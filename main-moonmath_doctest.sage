r"""
This file was *autogenerated* from main-moonmath.tex with sagetex.sty
version 2019/01/09 v3.2. It contains the contents of all the
sageexample environments from main-moonmath.tex. You should be able to
doctest this file with "sage -t main-moonmath_doctest.sage".

It is always safe to delete this file; it is not used in typesetting your
document.

Sage commandline, line 46::

sage: Groups()
sage: CommutativeAdditiveGroups()
sage: FiniteGroups()

Sage commandline, line 57::

sage: TrivialGroup = SymmetricGroup(1)

Sage commandline, line 79::

sage: CommutativeRings()
sage: CommutativeRings().super_categories()

Sage commandline, line 85::

sage: ZZ # A sage notation for the Ring of integers
sage: ZZ(5) # Get an element from the Ring of integers
sage: ZZ(5) + ZZ(3)
sage: ZZ(5) * ZZ(3)
sage: ZZ.random_element(10**50)
sage: ZZ(27713).str(2) # Binary string representation
sage: ZZ(27713).str(16) # Hexadecimal string representation

Sage commandline, line 155::

sage: Fields()

Sage commandline, line 160::

sage: QQ
sage: QQ(1/5) # Get an element from the field of rational numbers
sage: QQ(1/5) / QQ(3) # Division

Sage commandline, line 182::

sage: GF(2)
sage: GF(2)(1) # Get an element from GF(2)
sage: GF(2)(1) + GF(2)(1) # Addition
sage: GF(2)(1) / GF(2)(1) # Division

Sage commandline, line 213::

sage: ZZ(-17) // ZZ(4) # Integer quotient
sage: ZZ(-17) % ZZ(4) # remainder
sage: ZZ(-17).divides(ZZ(4))
sage: ZZ(4).divides(ZZ(12))

Sage commandline, line 246::

sage: ZZ(157843853).quo_rem(ZZ(261)) # Euclidean Division
sage: ZZ(604765)*ZZ(261) + ZZ(188) # check

Sage commandline, line 294::

sage: ZZ(12).xgcd(ZZ(5)) # (gcd,s,t)

Sage commandline, line 317::

sage: ZZ(7) % ZZ(271) == ZZ(2446) % ZZ(271)

Sage commandline, line 331::

sage: ZZ(64)** ZZ(137) % ZZ(137) == ZZ(64)
sage: ZZ(64)** ZZ(137-1) % ZZ(137) == ZZ(1)

Sage commandline, line 392::

sage: CRT_list([4,1,3,0], [7,3,5,11])

Sage commandline, line 457::

sage: Z6=Integers(6) # Define integers modulo 6
sage: Z6(2)+Z6(5) # standard representatives of a class
sage: Z6(14)+Z6(-1) # different representatives for same class
sage: - Z6(2) # additive inverse
sage: Z6(5)**(-1) # multiplicative inverse if exists

Sage commandline, line 492::

sage: Z6x = Z6['x']
sage: Z6x
sage: p = Z6x([1,2,3,4])
sage: p

Sage commandline, line 502::

sage: p.degree()
sage: Z6x([0]).degree()

Sage commandline, line 517::

sage: q = Z6x([5,-3,2,])
sage: p + q
sage: p*q
sage: p^2

Sage commandline, line 903::

sage: EllipticCurve(GF(5),[1,0])
sage: EllipticCurve(GF(5),[1,0]).trace_of_frobenius()

Sage commandline, line 1304::

sage: F43 = GF(43)
sage: F43t.<t> = F43[]
sage: F43_6.<v> = GF(43^6, name='v', modulus=t^6+6) # t^6+6 irreducible
sage: BLS6 = EllipticCurve (F43_6,[0 ,6])
sage: INF = BLS6(0) # point at infinity
sage: for P in INF.division_points(13): # PI(P) == [q]P
....:     if P.order() == 13: # exclude point at infinity
....:         PiP = BLS6([a.frobenius() for a in P])
....:         qP = 43*P
....:         if PiP == qP:
....:             print(P.xy())

Sage commandline, line 1342::

sage: g1 = BLS6([13,15])
sage: g2 = BLS6([7*v^2, 16*v^3])
sage: g1.weil_pairing(g2,13)

Sage commandline, line 1368::

sage: F13 = GF(13)
sage: for A in xrange(3, 13):
....:     if (A-2) % 4 != 0:
....:         continue
....:     try:
....:         E = EllipticCurve(F13, [0, A, 0, 1, 0]) # Montgomery form
....:         E
....:         E.order()
....:     except:
....:         continue

Sage commandline, line 1383::

sage: for d in F13:
....:     j= ZZ(0)
....:     for x in F13:
....:         for y in F13:
....:             if x^2+y^2 == 1+d*x^2*y^2:
....:                 j=j+1
....:     print('d=',d)
....:     print('order=',j)

Sage commandline, line 1404::

sage: for x in F13:
....:     for y in F13:
....:         if x^2+y^2 == F13(1)+F13(7)*x^2*y^2:
....:             print(x,y)

Sage commandline, line 1438::

sage: def Edwards_add((x1,y1),(x2,y2),d):
....:     x3 = F13((F13(x1)*F13(y2)+F13(y1)*F13(x2))/((F13(1)+F13(d)*F13(x1)*F13
....: (x2)*F13(y1)*F13(y2))))
....:     y3 = F13((F13(y1)*F13(y2)-F13(x1)*F13(x2))/((F13(1)-F13(d)*F13(x1)*F13
....: (x2)*F13(y1)*F13(y2))))
....:     return (x3,y3)

Sage commandline, line 1532::

sage: F13 = GF(13)
sage: for A in xrange(3, 13):
....:     if (A-2) % 4 != 0:
....:         continue
....:     try:
....:         E = EllipticCurve(F13, [0, A, 0, 1, 0]) # Montgomery form
....:         E
....:         E.order()
....:     except:
....:         continue

Sage commandline, line 1547::

sage: j = ZZ(0)
sage: for a in F13:
....:     for d in F13:
....:         j = 0
....:         for x in F13:
....:             for y in F13:
....:                 if a*x^2 + y^2 == 1+d*x^2*y^2:
....:                     j=j+1
....:         print('curve: a=',a,'d=',d,'order:',j)

Sage commandline, line 1573::

sage: for x in F13:
....:     for y in F13:
....:         if F13(2)*x^2+y^2 == F13(1)+F13(11)*x^2*y^2:
....:             print(x,y)

Sage commandline, line 1601::

sage: def Edwards_add((x1,y1),(x2,y2),a,d):
....:     x3 = F13((F13(x1)*F13(y2)+F13(y1)*F13(x2))/((F13(1)+F13(d)*F13(x1)*F13(x2)*F13(y1)*F13(y2))))
....:     y3 = F13((F13(y1)*F13(y2)-F13(a)*F13(x1)*F13(x2))/((F13(1)-F13(d)*F13(x1)*F13(x2)*F13(y1)*F13(y2))))
....:     return (x3,y3)

Sage commandline, line 1631::

sage: F7 = GF(7)
sage: MNT4 = EllipticCurve (F7,[4 ,1])
sage: [P.xy() for P in MNT4.points() if P.order() > 1]

Sage commandline, line 1662::

sage: F7t.<t> = F7[]
sage: F7_4.<u> = GF(7^4, name='u', modulus=t^4+t+1) # embedding degree is 4
sage: MNT4 = EllipticCurve (F7_4,[4 ,1])
sage: INF = MNT4(0) # point at infinity
sage: for P in INF.division_points(5): # PI(P) == [q]P
....:     if P.order() == 5: # exclude point at infinity
....:         PiP = MNT4([a.frobenius() for a in P])
....:         qP = 7*P
....:         if PiP == qP:
....:             print(P.xy())

Sage commandline, line 1690::

sage: g1 = MNT4([0,1])
sage: g2 = MNT4(2*u^3 + 5*u^2 + 4*u + 2, 2*u^3 + 3*u + 5)
sage: g1.weil_pairing(g2,5)

Sage commandline, line 1766::

sage: G.<x> = GF(5^6) # embedding degree is 6
sage: MNT6 = EllipticCurve (G,[2 ,1])
sage: INF = MNT6(0) # point at infinity
sage: for P in INF.division_points(7): # PI(P) == [q]P
....:     if P.order() == 7: # exclude point at infinity
....:         PiP = MNT6([a.frobenius() for a in P])
....:         qP = 5*P
....:         if PiP == qP:
....:             print(P.xy())

"""
