\chapter{Preliminaries}

\section{Runtime complexity}

\commscomb{}{should this whole section be moved to section \ref{def:DL-secure}?}
Before we deal with the mathematics behind zero-knowledge proof systems, we must first say a few words about the runtime of an algorithm or the time complexity of a mathematical problem. This is particularly important for us when we analyze the security of various SNARK systems.

Roughly speaking, the runtime complexity of an algorithm describes the amount of elementary computation steps that this algorithm requires in order to solve a problem, depending on the size of the input data.

Of course, the exact amount of arithmetic operations required depends on many factors, such as the implementation, the operating system used, the CPU and so on. However, this level of accuracy is seldom required for our purposes, so the ``magnitude'' of the computational effort is used instead.

In other words, instead of specifying the individual calculation steps, we look for an upper limit which approximates the runtime as soon as the input quantity becomes very large. 

To talk about the security of cryptographic systems, we distinguish the following levels of complexity:
\begin{itemize}
\item $\mathcal{O}(n)$ means that the running time of the algorithm to be considered is linearly dependent on the size of the input set $n$
\item $\mathcal{O}(n^k)$ means that the running time is polynomial  
\item $\mathcal{O}(2^n) $ stands for an exponential running time. %\cite{JB} 
\end{itemize} 


An algorithm which has a running time that is greater than a polynomial is often simply referred to as \hilight{slow}.

A generalization of the runtime complexity of an algorithm is the so-called \term{time complexity of a mathematical problem}, which is defined as the runtime of the fastest possible algorithm that can still solve this problem.
%\cite{AB}.

Since the time complexity of a mathematical problem is concerned with the runtime analysis of all possible (and thus possibly still undiscovered) algorithms, this is often very difficult to determine.

For our topic, the time complexity of the so-called discrete logarithm problem  is particularly important (see \secname{} \ref{def:DL-secure}). This is a problem for which we only know slow algorithms on classical computers at the moment, but for which we cannot rule out that faster algorithms also exist.
 

\section{Software Used in This Book}
\label{sagemath_setup}
It order to provide an interactive learning experience, and to allow getting hands-on with the concepts described in this book, we give examples for how to program them in the \href{https://www.sagemath.org/}{SageMath} programming language. Sage is based on the learning-friendly programming language \href{https://www.python.org/}{Python},  extended and optimized for computations involving algebraic objects. Therefore, we recommend installing Sage before diving into the following chapters.

The installation steps for various system configurations are described on the \href{https://doc.sagemath.org/html/en/installation/index.html}{Sage website}. Note that we use Sage version 9, so if you are using Linux and your package manager only contains version 8, you may need to choose a different installation path, such as using prebuilt binaries.

If you are not familiar with SageMath, we recommend you consult the \href{https://doc.sagemath.org/html/en/tutorial/index.html}{Sage Tutorial}.




