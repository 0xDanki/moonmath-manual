\chapter{Arithmetics}
% Reason why we need a math-chapter in a book like this:
How much mathematics is needed to understand zero knowledge proofs? The answer, of course, depends on many things like the level of detail the reader want to understand them. For example it is possible to describe those proofs not using mathematics at all. However to read a foundational paper like [GROTH16], enough mathematics is needed to at least understand the basic concepts. 

Otherwise any student who is interested in learning the concepts, but who
has never seen or played with, say, a finite field, or an elliptic curve, may quickly become overwhelmed. This is not so much due to the complexity of the mathematics needs but perhaps more because of the vast amount of technical jargon, of unknown terms, obscure symbols that quickly makes a text ubreadable, desipte the concepts being actually not that hard. As a result the reader might either loose interest, or gain some dangerous smattering that in a worst case scenario materialize in inmature code. 

In this chapter we therefore derive the mathematical concepts needed to understand the basic concepts underlying snark development and we encourage the reader who is not familiar with basic number theory and lliptic curves to take the time and read this chapter until they are able to at least solve most of the simple exercises. 

If on the other hand the reader is already skilled in elliptic curve cryptography they might skip this section and only come back for reference and comparision. Maybe the most interesing parts are XXX.

We start at a very basic level and only really requie fundamntal concepts like integer arithmetics. At the same time we'll have a focus on teaching the reader how to think mathematically and to understand that there are numbers and methatical structures out there that appear to be very different from the stuff we learned in school and yet on a deeper level they are in deed very similar.

We want to stress however, that our introduction is informal, incomplete and optimized to enable the reader to understand zero knowledge concepts as efficient as possible. Our focus and design choices are so that we give as little theory as necessary but accompanied by a wealth of numerical examples. We found this on the believe, that such an informal, example-
driven approach to learning mathematics may ease the beginnerâ€™s digestion in the initial stages. 

For instance, a beginner would be likely to find it more beneficial to first compute a simple toy snark in a pen and paper style all the way through all steps before they dig deeper and actually devop real world production ready systems. Also having already a few simple examples in you head, its likely easier to only then read the actual academic papers. 

However in order to be able to derive those toy example, some mathematical groundwork is needed. This chapter therefore will help the reader to focus on what is important, while at the same time serve as first exercises the reader is encouraged to recompute themself. Every section usually then ends with a list of additional exercises in increasing difficulty order, to help the reader memorising and applying the concepts given. 

Overall the goal of this chapter is to provide a reader who is starting with nothing more than basic high school algebra, to be able to solve basic tasks in elliptic curve cryptography without the need of a computer.


%Summary of this chapter
We start with a brief recapitulation of basic integer aithmetics like long division, the greatest common divisior and Euklids algorithm. After that we introduce modular arithmetics as \textbf{the most important} skill to compute our pen and paper examples. We then introduce polynomials, compute their analogs to integer arithmetics and introduce the important concept of Lagrange interpolation.

After this practical warm up, we have to introduce some basic algebraic terms like groups and fields, because those terms are all over the place when reading academic papers in the context of zero knowledge proof. The beginner is good adviced to memorize those terms and think about them. We define these terms in the general abstract way of mathematics, hoping that the non mathematical trained reader will gradually learn to become comfortable with this style. We then give basic examples and do basic computations with these examples to get familiar with the concepts. 

\section{Integer Arithmetics}
\label{integer_arithmetics}
To some degree, most readers with probably remember integer arithmetics from school. It is however important for the rest of the book to be able to apply those concepts to understand and execute computations in the various pen and paper examples that are the main contribution of the moon math manual. We will therefore recapitulate those concepts filling up some knowledge gaps.

In what follows we applay standard mathematical notations and use the symbol $\mathbb{Z}$ for the set of all integers, that is we write
\begin{equation}
\label{integer_symbol}
\Z := \{\ldots, -3,-2,-1,0,1,2,3,\ldots\}
\end{equation}
So whenever you see the symbol $\mathbb{Z}$, think of the set of all integers. If $a \in \Z$ is an integer, we write $|a|$ for the \textit{absolute value} of $a$, that is the the non-negative value of $a$ without regard to its sign. In addition we will use the symbol $\N$ for the set of all counting numbers, that is we write 
\begin{equation}
\label{integer_symbol}
\N := \{0,1,2,3,\ldots\}
\end{equation}
including the number $0$. So whenever you see the symbol $\mathbb{N}$, think of the set of all non negative integers. 

To make it easier to memorize new concepts and symbols, we might frequently link to definitions (See \ref{integer_symbol} for a definition of $\Z$) in the begining, but as to many links render a text unreadable, we will assume the reader will become familiar with definitions as the text proceeds at which point we will not link them anymore. 

Both sets $\N$ and $\Z$ have a notion of addition as well as multiplication dedined on them and also most of us are probably able to do many integer computations in their head, we will frequently invoke the sagemath system (\ref{sagemath_setup}) for more complicated computations. One way to invoke the integer-type in sage is:
\begin{sagecommandline}
sage: ZZ # A sage notation for the integer type
sage: NN # A sage notation for the counting number type
sage: ZZ(5) # Get an element from the Ring of integers
sage: ZZ(5) + ZZ(3)
sage: ZZ(5) * NN(3)
sage: ZZ.random_element(10**50)
sage: ZZ(27713).str(2) # Binary string representation
sage: NN(27713).str(2) # Binary string representation
sage: ZZ(27713).str(16) # Hexadecimal string representation
\end{sagecommandline}
Of particular interest for us are the so called \textit{prime numbers}, which are counting numbers $ p \in \N $ with $ p \geq 2 $, which are divisible by themself and by $ 1 $ only. Prime numbers are called \textit{odd} if they are not the number $ 2 $. We write $ \Prim $ for the set of all prime numbers and $ \Prim _{\geq 3} $ for the set of all odd prime numbers.
$\Prim$ is infinite and can be ordered according to size, so that we can writem them as
\begin{equation}
\label{eq: primenumber_sequence}
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, \ldots
\end{equation}
which is sequence $ A000040 $ in OEIS. In particular, we can talk about small and large prime numbers.

As the \textit{fundamental theorem of arithmetics} tells us, prime numbers are in a certain sense the basic building blocks from which all other natural numbers are composed. To see that, let $ n \in \N_{\geq 2} $ be any natural number. Then there are always prime numbers $ p_1, p_2, \ldots, p_k \in \Prim $, such that
\begin{equation}
n = p_1 \cdot p_2 \cdot \ldots \cdot p_k \;.
\end{equation}
This representation is unique, except for permutations in the factors and is called the \textbf{prime factorization} of $n$.
\begin{example}[Prime Factorization] To see what we mean by integer factorization, lets look at the number $19214758032624000$. To get its prime factors, we can sucessively divide it by all prime numbers in ascending order starting with $2$. We get
\begin{equation*}
19214758032624000 = 2\cdot 2\cdot 2\cdot 2\cdot 2\cdot 2\cdot 2 \cdot 3\cdot 3\cdot 3\cdot 5\cdot 5\cdot 5\cdot 7 \cdot 11 \cdot 17\cdot 17 \cdot 23 \cdot 43\cdot 43 \cdot 47
\end{equation*}
We can double check our findings invoking sage, which provides an algorith to factor counting numbers:
\begin{sagecommandline}
sage: n = ZZ(19214758032624000)
sage: factor(n)
\end{sagecommandline}
\end{example}
Having done the computation from the previous example, reveals an important observation: Computing the factorization was computationally expensive, while on the other hand, giving a string of prime numbers, computing their product is fast. 

From this an important question arises: How fast we can compute the prime factorization of a natural number? This is the famous \textit{factorization problem} and as far as we know, there is no method on a classical Turing machine that is able to compute this representation in polynomial time. The fastest algorithms known today run sub-exponentially, with $\mathcal{O}((1+ \epsilon)^n)$ and some $ \epsilon> 0 $.

It follows that integer factorization $\Leftrightarrow$ prime number multiplication is an example of, what is called a one-way.function. Something that is easy to compute in one direction, but hard to compute in the other direction. Existence of one way functions like this are basic crytographic assumptions, that the security of many crypto systems is based on.

It should be pointed out however hat the American mathematician Peter Williston Shor developed an algorithm in 1994 which can calculate the prime factor representation of a natural number in polynomial time on a quantum computer. The consequence of this is, of course, that cryosystems, which are based on the time complexity of the prime factor problem, are unsafe as soon as practically usable quantum computers are available.
\begin{exercise}
Compute the factorization of $6469693230$ and double check your results using sage.
\end{exercise}

\paragraph{Euklidean Division}
\label{Euklidean_division}
In general there is no division defined in the usual sense for integers, as for example $7$ divided by $3$ will not be an integer again. However it is possible to devide any two integers with a remainder. So for example $7$ divided by $3$ is equal to $2$ with a remainder of $1$, since $7 = 2\cdot 3 + 1$. 

Doing integer division like this is probably something many of us remember from school. It is 
usually called \textit{Euclidean division}, or division with remainder and it is an important technique, that every reader must become familiar with to understand many concepts in this book. The precise definition is as follows:

Let $ a \in \Z $ and $ b \in \Z $ be two integers. Then there is always another integer $ m \in \Z $ and a counting number $ r \in \N $, with $ 0 \leq r <|b| $ such that
\begin{equation}
\label{eq_euklidean_division}
a = m \cdot b + r
\end{equation}
This decomposition of $a$ given $b$ is called \textit{Euklidean division}, where $ a $ is called the \textit{divident}, $ b $ is called the \textit{divisor}, $m$ is called the \textit{quotient} and $r$ is called the \textit{remainder}. 
\begin{notation}
\label{eq_euklidean_division_notation}
Suppose that the numbers $ a, b, m $ and $ r $ satisfy equation (\ref{eq_euklidean_division}). Then we often write 
\begin{equation}
\label{def_integer_division_and_modulus}
\begin{array}{lcr}
\Zdiv{a}{b}: = m, & & \Zmod{a}{b}: = r 
\end{array}
\end{equation}
to describe the quotient and the remainder of the Euklidean division. We also say, that an integer $ a $ is divisible by another integer $ b $ if $ \Zmod{a}{b} = 0 $ holds. In this case we also write $ a | b $.
\end{notation}
So in a Nutshell Euclidean division is a process of dividing one integer by another, in a way that produces a quotient and a non negative remainder the latter of which is smaller than the absolute value of the divisor. It can be shown, that both the quotient and the remainder always exist and are unique, as long as the divident is different from $0$.

A special situation occures, is the remainder is zero, because in this special case the divident \textit{is} divisible by the divisor. Our notation $a|b$ refelcts that. 


\begin{example} Applying Euklidean division and our previously defined notation \ref{def_integer_division_and_modulus} to the divisor $-17$ and the divident $4$, we get 
\begin{equation*}
\begin{array}{lcr}
\Zdiv{-17}{4} = - 5, & & \Zmod{-17}{4} = 3
\end{array}
\end{equation*}
because $ -17 = -5 \cdot 4 + 3 $  is the Euklidean division of $-17$ and $4$ (Since the remainder is by definition a non-negative number). In this case $4$ does not divide $-17$ as the reminder is not zero. Writing $-17 | 4$ therefore has no meaning. On the other hand we can write $12 | 4$, since $4$ divides $12$, as $ \Zmod{12}{4} = 0 $. We can invoke sagemath to do the computation for us. We get
\begin{sagecommandline}
sage: ZZ(-17) // ZZ(4) # Integer quotient 
sage: ZZ(-17) % ZZ(4) # remainder 
sage: ZZ(4).divides(ZZ(-17)) # self divides other
sage: ZZ(4).divides(ZZ(12))
\end{sagecommandline}
\end{example}
Methods to compute Euklidean division for integers are called \textit{integer division algorithms}. Probably the best known algorithm is the so called \textit{long division}, that most of us might have learned in school. It should be noted however that there are faster methods like \textit{Newtonâ€“Raphson division}.

As long division is the standard method used for pen-\&-paper division of multi-digit numbers expressed in decimal notation, the reader should become familiar with it as we use it all over this book when we do simple pen-and-paper computations. However instead of defining the algorithm formally, we rather give some examples, that hopelly will make the process clear

\begin{example}[Integer Long Division] To give an example of integer long division algorithm, lets divide the integer $a=143785$ by the number $b=17$. Our goal is therfore to find solutions to equation \ref{eq_euklidean_division}, that is we need to find the quotient $m\in\Z$ and the reminder $r \in \N$ such that $143785 = m\cdot 17 + r$. Using a notation that is mostly used in Commonwealth countries, we compute
\begin{equation}
\intlongdivision{143785}{17}
\end{equation}
We therefore get $m=8457$ as well as $r=16$ and indeed we have $143785 = 8457\cdot 17 + 16$, which we can double check invoking sage:
\begin{sagecommandline}
sage: ZZ(143785).quo_rem(ZZ(17)) # Euclidean Division
sage: ZZ(143785) == ZZ(8457)*ZZ(17) + ZZ(16) # check
\end{sagecommandline}
In a nutshell, the algorithm loops through the digits of the divident from the left to right, subtracting the largest possible multiple of the divisor (at the digit level) at each stage; the multiples then become the digits of the quotient, and the remainder is the first digit of the divident.
\end{example}
\begin{exercise}[Integer Long Division]
Find an $m\in\Z$ as well as an $r\in\N$ such that $a= m\cdot b +r$ (See equation \ref{eq_euklidean_division}) holds for the folling pairs $(a,b) = (27,5)$, $(a,b)=(27,-5)$, $(a,b)=(127,0)$, $(a,b)= (-1687, 11)$. In which cases are your solutions unique?
\end{exercise}
\begin{exercise}[Long Division Algorithm]
Write an algorithm in pseudocode that computes integer long division, handling all edge cases properly.
% https://en.wikipedia.org/wiki/Division_algorithm
\end{exercise}

\paragraph{The Extended Euklidean Algorithm}
One of the most critical parts in this book is modular arithmetics XXX and its application in the computations in so called finite fields, as we explain in XXX. In modular arithmetics it is sometimes possible to define actual division and multiplicative inverses of numbers, that is very different from inverses as we know them from other systems like factional numbers. 

However, to actually compute those inverses we have to get familar with the so-called \textit{extended Euclidean algorithm}. To recapitulate jargon first, the \textit{greatest common divisor} (GCD) of two nonzero integers $a$ and $b$ is the greatest non-zero counting number $d$ such that $d$ divides both $a$ and $b$; that is $d|a$ as well as $d|b$. We write $ gcd (a, b):=d $ for this number. In addition two counting numbers are called \textbf{relative prime}, if their greates common divisor is $1$.

The extended Euclidean algorithm is then a method to calculate the greatest common divisor of two counting numbers $ a $ and $ b \in \N $, as well as two additional integers $ s, t \in \Z $, such that the equation
\begin{equation}
\label{eq: erw_Eukl_algo}
gcd (a, b) = s \cdot a + t \cdot b
\end{equation}
holds. The following pseudocode shows in detail how to calculate these numbers with the extended Euclidean algorithm (\cite{JB} chapter 2.9):

\begin{algorithm}\caption{Extended Euklidean Algorithm}
\label{alg_ext_euclid_alg}
\begin{algorithmic}[0]
\Require $a,b \in \N$ with $a\geq b$
\Procedure{Ext-Euclid}{$a,b$}
\State $r_0\gets a$
\State $r_1\gets b$
\State $s_0\gets 1$
\State $s_1\gets 0$
\State $k\gets 1$
\While{$ r_{k} \neq 0 $}
\State $ q_k\gets \Zdiv{r_{k-1}}{r_k} $
\State $ r_{k + 1}\gets r_{k-1} -q_k \cdot r_k $
\State $ s_{k + 1}\gets s_{k-1} -q_k \cdot s_k $
\State $ k \gets k + 1 $
\EndWhile
\State \textbf{return} $gcd(a,b)\gets r_{k-1}$, $s\gets s_{k-1}$ and $ t: = \Zdiv{(r_{k-1}-s_{k-1} \cdot a)}{b} $ 
\EndProcedure
\Ensure $ gcd (a, b) = s \cdot a + t \cdot b $
\end{algorithmic}
\end{algorithm}
The algorithm is simple enough to be done effectively in pen-\&-paper examples, where it is common to write it as a table where the rows represent the while-loop and the colums represent the values of the the array $r$, $s$ and $t$ with index $k$. The following example provides a simple execution:
\begin{example} To illustrate the algorithm, lets apply it to the numbers $a=12$ and $b=5$. Since $12,5\in \N$ as well as $12\geq 5$ all requirements are meat and we compute
\begin{center}
  \begin{tabular}{c | c c l}
    k & $ r_k $ & $ s_k $ & $ t_k = \Zdiv{(r_k-s_k \cdot a)}{b} $ \\\hline
    0 & 12 & 1 & 0 \\
    1 & 5 & 0 & 1 \\
    2 & 2 & 1 & -2 \\
    3 & 1 & -2 & 5 \\
  \end{tabular}
\end{center}
From this we can see that $ 12 $ and $ 5 $ are relatively prime (coprime), since their greatest common divisor is $ gcd (12, 5) = 1 $ and that the equation $ 1 = (-2) \cdot 12 + 5 \cdot 5 $ holds. We can also invoke sage to double check our findings:
\begin{sagecommandline}
sage: ZZ(12).xgcd(ZZ(5)) # (gcd(a,b),s,t)
\end{sagecommandline}
\end{example}
\begin{exercise}[Extended Euklidean Algorithm]
Find integers $s,t\in\Z$ such that $gcd(a,b)= s\cdot a +t\cdot b$ holds for the folling pairs $(a,b) = (45,10)$, $(a,b)=(13,11)$, $(a,b)=(13,12)$. What pairs $(a,b)$ are coprime?
\end{exercise}
\begin{exercise}[Towards Prime fields]
Let $n\in \N$ be a counting number and $p$ a prime number, such that $n<p$. What is the greatest common divisor $gcd(p,n)$?
\end{exercise}

\section{Modular arithmetic}
% TODO: Introduce the term residue class
In mathematics, so called \textit{modular arithmetic} is a system of arithmetic for integers, where numbers "wrap around" when reaching a certain value, much like calculations on a clock wrap around whenever the value exceeds the number $12$, $24$ or $60$, depending on your clock. For example if the clock shows that it is $11$ o'clock, then $20$ hours later it will be $7$ o'clock, not $31$ o'clock. The letter of which has no meaning on a normal clock that shows hours. 

The number at which the wrap occures is called the \textit{modulus}. Modular arithmetics generalizes the clock example to arbitrary moduli and studies equations and phenomena that arizes in this new kind of arithmetics. It is of central importance for understanding most modern crypto systems, in large parts because the exponentiation function has an inverse with respect to certain moduli, that is hard to compute. In addition we will see that it provides the foundation of what is called finite fields (See XXX)

Also it will turn out that modular arithmetic appears very different from ordinary integer arithmetic that we are all familiar with, we encouurage the interested reader to work through the example and to discover that, once they accept that this is a new kind of calculations, its actually not that hard.
\paragraph{Congurency}
In what follows, let $n\in\N$ with $n\geq 2$ be a fixed counting number, that we will call the \textit{modulus} of our modular arithmetics system. With such an $n$ given, we can then group integers into classes, by saying that two integers are in the same class, whenever their Euklidean division \ref{Euklidean_division} by $n$ will give the same remainder. We then say that two numbers are \textit{congruent} whenever they are in the same class.

\begin{example}
If we choose $n=12$ as in our clock example, then the integers $-7$, $5$, $17$ and $29$ are all congruent with respect to $12$, since all of them have the remainder $5$ if we Euklidean divide them by $12$. In the picture of an analog $12$-hour clock, starting at $5$ o'clock, when we add $12$ hours we are again at $5$ o'clock, representing the number $17$. On the other hand when we subtract $12$ hours, we are at $5$ o'clock again, representing the number $-7$. 
\end{example}
We can formulize this intuition of what congruency should be into a proper definition utilizing Euklidean division as explained previously \ref{integer_arithmetics}: Let $ a $, $ b \in \Z $ be two integers and $ n \in \N $ a natural number.
Then $ a $ and $ b $ are said to be \textbf{congruent with respect to the modulus} $ n $, if and only if the equation
\begin{equation}
\Zmod{a}{n} = \Zmod{b}{n}
\end{equation}
holds. If on the other hand two numbers are not congruent with respect to a given modulus $n$, we call them \textit{incongruent} w.r.t. $n$. 

A \textit{congruency} is then nothing but an equation "up to congruency", which means that the equation only needs to hold if we take the modulus on both sides. In which case we write 
\begin{equation}
\kongru{a}{b}{n} 
\end{equation}
\paragraph{Modular Arithmetics}
On particulary nice thing about congruencies is, that we can do calculations (aithmetics), much like we can with integer equations. That is we can add or multiply numbers on both sides. The main difference is probably that the congruency $\kongru{a}{b}{n}$ is only equivalent to the congruency $\kongru{k\cdot a}{k\cdot b}{n}$ for some non zero integer $k\in \Z$, whenever $k$ and the modulus $n$ are coprime. The following list gives a set of useful rules:

Suppose that the congurencies $\kongru{a_1}{b_1}{n}$ as well as $\kongru{a_2}{b_2}{n}$ are satisfied for integers $a_1,a_2,b_1,b_2\in\Z$ and that $k\in\Z$ is another integer. Then:
\begin{itemize}
\item $\kongru{a_1+k}{b_1+k}{n}$ (compatibility with translation)
\item $\kongru{k\cdot a_1}{k\cdot b_1}{n}$ (compatibility with scaling)
\item $\kongru{a_1+a_2}{b_1+b_2}{n}$ (compatibility with addition)
\item $\kongru{a_1\cdot a_2}{b_1\cdot b_2}{n}$ (compatibility with multiplication)
\end{itemize}
Other rules like compatibility with subtraction and exponentiation follow from this rule, as for example compatibility with subtraction is compatibility with scaling by $k=-1$ and compatibility with addition.

Note that the previous rules are implications not equivalences, which means that you can not necessarily reverse those rules. The following rules makes this precise:
\begin{itemize}
\item If $\kongru{a_1+k}{b_1+k}{n}$, then $\kongru{a_1}{b_1}{n}$
\item If $\kongru{k\cdot a_1}{k\cdot b_1}{n}$ and $k$ is coprime with $n$, then $\kongru{a_1}{b_1}{n}$
\item If $\kongru{k\cdot a_1}{k\cdot b_1}{k\cdot n}$ , then $\kongru{a_1}{b_1}{n}$
\end{itemize}
Another property of congruencies, not known in the traditional arithmetics of integers is the so called \textit{Fermat's Little Theorem}. In simple words, it says that in modular arithmetics every number raised to the power of a prime number modulus is congruent to the number itself. Or, to be more precise, if $ p \in \Prim $ is a prime number and $ k \in \mathbb{Z} $ is an integer, then:
\begin{equation}
\kongru{k ^ p}{k}{p} \;,
\end{equation}
If $k$ is coprime to $p$, then we can divide both sides of this congruency by $k$ and rewrite the expression into the equivalent form 
\begin{equation}
\label{eq_fermat_lt_2}
\kongru{k ^{p-1}}{1}{p}
\end{equation} 
We can invoke sage, to compute examples for both $k$ being coprime and not coprime to $p$:
\begin{sagecommandline}
sage: ZZ(137).gcd(ZZ(64))
sage: ZZ(64)** ZZ(137) % ZZ(137) == ZZ(64) % ZZ(137)
sage: ZZ(64)** ZZ(137-1) % ZZ(137) == ZZ(1) % ZZ(137)
sage: ZZ(1918).gcd(ZZ(137))
sage: ZZ(1918)** ZZ(137) % ZZ(137) == ZZ(1918) % ZZ(137)
sage: ZZ(1918)** ZZ(137-1) % ZZ(137) == ZZ(1) % ZZ(137)
\end{sagecommandline}
\begin{remark}
Congruency \ref{eq_fermat_lt_2} has a nice interpretation, that gives a first glimpse of the idea of a prime field as we will describe it in XXX: Whenever the modulus is a prime number and $k<p$ then $k$ and $p$ are coprime (Exercise XXX) and hence there is a notion of division by $k$, that is absent in integer arithmetics. If $a$ is another integer we could define division by $k$ as follows $a/k := a\cdot k^{p-2}$, which is always defined. This makes sense because "division by something" should be defined as "multiplication by the inverse" and since $\kongru{k\cdot k ^{p-2}}{1}{p}$, the number $k^{p-2}$ behaves like a multiplicative inverse for $k$ in modular arithmetics for prime number moduli and coprime $k$.
\end{remark}

Now, since this was a lot to digest for a reader who has never encountered modular arithmetics before, lets compute an example that contains most of the stuff we just described:   
   
\begin{example}Assume that we choose the modulus $17$ and that our task is to solve the following congruency for $x\in \Z$
$$\kongru{7\cdot(2x+21) + 11}{x-102}{17}$$
As many rules for congruencies are more or less same as for integers, we can proceed in a way similar, as we would if we had an equation to solve. 
The first thing we notice, is that $7\cdot(2x+21) + 11= 14x +158$, since both sides of a congruency contain ordinary integers. We can therefore rewrite the congruency into the equivalent form
$$\kongru{14x +158}{x-102}{17}$$
In a next step we want to shift all encounters of $x$ to left and every other term to the right. So we applay the "compatibility with translation" rules two times. In a first step we choose $k=-x$ and in a second step we choose $k=-158$. Since "compatibility with translation" transforms a congruency into an equivalent form, the solution set will not change and we get 
\begin{multline*}
\kongru{14x +158}{x-102}{17} \Leftrightarrow\\
\kongru{14x-x +158-158}{x-x-102-158}{17} \Leftrightarrow \\
\kongru{13x}{-260}{17}
\end{multline*}
If our congruency would just be a normal integer equation, we would divide both sides by $13$ to get $x=-20$ as our solution. However in case of a congruency we need to make sure that the modulus and the number we want to divide by are coprime first. Only then will we get an equivalent expression. So we need to the greatest common divisor $gcd(17,13)$ and since both numbers are prime, we know $gcd(17,13)=1$, so both numbers are indeed coprime. We therefore compute 
$$
\kongru{13x}{-260}{17} \Leftrightarrow \kongru{x}{-20}{17}
$$
Our task is now to find all integers $x$, such that $x$ is congruent to $-20$ with respect to the modulus $17$. So we have to find all $x$ such
$$
\Zmod{x}{17} = \Zmod{-20}{17}
$$
Since $-2\cdot 17 +14 = -20$ we know $ \Zmod{-20}{17} = 14$ and hence we know that $x=14$ is a solution. However $31$ is another solution since $ \Zmod{31}{17} = 14$ as well and so is $-20$. In fact there are infinite many solutions given by the set
$$
\{\ldots, -20,-3, 14,31, 48,\ldots\} = \{14+k\cdot 17 \;|\; k\in \Z\}
$$
Putting all this together we have shown that the every $x$ from the set $\{x=14+k\cdot 17 \;|\; k\in \Z\}$ is a solution to the congruency $\kongru{7\cdot(2x+21) + 11}{x-102}{17}$. We double ckeck for, say, $x=14$ as well as $x=14 + 12\cdot 17 = 218$ using sage:
\begin{sagecommandline}
sage: (ZZ(7)* (ZZ(2)*ZZ(14) + ZZ(21)) + ZZ(11))  % ZZ(17) == (ZZ(14) - ZZ(102))  % ZZ(17)
sage: (ZZ(7)* (ZZ(2)*ZZ(218) + ZZ(21)) + ZZ(11))  % ZZ(17) == (ZZ(218) - ZZ(102))  % ZZ(17)
\end{sagecommandline}
\end{example}
\begin{example}[Mudular multiplicative inverse] In the previous example we encounter the "lucky coincidence", that we could solve the congruency $\kongru{13x}{-260}{17}$ by division by $13$, since $260$ is divisible by $13$ as integers. But what if this is not the case?
So see how this can be solved in modular arithmetics lets consider the following modification of the congruency in the previous example:
$$
\kongru{7x}{-260}{17}
$$ 
In this example we can not integer divide both sides of the congruency by $7$, since $260/7$ is not an integer. However we recall from Fermats little theorem, that $\kongru{k\cdot k^{p-2}}{1}{p}$ for every integer $k$ that coprime to every prime modulus $p$. 

In our example, since $7$ is coprime to $17$ (both are prime numbers), we can exploit Fermats theorem, in combination with the "compatibility with scaling" rule and multiply both sides of the congruency with $7^{17-2}= 4747561509943$. We then get
\begin{multline*}
\kongru{7x}{-260}{17} \Leftrightarrow \\
\kongru{7^{17-2}\cdot 7\cdot x}{-260\cdot 7^{17-2}}{17}\Leftrightarrow \\
%\kongru{x}{-260\cdot 4747561509943}{17} \Leftrightarrow \\
\kongru{x}{-1234365992585180}{17} 
\end{multline*}
And since $\Zmod{-1234365992585180}{17}=9$, we know that the solution is given by the set of all numbers $x\in \{9+m\cdot 17\;|\; m\in\Z\}$. We double ckeck for, say, $x=9$ as well as $x=9 + 101\cdot 17 = 1726$ using sage:
\begin{sagecommandline}
sage: (ZZ(7)* ZZ(9))  % ZZ(17) == (-ZZ(260))  % ZZ(17)
sage: (ZZ(7)* ZZ(1726))  % ZZ(17) == (-ZZ(260))  % ZZ(17)
\end{sagecommandline}
\end{example}
\begin{remark}
The discouraged reader, who at this point thinks that modular aithmetics is to complicated, might consider two thinks: First, computing congruencies in modular arithmetics is not really more complicated then computations in more familiar number systems like fractional numbers. Its just a matter of getting used to it. Second, the theory of prime fields (and more general residue class rings) takes a different view on modular rithmetics with the attempt to simplify thinks. In other words, once we understand prime field arithmetics, thinks become conceptually cleaner and more easy to compute.
\end{remark}
\paragraph{The Chinese Remainder Theorem} We have seen in the previous paragraph how to solve congruencies in modular arithmetic. However one question that remains is, how to solve systems of congruencies, whith different moduli? The answer is given by the so called \textit{Chinese raimainder theorem}, which tells us, that for any $ k \in \N $ and coprime natural numbers $ n_1, \ldots n_k \in \N $ as well as integers $ a_1, \ldots a_k \in \Z $, the so-called \textit{simultaneous congruency}
\begin{equation}
\label{eq_simultaneous_congruency}
\begin{array}{c}
\kongru{x}{a_1}{n_1} \\
\kongru{x}{a_2}{n_2} \\
\cdots \\
\kongru{x}{a_k}{n_k} \\
\end{array}
\end{equation}
has a solution and all possible solutions of this congruence system are congruent modulo
the product $N= n_1 \cdot \ldots \cdot n_k $. In fact, the following algorithm computes the solution set:
\begin{algorithm}\caption{Chinese Reminder Theorem}
\label{alg_ext_euclid_alg}
\begin{algorithmic}[0]
\Require $n_0,\ldots,n_{k-1} \in \N$ coprime
\Procedure{Congruency-Systems-Solver}{$k,a_{0,\ldots,k-1},n_{0,\ldots,k-1}$}
\State $N\gets n_0\cdot \ldots \cdot n_{k-1}$
\While{$j< k $}
\State $N_j\gets N/n_j$
\State $(\_,s_j,t_j)\gets EXT-EUCLID (N_j,n_j)$ 
  \Comment{$1 = s_j\cdot N_j + t_j\cdot n_j$}
\EndWhile
\State $x'\gets \sum_{j=0}^{k-1}a_j\cdot s_j\cdot N_j$
\State $x\gets \Zmod{x'}{N}$
\State \textbf{return} $\{x+ m\cdot N\;|\; m\in \Z\}$
\EndProcedure
\Ensure $\{x+ m\cdot N\;|\; m\in \Z\}$ is the complete solution set to \ref{eq_simultaneous_congruency}.
\end{algorithmic}
\end{algorithm}

This is the classical Chinese remainder theorem as it was already known in ancient China. Under certain circumstances, the theorem can be extended to non-coprime moduli $ n_1, \ldots, n_k $ but we don't need that extension in the book.
\begin{example} To illustrate how to solve simultaneous congruences using the Chinese remainder theorem, let's look at the following system of congruencies:
$$
\begin{array}{c}
\kongru{x}{4}{7} \\
\kongru{x}{1}{3} \\
\kongru{x}{3}{5} \\
\kongru{x}{0}{11} \\
\end{array}
$$
Clearly all moduli are coprime and we have $ N = 7 \cdot 3 \cdot 5 \cdot 11 = 1155 $, as well as
$ N_1 = 165 $, $ N_2 = 385 $, $ N_3 = 231 $ and $ N_4 = 105 $. From this we calculate with the extended Euclidean algorithm
$$
\begin{array}{cccc}
 1 = & 2 \cdot 165  & + & -47 \cdot 7 \\
 1 = & 1 \cdot 385  & + &  -128 \cdot 3 \\
 1 = & 1 \cdot 231  & + &  -46 \cdot 5 \\
 1 = & 2 \cdot 105  & + &  -19 \cdot 11 \\
\end{array}
$$
so we have
$x = 4 \cdot 2 \cdot 165 + 1 \cdot 1 \cdot 385 + 3 \cdot 1 \cdot 231 + 0 \cdot 2 \cdot 105 = 2398$
as one solution. Because $ \Zmod{2398}{1155} = 88 $ the set of all solutions is
$ \{\ldots, -2222, -1067,88,1243, 2398, \ldots \} $. In particular, there are infinitely many different solutions. We can invoke sage's computation of the Chinese Remainder Theorem (CRT) to double check our findings:
\begin{sagecommandline}
sage: CRT_list([4,1,3,0], [7,3,5,11])
\end{sagecommandline}
\end{example}
As we have seen in various examples before, computing congruencies can be cumersome and solution sets are huge in general. It is therefore advantagous to find some kind of simplification for modular arithmetic. Fortunately this is possible if we consider all integers that have the same remainder with respect to a given modulus $n$ to be the same. It then follows from the properties of Euclidean division, that there are exactly $ n $ different such sets for every moduls. 

If we go a step further and identify each such set (equivalence class) with the corresponding remainder of the Euclidean division, we get a new set, where integer addition and multiplication can be projected to a new kind of addition and multiplication on the equivalence classes. 

Roughly speaking the new rules for addition and multiplication are then computed by taking any element of the firsr equivalence class and some element of the second, then add or multiply them in the usual way and see in which equivalence class the result is contained.
The following example makes the abstract idea more concrete
\begin{example} [Arithmetics modulo $6$]
\label{def_residue_ring_z_6}
Choosing the modulus $ n = 6 $ we have six equivalence classes of integers which are congruent modulo $ 6 $ (which have the same remainder when divided by $6$). We write
$$
\begin{array}{lll}
0: = \{\ldots, -6,0,6,12, \ldots \}, &
1: = \{\ldots, -5,1,7,13, \ldots \}, &
2: = \{\ldots, -4,2,8,14, \ldots \} \\
3: = \{\ldots, -3,3,9,15, \ldots \}, &
4: = \{\ldots, -2,4,10,16, \ldots \}, &
5: = \{\ldots, -1,5,11,17, \ldots \}
\end{array}
$$
Now to compute the addition of those equivalence classes, say $2+5$, one chooses arbitrary elements from both sets say $14$ and $-1$, adds those numbers in the usual way and then looks in which equivalence class the result will be. 

So we have $14+(-1)=13$ and $13$ is in the equivalence class (of) $1$. Hence we find that $2+5=1$ in modular $6$ aithmetics, which is a more readable way to write the congruency $\kongru{2+5}{1}{6}$.

Applying the same reasoning to all equivalence classes, addition and multiplication can  be transferred to the equivalence classes and the results are summarized in the following addition and multiplication tables for modulus $6$ aithmetics:
\begin{center}
  \begin{tabular}{c | c c c c c c}
    + & 0 & 1 & 2 & 3 & 4 & 5\\\hline
    0 & 0 & 1 & 2 & 3 & 4 & 5 \\
    1 & 1 & 2 & 3 & 4 & 5 & 0\\
    2 & 2 & 3 & 4 & 5 & 0 & 1\\
    3 & 3 & 4 & 5 & 0 & 1 & 2\\
    4 & 4 & 5 & 0 & 1 & 2 & 3\\
    5 & 5 & 0 & 1 & 2 & 3 & 4
  \end{tabular} \quad \quad \quad \quad
  \begin{tabular}{c | c c c c c c}
$ \cdot $ & 0 & 1 & 2 & 3 & 4 & 5 \\\hline
        0 & 0 & 0 & 0 & 0 & 0 & 0\\
        1 & 0 & 1 & 2 & 3 & 4 & 5\\
        2 & 0 & 2 & 4 & 0 & 2 & 4\\
        3 & 0 & 3 & 0 & 3 & 0 & 3\\
        4 & 0 & 4 & 2 & 0 & 4 & 2\\
        5 & 0 & 5 & 2 & 3 & 2 & 1
  \end{tabular}
\end{center}

These two tables are all you need to be able to calculate in modular $6$ aithmetics. 

To see how this simplifies congruency computations, lets look at the congruency 
$$\kongru{7\cdot(2x+21) + 11}{x-102}{6}$$
from example XXX again (But this time in modular $6$ arithmetics to use our addition and multiplication tables). Since $\Zmod{21}{6}= 3$ and $\Zmod{102}{6}= =$ We can rewrite the congruency into the equation 
$7\cdot(2x+3) + 11=x$
AND DO STUFF



For example, to determine the multiplicative inverse of a remainder class, look for the entry that results in $ 1 $ in the product table. For example the multiplicative inverse of $ 5 $ is $ 5 $ itself, since $5\cdot 5 = 1$. Similar to the integers not all numbers have inverses. For example there is no element, that when multiplied with $4$ will give $1$. 
However in contrast to what we know from integers, there are non zero numbers, that, when multiplied gives zero (e.g $4\cdot 4 =0$).

One can show that distributivity, associativity and commuativity hold (See section XXX for a precise definition)

\begin{sagecommandline}
sage: Z6=Integers(6) # Define integers modulo 6 
sage: Z6(2)+Z6(5) # standard representatives of a class
sage: Z6(14)+Z6(-1) # different representatives for same class
sage: - Z6(2) # additive inverse
sage: Z6(5)**(-1) # multiplicative inverse if exists
\end{sagecommandline}
\end{example}

TODO:

Barrett reduction

Montgomery modular multiplication (Montgomery domain)

\begin{jargon}[$k$-bit modulus] In cryptographic papers, we can sometimes read phrases like "$[\ldots]$ using a 4096-bit modulus". This means that the underlying modulus $n$ of the modular arithmetic used in the system has a binary representation with a length of $4096$ bits. For example, the number $6$ has the binary representation $110$ and henxe example describes a $3$-bit modulus arithmetics system.   
\end{jargon}
\begin{exercise}
Let $a,b,k$ be integers, such that $\kongru{a}{b}{n}$ holds. Show $\kongru{a^k}{b^k}{n}$.
\end{exercise}
\begin{exercise}
Let $a,n$ be integers, such that $a$ and $n$ are not coprime. For which $b\in\Z$ does the 
congruency $\kongru{a\cdot x}{b}{n}$ have a solution $x$ and how does the solution set look in that case?
\end{exercise}
\paragraph{Modular Inverses} As we know integers can be added, subtracted and multiplied, but not divided in general, as for example $3/2$ is not an integer anymore. To see why this is, from a more theoretical perspective, lets consider the definition of a multiplicative inverse first. When we have a set that has some kind of multiplication defined on it and we have a distinguished element of that set, that behaves neutral with respect to that multiplication (doesn't change anything when multiplied with any other element), then we can define \textit{multiplicative inverses} in the following way:

Let $S$ be our set that has some notion $a\cdot b$ of multiplication and a \textit{neutral element} $1\in S$, such that $1\cdot a = a$ for all elements $a\in S$. Then a \textit{multiplicative inverse} $a^{-1}$ of an element $a\in S$ is defined by
\begin{equation}
a\cdot a^{-1} = 1
\end{equation}
So roughly speaking a multiplicative element is defined in such a way, that it cancels the original element to give $1$, whenever they are multiplied. 

Numbers that have multiplicative inverses are of particular interest, because they immediately lead to the definition of division by those numbers. In fact if $a$ is number, such that the multiplicative inverse $a^{-1}$ exist, then we define \textit{division} by $a$ simply as multiplication by the inverse, i.e
\begin{equation}
\frac{b}{a}:= b\cdot a^{-1}
\end{equation}
\begin{example} Consider the set of rational numbers $\mathbb{Q}$, that is the set of all fractions. Then the neural element of multiplication is $1$, since $1\cdot a = a$ for all rational numbers. For example $1\cdot 4=4$, $1\cdot \frac{1}{4}=\frac{1}{4}$, or $1\cdot 0 =0$ and so on.

Then every rational number $a\neq 0$ has a multiplicative inverse, given by $\frac{1}{a}$. 
For example the multiplicative inverse of $3$ is $\frac{1}{3}$, since $3\cdot \frac{1}{3}=1$, the multiplicative inverse of $\frac{5}{7}$ is $\frac{7}{5}$, since $\frac{5}{7}\cdot \frac{7}{5}=1$ and so on. 
\end{example}
\begin{example}Looking at  the set $\Z$ of integers, we see that with respect to multiplication the neutral element is the number $1$ and we notice, that no integer $a\neq 1$ has a multiplicative inverse, since the equation $a\cdot x =1$ has no integer solutions for $a\neq 1$. 

The definition of multiplicative inverse works verbtim for addition, too. In the case of integers, the neutral element with respect to addition is $0$, since $a+0=0$ for all integers $a\in\Z$. The additive inverse then always exist and is given by the negative number $-a$, since $a+(-1)=0$.  
\end{example}
\begin{example} Looking at the set $\Z_6$ of residuel classes modulo $6$ from example XXX, we can use the multiplication table to find multiplicative inverses. To see that we look at the row of the element and then find the entry equal to $1$. If such an entry exist, the element of that column is the multiplicative inverse. If on the other hand the row has no entry equal to $1$, we know that the element has no multiplicative inverse.

For example in $\Z_6$ the multiplicative inverse of $5$ is $5$ itself, since $5\cdot 5=1$. We can moreover see that $5$ and $1$ are the only elements that have multiplicative inverses in $\Z_6$. 

Now since $5$ has a multiplicative inverse modulo $6$, it makes sense to "divide by $5$ in $\Z_6$. For example
$$
\frac{4}{5}= 4\cdot 5^{-1} = 4\cdot 5 = 2
$$ 
\end{example}
From the last example we can make the interesting observation, that while $5$ has no multiplicative inverse as an integer, it has a multiplicative inverse in modular $6$ arithmetics. 

So the question remains, to understand, what elements have multiplicative inverses in modular arithmetics. The answer is, that in modular $n$ arithmetics, a residue class $r$ has a multiplicative inverse, if and only if $n$ and $r$ are coprime. Since $ggt(n,r)=1$ in that case, we know from the extended Euklidean algorithm, that there are numbers $s$ and $t$, such that 
\begin{equation}
\label{eq_compute_multiplicative_inverse}
1 = s\cdot n + t\cdot r
\end{equation}
and if we take the modulus $n$ on both sides the term $s\cdot n$ vanishes, which tells us that $\Zmod{t}{n}$ is the multiplicative inverse of $r$ in modular $n$ arithmetics.
\begin{example}[Multiplicative inverses in $\Z_6$] In the previous example we have looked up multiplicative inverses in $\Z_6$ from lookup-table XXX. In real world examples, it is of course usually impossible to write down those lookup tables as the modulus is way to large and the sets occasionally contain more elements, then there are atoms in the observable universe.

No to see that $2\in \Z_6$ has no multiplicative inverse in $\Z_6$ without using the lookup table, we immediately observe that $2$ and $6$ are not coprime since their greatest common divisor is $2$. If follows that equation \ref{eq_compute_multiplicative_inverse} has no solutions $s$ and $t$ and hence $2$ has no multiplicative inverse.

The same reasoning works for $3$ and $4$, too as both are not coprime with $6$ and the only case that is different is $5$, since $ggt(6,5)=1$. To compute the multiplicative inverse of $5$ we use the extended Euklidean algorithm and compute   
\begin{center}
  \begin{tabular}{c | c c l}
    k & $ r_k $ & $ s_k $ & $ t_k = \Zdiv{(r_k-s_k \cdot a)}{b} $ \\\hline
    0 & 6 & 1 & 0 \\
    1 & 5 & 0 & 1 \\
    2 & 1 & 1 & -1 \\
    3 & 0 & . & . \\
  \end{tabular}
\end{center}
So we get $s=1$ as well as $t=-1$ and have $1 = 1\cdot 6 -1\cdot 5$. From this follows that $\Zmod{-1}{6}=5$ is the multiplicative inverse of $5$ in modular $6$ arithmetics. We can double check using sage:
\begin{sagecommandline}
sage: ZZ(6).xgcd(ZZ(5))
\end{sagecommandline}
\end{example}
At this point the attentive reader might notice, that the situation, where the modulus is a prime number is of particular interest, since we know from exercise XXX, that in this cases all remainder classes must have modular inverses, since $ggt(r,n)=1$ for prime $n$ and $r<n$. We will look at this central situation in XXX. 

\begin{example} [Modular $5$ arithmetics] 
\label{primfield_z_5}
To see the unique properties of mudular arithmetics whenever the modulus is prime numbers, we will parallel our findings from example XXX, but this time for the prime modulus $5$.
For $ n = 5 $ we have five equivalence classes of integers which are congruent modulo $ 5 $. We write
$$
\begin{array}{ccc}
0: = \{\ldots, -5,0,5,10, \ldots \}, &
1: = \{\ldots, -4,1,6,11, \ldots \}, &
2: = \{\ldots, -3,2,7,12, \ldots \} \\
3: = \{\ldots, -2,3,8,13, \ldots \}, &
4: = \{\ldots, -1,4,9,14, \ldots \}
\end{array}
$$
Addition and multiplication can now be transferred to the equivalence classes. This results in the following addition and multiplication tables in $ \Z_5 $:
\begin{center}
  \begin{tabular}{c | c c c c c}
    + & 0 & 1 & 2 & 3 & 4 \\\hline
    0 & 0 & 1 & 2 & 3 & 4 \\
    1 & 1 & 2 & 3 & 4 & 0 \\
    2 & 2 & 3 & 4 & 0 & 1 \\
    3 & 3 & 4 & 0 & 1 & 2 \\
    4 & 4 & 0 & 1 & 2 & 3 \\
  \end{tabular} \quad \quad \quad \quad
  \begin{tabular}{c | c c c c c}
$ \cdot $ & 0 & 1 & 2 & 3 & 4 \\\hline
      0 & 0 & 0 & 0 & 0 & 0 \\
      1 & 0 & 1 & 2 & 3 & 4 \\
      2 & 0 & 2 & 4 & 1 & 3 \\
      3 & 0 & 3 & 1 & 4 & 2 \\
      4 & 0 & 4 & 3 & 2 & 1 \\
  \end{tabular}
\end{center}

These two tables are all you need to be able to calculate in $ \Z_5 $. For example, to determine the multiplicative inverse of an element, look for the entry that results in $ 1 $ in the product table. This is the multiplicative inverse. For example the multiplicative inverse of $ 2 $ is $ 3 $ and the multiplicative inverse of $4$ is $4$ itself, since $4\cdot 4=1$. As we can see indeed every element $\neq 0$ has a multiplicative inverse.
\end{example}
\section{Polynomial Arithmetics}
A polynomial is an expression consisting of variables (also called indeterminates) and coefficients, that involves only the operations of addition, subtraction, multiplication, and non-negative integer exponentiation of variables. All coefficients of a polynomial must have the same type, e.g. being integers or fractions etc. To be more precise a \textit{polynomial} is an expression
\begin{equation}
P(x) := \sum _{j = 0} ^{m}{a} _{j}{t} ^{j} ={a} _{m}x^m +{a} _{m-1} x^{m-1} + \dots + a_1 x + a_0 \;,
\end{equation}
where $x$ is called the \textit{indeterminate}, each $ a_j$ is called a \textit{coefficient}. If $R$ is the type of the coefficients then the set of all \textbf{polynomials with coefficients in $R$} is written as $R[x]$. We often simply write $ P (x) \in R[x]$ for a polynomial and denote the constant term as $ P(0)$. 

A polynomial is called the \textit{zero polynomial} if all coefficients are zero and a polynomial is called the \textit{one polynomial} if the constant term is $1$ and all other coefficients are zero.

If a polynomial $P(x)=\sum_{j=0}^m a_jx^j$ is given and is not the zero polynomial, we call 
\begin{equation}
deg(P):=m
\end{equation}
the \textit{degree} of $P$ and define the degree of the zero polynomial to be $-\infty$. In addition we write 
\begin{equation}
\label{def_leading_coefficient}
Lc(P):=a_m
\end{equation}
and call it the \textit{leading coefficient} of the polynomial $P$. We can restrict the set $R[x]$ of \textit{all} polynomials with coefficients in $R$, to the set of all such polynomials that have a degree that does not exceed a certain value. If $m$ is the maximum degree allowed, we write $R_{\leq m}[x]$ for the set of all poynomials with a degree less or equal to $m$.
\begin{example}[Integer Polyinomials] The coefficients of a polynomial must all have the same type. The set of polynomials with integer coefficients is written as $\Z[x]$. Examples of such polynomialse are:
\begin{itemize}
\item $P_1(x)= 2x^2 -4x +17$, with degree $deg(P_1)=2$.
\item $P_2(x)= x^{23}$, with degree $deg(P_2)=23$.
\item $P_3(x)= x$, with degree $deg(P_3)=1$.
\item $P_4(x)= 174$, with degree $deg(P_4)=0$.
\item $P_5(x)= 1$, with degree $deg(P_5)=0$.
\item $P_6(x)=0$, with degree $deg(P_5)=-\infty$.
\item $P_7(x)= (x-2)(x+3)(x-5)$, with degree $deg(P_3)=3$.
\end{itemize}
In particular every integer can be seen as an integer polynomial of degree zero. $P_7$ is a polynomial, because we can expand its definition into $P_7(x)=x^3 - 4 x^2 - 11 x + 30$, which is polynomial of degree $3$. The following expressions are not integer polynomial
\begin{itemize}
\item $Q_1(x)= 2x^2 + 4 + 3x^{-2}$
\item $Q_2(x)= 0.5x^4 -2x$
\item $Q_3(x)=1/x$
\end{itemize}
\end{example}
\begin{example}[Polynomials over $\mathbb{Z}_6$] Recall our definition of the residue classes $\Z_6$ and their arithmetics as defined in \ref{def: residual class ring}. The set of all polynomials with indeterminant $x$ and coefficients in $\Z_6$ is symbolized as $\Z_6[x]$. Example of polynomials from $\Z_6$ are:
\begin{itemize}
\item $P_1(x)= 2x^2 -4x +5$, with degree $deg(P_1)=2$.
\item $P_2(x)= x^{23}$, with degree $deg(P_2)=23$.
\item $P_3(x)= x$, with degree $deg(P_3)=1$.
\item $P_5(x)= 1$, with degree $deg(P_5)=0$.
\item $P_6(x)=0$, with degree $deg(P_5)=-\infty$.
\item $P_7(x)= (x-2)(x+3)(x-5)$, with degree $deg(P_3)=3$.
\end{itemize}
As in the previous example $P_7$ is a polynomial. However since we are working with coefficients from $\Z_6$ now the expension of $P_7$ is computed differently, as we have to invoke addition and multiplication in $\Z_6$ as defined in XXX. We get:
$$
\begin{array}{l c l r}
(x-2)(x+3)(x-5) & = & (x+4)(x+3)(x+1) & \text{\# additive inverses in } \Z_6 \\
                & = & (x^2+4x+3x+3\cdot 4)(x+1) & \text{\# bracket expansion} \\
                & = & (x^2+1x+0)(x+1) & \text{\# compuation in } \Z_6 \\
                & = & (x^3+x^2+x^2+x) & \text{\# bracket expansion}\\
                & = & (x^3+2x^2+x) &
\end{array} 
$$
\end{example}
We can invoke sage to do computations with polynomials. To do so we have to specify the symbol for the indertimate and the type for the coefficients. Note however that sage defines the degree of the zero polynomial to be $-1$.
\begin{sagecommandline}
sage: Zx = ZZ['x'] # integer polynomials with indeterminate x
sage: Zt.<t> = ZZ[] # integer polynomials with indeterminate t
sage: Zx
sage: Zt
sage: p = Zx([1,2,3,4])
sage: q = Zt([1,2,3,4])
sage: p
sage: q
sage: p.degree()
sage: zero = Zx([0])
sage: zero.degree()
\end{sagecommandline}
Given some element from the same type as the coefficients of a polynomial, the polynomial can be evaluated at that element, which means that we insert the element for every occurence of $x$ in the polynomial expression. To be more precise let $P\in R[x]$, with $P(x)=\sum_{j=0}a_j x^j$ be some polynomial with coefficient of type $R$ and let $b\in R$ be an element of that type. Then the \textit{evaluation} of $P$ at $b$ is given by
\begin{equation}
P(a) = \sum_{j=0} a_j b^j
\end{equation}
\begin{example} We evaluate the integer polynomials from example XXX at certain integers. We get:
\begin{itemize}
\item $P_1(2)= 2\cdot 2^2 -4\cdot 2 +17 = 17$
\item $P_2(3)= 3^{23}=94143178827$
\item $P_3(-4)= -4 = -4$.
\item $P_4(15)= 174$.
\item $P_5(0)= 1$.
\item $P_6(1274)=0$.
\item $P_7(-6)= (-6-1)(-6+2)(-6-4) = -280$.
\end{itemize}
Note however that is not possible to evaluate any of those polynomial on values of different type. It is for example strictly speaking wrong to write $P_1(0.5)$, since $0.5$ is not an integer.
\end{example}
\begin{example} We evaluate the polynomials from example XXX at certain values from $\Z_6$. We get:
\begin{itemize}
\item $P_1(2)= 2\cdot 2^2 -4\cdot 2 +5 = 2 - 2 + 5 = 5$
\item $P_2(3)= 3^{23}=3$, since $3\cdot 3=3$ in $\Z_6$.
\item $P_3(-4)= P_3(2) = 2$.
\item $P_5(0)= 1$.
\item $P_6(4)=0$.
\end{itemize}
\end{example}
\begin{exercise}
Compare both expansions of $P_7$ from $\Z[x]$ and from $\Z_6[x]$ in example XXX and example XXX and consider the definition of $\Z_6$ as given in example XXX. Can you see how the definition of $P_7$ over $\Z$ projects to the definition over $\Z_6$ if you consider the residue classes of $\Z_6$?
\end{exercise}
\paragraph{Polynomial Aithmetics}
Polynomials behave like integers in many ways. In particular they can be added, subtracted and multiplied. In addition they have their own notion of Euklidean division. Roughly speaking two polynomials are added by simply adding the coefficients of the same index and they are multiplied by applying the distributive property, that is by multiplying every term of the left factor with every term of the right factor and add the results together.

To be more precise let $ \sum _{n = 0} ^{m_1}{a} _{n}{x} ^{n} $ and
$ \sum _{n = 0} ^{m_2}{b} _{n}{x} $ be two polynomials from $ R[x]$. Then the \textit{sum} and the \textit{product} of these polynomials is defined as:
\begin{equation}
\sum _{n = 0} ^{m_1}{a} _{n}{x} ^{n} + \sum _{n = 0} ^{m_2}{b} _{n}{x } ^{n} = \sum _{n = 0} ^{may(m_1,m_2)}{({a} _{n} +{b} _{n})}{x} ^{n}
\end{equation}
\begin{equation}
\bigg (\sum _{n = 0} ^{m_1}{a} _{n}{x} ^{n} \bigg) \cdot \bigg (\sum _{n = 0} ^{m_2 }{b} _{n}{x} ^{n} \bigg) = \sum _{n = 0} ^{m_1+m_2} \sum _{i = 0} ^{n}{a} _{i }{{b} _{ni}}{x} ^{n}
\end{equation}
A rule for polynomial subtraction can be deduced from these two rules by first muliplying the subtrahend with (the polynomial) $-1$ and then add the result to the minuend.

Regarding ower definition of the degree of a polynomial, we see that the degree of the sum is always the maximum of the degrees of both summands and the degree of the product is always the degree of the factors, providing that $-\infty \cdot m= \infty$ for every integer $m\in\Z$. Using sage's definition of degree, this would not hold, as the zero polynomials degree is $-1$ is sage, which would violate this rule.
\begin{example} To given an example of how polynomial aithmetics work, consider the following two integer polynomials $P,Q\in \Z[x]$ with $P(x)= 5x^2 -4x +2$ and $Q(x)=x^3-2x^2 +5$. The sum of these two polynomials is computed by adding the coefficients of each term with equal exponent in $x$. This gives
$$
\begin{array}{lcl}
(P+Q)(x) & = & (0+1)x^3 + (5-2)x^2 + (-4 +0) x +(2+5) \\
         & = & x^3 +3x^2 -4x +7
\end{array}
$$
The product of thess two polynomials is computed by multiplication of each term in the first factor with each term in the second factor. We get
$$
\begin{array}{lcl}
(P\cdot Q)(x) & = & (5x^2 -4x +2)\cdot (x^3-2x^2 +5) \\
              & = & (5 x^5 -10 x^4 +25 x^2)+ (-4x^4 +8 x^3 -20x) + (2x^3 -4x^2+10) \\
              & = & 5 x^5 -14x^4 +10x^3+21x^2-20x +10
\end{array}
$$
We can double check our computations by invoking sage
\begin{sagecommandline}
sage: Zx = ZZ['x'] 
sage: P = Zx([2,-4,5])
sage: Q = Zx([5,0,-2,1])
sage: P
sage: Q
sage: P+Q
sage: P*Q
\end{sagecommandline}
\end{example}
\begin{example} Lets consider the polynomials of the previous example but interpreted in modular $6$ aithmetics. So we consider $P,Q\in \Z_6[x]$ again with $P(x)= 5x^2 -4x +2$ and $Q(x)=x^3-2x^2 +5$. This time we get
$$
\begin{array}{lcl}
(P+Q)(x) & = & (0+1)x^3 + (5-2)x^2 + (-4 +0) x +(2+5) \\
         & = & (0+1)x^3 + (5+4)x^2 + (2 +0) x +(2+5) \\
         & = & x^3 +3x^2 +2x +1\\
         \\
(P\cdot Q)(x) & = & (5x^2 -4x +2)\cdot (x^3-2x^2 +5) \\
              & = & (5x^2 +2x +2)\cdot (x^3+4x^2 +5) \\
              & = & (5 x^5 +2 x^4 +1x^2)+ (2x^4 +2x^3 +4x) + (2x^3 +2x^2+4) \\
              & = & 5 x^5 +4x^4 +4x^3+3x^2+4x +4
\end{array}
$$
We can double check our computations by invoking sage
\begin{sagecommandline}
sage: Z6 = Integers(6)['x'] 
sage: P = Z6([2,-4,5])
sage: Q = Z6([5,0,-2,1])
sage: P
sage: Q
sage: P+Q
sage: P*Q
\end{sagecommandline}
\end{example}

\paragraph{Euklidean Division}
The ring of polynomials shares a lot of properties with the integers. In particular there is also the concept of Euclidean division and the algorithm of long division defined for polynomials. Recalling from Euklidean division of integers XXX, we know, that given two integers $a$ and $b\neq 0$ there is always another integer $m$ and a counting number $r$ with $r<|b|$, such that $a = m\cdot b +r$ holds.

We can generalize this to polynomials, whenver the coefficients of the polynomials have a notion of division. In fact given two polynomials $A$ and $B\neq 0$ from $R[x]$, there exist two polynomials $M$ (the quotient) and $R$ (the remainder), such that
\begin{equation}
A = M\cdot B + R
\end{equation}
and $deg(R) < deg(B)$. Similar to integer Euklidean division both $M$ and $R$ are uniquely defined by these relations. 
\begin{notation}
\label{eq_polynomial_euklidean_division_notation}
Suppose that the polynomials $ A, B, M $ and $ R $ satisfy equation XX. Then we often write 
\begin{equation}
\label{def_integer_division_and_modulus}
\begin{array}{lcr}
\Zdiv{A}{B}: = M, & & \Zmod{A}{B}: = R 
\end{array}
\end{equation}
to describe the quotient and the remainder polynomials of the Euklidean division. We also say, that a polynomial $ A $ is divisible by another polynomial $ B $ if $ \Zmod{A}{B} = 0 $ holds. In this case we also write $ B | A $ and call $B$ a \textit{factor} of $A$.
\end{notation}
Analog to integers, methods to compute Euklidean division for polynomials are called \textit{polynomial division algorithms}. Probably the best known algorithm is the so called \textit{polynomial long division}. 
\begin{algorithm}\caption{Polynomial Euklidean Algorithm}
\label{alg_ext_euclid_alg}
\begin{algorithmic}[0]
\Require $A,B \in R[x]$ with $B\neq 0$, such that $Lc(B)^{-1}$ exists in $R$
\Procedure{Poly-Long-Division}{$A,B$}
\State $M \gets 0$
\State $R \gets A$
\State $d \gets deg(B)$
\State $c \gets Lc(B)$
\While{$ deg(R) \geq d$}
\State  $S := \frac{Lc(R)}{c}\cdot x^{deg(R)-d}$
\State $M \gets M + S$
\State $R \gets R - S\cdot B$
\EndWhile
\State \textbf{return} $(Q, R)$ 
\EndProcedure
\Ensure $ A=  M \cdot B + R$
\end{algorithmic}
\end{algorithm}

% https://math.stackexchange.com/questions/2140378/division-algorithm-for-polynomials-in-rx-where-r-is-a-commutative-ring-with-u
This algorithm works only when there is a notion of division by the leading coefficient of $B$. It can be generalized, but we will only need this somewhat simpler method in what follows.
\begin{example}[Polynomial Long Division] To give an example of how the previous algorithm works, lets divide the polynomial $A(x)=x^5+2x^3-9$ by the polynomial $B(x)=x^2+4x-1$. Since $B$ is not the zero polynomial and the leading coefficient of $B$ is $1$, which is invertible as an integer, we can applay algorithm XXX and our goal is to find solutions to equation \ref{xxx}, that is we need to find the quotient polynomial $M\in\Z[x]$ and the reminder polynomial $R \in \Z[x]$ such that $x^5+2x^3-9 = M(x)\cdot (x^2+4x-1) + R$. Using a notation that is mostly used in Commonwealth countries, we compute
\begin{equation}
\polylongdiv{X^5+2X^3-9}{X^2+4X-1}
\end{equation}
We therefore get $M(x)=x^3-4x^2+19x-80$ as well as $R(x)=339x-89$ and indeed we have $x^5+2x^3-9 = (x^3-4x^2+19x-80)\cdot (x^2+4x-1) + (339x-89)$, which we can double check invoking sage:
\begin{sagecommandline}
sage: Zx = ZZ['x']
sage: a = Zx([-9,0,0,2,0,1])
sage: b = Zx([-1,4,1])
sage: m = Zx([-80,19,-4,1])
sage: r = Zx([-89,339])
sage: a == m*b +r
\end{sagecommandline}
\end{example}
\begin{example} In the previous example polynomial division gave a non trivial (non vanishing, i.e non-zero) remainder. Of special interest are divisions that don't give a remainer. Sutable divisiors are called factors in that case. For example consider the polynomial $P_7$ from example XXX again. As we have shown, it can be written both as $x^3 - 4 x^2 - 11 x + 30$ as well as $(x-2)(x + 3)(x-5)$. From this we can see that the polynomials $F_1(x)=(x-2)$, $F_2(x)=(x+3)$ and $F_3(x)=(x-5)$ are all the factors of $x^3 - 4 x^2 - 11 x + 30$.
\end{example}

\paragraph{Prime Factors}
As we have seen in example XXX, points where a polynomial evaluates to zero, i.e points $x_0\in R$ with $P(x_0)=0$ are of special interest, since the polynomial $F(x)=(x-x_0)$ is a factor of $P$. Those points are called the \textit{roots} of $P$. To be more precise, let $P\in R[x]$ be a polynomial. Then the set of all roots of $P$ is defined as
\begin{equation}
R_0(P):=\{x_0\in R\;|\; P(x_0)=0\}
\end{equation}
Finding the roots of a polynomial is sometimes called solving the polynomial. It is a hard problem and has been the subject of much research throughout history. In fact it is well known that for polynomials of degree $5$ or higher there is, in general, no closed expression, from which the roots can be deduced. 

Therefore, except for very low degrees, root finding of polynomials consists of finding approximations of the roots.
\begin{example}
Consider our integer polynomial $P_7(x)=x^3 - 4 x^2 - 11 x + 30$ from example XXX again. We know that it's set of roots is given by $R_0(P_7)=\{-3,2,5\}$.

On the other hand consider the integer polynomial $P(x)=x^2-2$. We know that it can not have any integer root, since $x^2-2=0$ implies that any root $x_0$ would have to satisfy $x_0^2=2$, but there is no integer that squares into $2$ ($\sqrt{2}$ is not an integer).
\end{example}
It can be shown, that if $m$ is the degree of a polynomial $P$, then $P$ can not have more then $m$ roots. However in general polynomials can have less then $m$ roots. A special case occures if a polynomial has no roots at all in which case it is called \textit{irreducible}. 

In a sense, irreducible polynomials are for polynomials what prime numbers are for integers. They are the basic building blocks from which all other polynomials can be constructed. This can be expressed in a polynomial analog of the fundamental theorem of arithmetics XXX. To be more precise, let $P \in R[x]$ be any polynomial. Then there are always irreducible polynomials $F_1, F_2, \ldots, F_k \in R[x]$, such that
\begin{equation}
P = F_1 \cdot F_2 \cdot \ldots \cdot F_k \;.
\end{equation}
This representation is unique, except for permutations in the factors and is called the \textbf{prime factorization} of $P$.

Every root $x_0$ of a polynomial defines a prime factor $(x-x_0)$ of $P$. The converse however is not necessarily true, because a polynomial can have irreducible prime factors. 
\begin{example}[Prime Factorization] To give an example consider the polynomial 
$P=x^7 + 3 x^6 + 3 x^5 + x^4 - x^3 - 3 x^2 - 3 x - 1$. We can check that this polynomial has the following roots $R_0(P)=\{-3,2\}$ and that the irreducible polynomial $F_1(x)=x^2-2$ is a factor of $P$. We can use this data to compute the prime factorization of $P$, by succesive polynomial division of $P$ by $(x+3)$, $(x-2)$ as well as $x^2-2$. We get:
$$
P= (x^2-2)(x^4-4)(x-2)(x+3)
$$
\end{example}
\paragraph{Lange interpolation}
One particulary nice property of polynomials is that a polynomial of degree $m$ is completely determined on $m+1$ evaluation points. Seeing this from a different angle, we can (sometimes) uniquely derive a polynomial of degree $m$ from a set 
\begin{equation}
\label{def_lagrange_interpolation_set}
S= \{(x_0,y_0), (x_1,y_1),\ldots,(x_m,y_m)\;|\; x_i\neq x_j\text{ for all indices i and j}\}
\end{equation}
This "few to many" property of polynomials is used in many places, like for example in erasure codes. It is also of importance in snarks and we therefore need to understand a method to actually compute a polynomial from a set of points. 

If the coefficients of the polynomial we want to find have a notion of multiplicative inverse, it is always possible to find such a polynomial and one method is called \textit{Lagrange interpolation}. It works as follows:
Give a set like \ref{def_lagrange_interpolation_set}, a polynomial $P$ of degree $m+1$ with $P(x_i)=y_i$ for all pairs $(x_i,y_i)$ from $S$ is given by the following algorithm:

\begin{algorithm}\caption{Lagrange Interpolation}
\label{alg_lagrange_interplation}
\begin{algorithmic}[0]
\Require $R$ must have multiplicative inverses
\Require $S= \{(x_0,y_0), (x_1,y_1),\ldots,(x_m,y_m)\;|\; x_i,y_i\in R, x_i\neq x_j\text{ for all indices i and j}\}$  
\Procedure{Lagrange-Interpolation}{$S$}
\For{$j \in (0\ldots m)$}
\State  $l_j(x) \gets \Pi_{i=0;i\neq j}^{m}\frac{x-x_i}{x_j-x_i} = \frac{(x-x_0)}{(x_j-x_0)} \cdots \frac{(x-x_{j-1})}{(x_j-x_{j - 1})} \frac{(x-x_{j+1})}{(x_j-x_{j+1})} \cdots \frac{(x-x_m)}{(x_j-x_m)}$
\EndFor
\State $P\gets \sum_{j=0}^m y_j\cdot l_j$
\State \textbf{return} $P$ 
\EndProcedure
\Ensure $P\in R[x]$ with $deg(P)=m$
\Ensure $P(x_j)=y_j$ for all pairs $(x_j,y_j)\in S$
\end{algorithmic}
\end{algorithm}

\begin{example} Lets consider the set $S=\{(0,4),(-2,1),(2,3)\}$ of fractional numbers. We know that this set determines a unique integer polynomial of degree $2$ in $\mathbb{Q}[x]$. To compute this polynomial, we use the Lagrange interpolation algorithm from XXX. We compute 
$$
\begin{array}{lcccl}
l_0(x) & = & \frac{x-x_1}{x_0-x_1}\cdot\frac{x-x_2}{x_0-x_2}
         = \frac{x+2}{0+2}\cdot\frac{x-2}{0-2}
         =  -\frac{(x+2)(x-2)}{4}
       & = & -\frac{1}{4}(x^2-4)\\
         \\
l_1(x) & = & \frac{x-x_0}{x_1-x_0}\cdot\frac{x-x_2}{x_1-x_2}
         = \frac{x-0}{-2-0}\cdot \frac{x-2}{-2-2}
         = \frac{x(x-2)}{8}
       & = & \frac{1}{8}(x^2-2x)\\
         \\
l_2(x) & = & \frac{x-x_0}{x_2-x_0}\cdot\frac{x-x_1}{x_2-x_1}
         = \frac{x-0}{2-0}\cdot\frac{x+2}{2+2}
         = \frac{x(x+2)}{8}
       & = & \frac{1}{8}(x^2+2x)\\
       \\
       \\
P(x)   & = &  4\cdot (-\frac{1}{4}(x^2-4)) + 1\cdot \frac{1}{8}(x^2-2x) + 3\cdot \frac{1}{8}(x^2+2x) 
       & & \\
       & = & -x^2+4 + \frac{1}{8}x^2-\frac{1}{4} x + \frac{3}{8}x^2+\frac{3}{4} x 
       & = & -\frac{1}{2} x^2 +\frac{1}{2} x + 4        
\end{array}
$$
And indeed evaluation of $P$ on the $x$-values of $S$ gives the correct points, since $P(0)=4$, $P(-2)=1$ and $P(2)=3$.
\end{example}
\begin{example} To give another example, more relevant to the topics of this book, lets consider the same set $S=\{(0,4),(-2,1),(2,3)\}$ as in the pevious example but this times interpreted as residue classes modulo $5$ as we derive in XXX. Since we know
that multiplicative inverses exist in $\Z_5$, algorithm XXX applies and we can compute a unique polynomial of degree 2 in $\Z_5[x]$ from $S$. We can use the lookup tables XXX for computation in $\Z_5$ and get
$$
\begin{array}{lcccl}
l_0(x) & = & \frac{x-x_1}{x_0-x_1}\cdot\frac{x-x_2}{x_0-x_2}
         = \frac{x+2}{0+2}\cdot\frac{x-2}{0-2}
         =  \frac{(x+2)(x-2)}{-4}
         =  \frac{(x+2)(x+3)}{1}
       & = & x^2+1\\
         \\
l_1(x) & = & \frac{x-x_0}{x_1-x_0}\cdot\frac{x-x_2}{x_1-x_2}
         = \frac{x-0}{-2-0}\cdot \frac{x-2}{-2-2}
         = \frac{x}{3}\cdot \frac{x+3}{1}
         = 2(x^2+3x)
       & = & 2x^2+x\\
         \\
l_2(x) & = & \frac{x-x_0}{x_2-x_0}\cdot\frac{x-x_1}{x_2-x_1}
         = \frac{x-0}{2-0}\cdot\frac{x+2}{2+2}
         = \frac{x(x+2)}{3}
         = 2(x^2+2x)
       & = & 2x^2+4x\\
       \\
       \\
P(x)   & = &  4\cdot (x^2+1) + 1\cdot (2x^2+x) + 3\cdot (2x^2+4x) 
       & & \\
       & = & 4x^2+4 + 2x^2 +x + x^2+2x
       & = & 2x^2 +3x +4       
\end{array}
$$
And indeed evaluation of $P$ on the $x$-values of $S$ gives the correct points, since $P(0)=4$, $P(-2)=1$ and $P(2)=3$.
\end{example}

\begin{exercise}
Consider example XXX and example XXX again. Why is it not possible to applay algorithm XXX if we consider $S$ as a set of integers, nor as a set in $\Z_6$?
\end{exercise}



