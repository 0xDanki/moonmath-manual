\chapter{Elliptic Curves}\label{chap:elliptic-curves}
\label{chap:elliptic_curves}
%references http://infosec.pusan.ac.kr/wp-content/uploads/2019/09/Pairings-For-Beginners.pdf
Generally speaking, elliptic curves are nothing but geometric objects in projective planes \ref{sec:planes} over some given field, made up of points that satisfy certain equations. One of their key features from the point of view of cryptography is that if the underlying field is of positive characteristic, elliptic curves are finite, cyclic groups \ref{sec:finite-groups} and it is believed that the discrete logarithm problem \ref{def:DL-secure} on these groups is hard, given that the underlying characteristic is large enough. 

A special class of elliptic curves are so-called \term{pairing-friendly curves}, which have a notation of a group pairing \ref{pairing-map} attached to them, that have cryptographically advantageous properties. 

In this chapter, we introduce epileptic curves as they are used in pairing-based approaches to the construction of SNARKs. The elliptic curves we consider are all defined over prime fields or prime field extensions and the reader should be familiar with the contend of the previous chapter on those notations. 

\section{Short Weierstrass Curves}
\label{sec:short_weierstrass_curve}
In this section, we introduce \term{short Weierstrass} curves, which are the most general types of curves over finite fields of characteristics \ref{def:characteristic} greater than $3$ and start with their so called affine representation. Introducing elliptic curves in their affine representation is probably not the most common and conceptually cleanest way, but has the advantage that in the affine representation an elliptic curve is just a set of pairs of numbers. We believe that such an introduction makes elliptic curves more accessible to the beginner, since potential unfamilarity with projective coordinates can be avoided. However, the affine representation has the disadvantage that a special ``point at infinity'', that is not a point on the curve, is necessary to describe the curve's group structure. 

We then introduce the elliptic curve group law and describe elliptic curve scalar multiplication, which is an instantiation of the exponential map from general cyclic groups \ref{scalarmultiplication}. After that, we look at the projective representation of elliptic curves, which has the advantage that no special symbol is necessary to represent the point at infinity. As this representation is conceptually more straight forward, this is how elliptic curves are usually introduced in math classes. The major drawback from a beginners point of view is that in the projective representation, points are elemements from projective planes, which are classes of numbers.

We finish this section with an explicit equivalence that transforms affine representations into projective representations and vice versa.

\subsection{Affine Short Weierstrass form} Probably the least abstract and most straight-forward way to introduce elliptic curves for non-mathematicians and beginners is the so-called affine representation of a short Weierstrass curve. To see what this is, let $\F$ be a finite field of characteristic $q$ with $q>3$ and $a,b\in \F$ two field elements such that the so called \term{discriminant} $4a^3+ 27b^2$ is not equal to zero. Then a \term{short Weierstrass elliptic curve} $E(\F)$ over $\F$ in its affine representation is the set of all pairs of field elements $(x,y)\in \F\times \F$ that satisfy the short Weierstrass cubic equation $y^2=x^3+a\cdot x+b$, together with a distinguished symbol $\Oinf$, called the \term{point at infinity}:

\begin{equation}
\label{def_short_weierstrass_curve}
E(\F) = \{(x,y)\in \F\times \F\;|\; y^2=x^3+a\cdot x+b \} \bigcup \{\Oinf\}
\end{equation}
The term ``curve'' is used here because, if an elliptic curve is defined over a characteristic zero field, like the field $\Q$ of rational numbers, the set of all points $(x,y)\in \Q\times \Q$ that satisfy $y^2 = x^3 +a\cdot x +b$ looks like a curve. We should note however that visualizing elliptic curves over finite fields as ``curves'' has its limitations, and we will therefore not stress the geometric picture too much, but focus on the computational properties instead. To understand the visual difference, consider the following two elliptic curves: 

\medskip

% let Sage draw some elliptic curve in R^2, but show only the picture
\begin{sagesilent}
E1 = EllipticCurve([-2,1])
C1 = E1.plot()
F = GF(9973)
E2 = EllipticCurve(F, [-2,1])
C2 = E2.plot()
\end{sagesilent}
\begin{minipage}{0.48\textwidth}
\sageplot[scale=.48]{C1} 
\end{minipage}
%
\begin{minipage}{0.48\textwidth}
\label{plot:elliptic_curve}
\sageplot[scale=.5]{C2}
\end{minipage}

Both elliptic curves are defined by the same short Weierstrass equation $y^2 = x^3-2x+1$, but the first curve is defined over the rational numbers $\Q$, that is, the pair $(x,y)$ contains rational numbers, while the second one is defined over the prime field $\F_{9973}$, which means that both coordinates $x$ and $y$ are from the prime field $\F_{9973}$. Every blue dot represents a pair $(x,y)$, that is a solution to $y^2 = x^3-2x+1$. As we can see, the second curve hardly looks like a geometric structure one would naturally call a curve. This shows that our geometric intuitions from $\Q$ are obfuscated in curves over finite fields.

The equation $6\cdot(4a^3+ 27b^2)\neq 0$ ensures that the curve is  non-singular, which loosely means that the curve has no cusps or self-intersections in the geometric sense, if seen as an actual curve. As we will see in \ref{sec:affine_group_law}, cusps and self-intersections would make the group law potentially amibgious.

Throughout this book, the reader is advised to do as many computations in a pen-and-paper fashion as possible, as this is helps getting a deeper understanding of the details. However, when dealing with elliptic curves, computations can quickly become cumbersome and tedious, and one might get lost in the details. Fortunately, Sage is very helpful in dealing with elliptic curves. This book to introduces the reader to the great elliptic curve capabilities of Sage. The following snippet shows a way to define elliptic curves and work with them in Sage:

\begin{sagecommandline}
sage: F5 = GF(5) # define the base field
sage: a = F5(2) # parameter a
sage: b = F5(4) # parameter b
sage: # check non-sigularity
sage: F5(6)*(F5(4)*a^3+F5(27)*b^2) != F5(0)
sage: # short Weierstrass curve 
sage: E = EllipticCurve(F5,[a,b]) # y^2 == x^3 + ax +b 
sage: P = E(0,2) # 2^2 == 0^3 + 2*0 + 4
sage: P.xy() # affine coordinates
sage: INF = E(0) # point at infinity
sage: try: 	# point at infinity has no affine coordinates
....:     INF.xy()
....: except ZeroDivisionError:
....:     pass
sage: P = E.plot() # create a plotted version 
\end{sagecommandline}
The following three examples give a more practical understanding of what an elliptic curve is and how we can compute it. The reader is advised to read them carefully, and ideally, to also carry out the computation themselves. We will repeatedly build on these examples in this chapter, and use the second example throughout the entire book.
\begin{example}\label{E1F5} Consider the prime field $\F_5$ from example \ref{primfield_z_5}. To define an elliptic curve over $\F_5$, we have to choose two numbers $a$ and $b$ from that field. Assuming we choose $a=1$ and $b=1$ then $\kongru{4a^3+ 27b^2}{1}{5}$ from which follows that the corresponding elliptic curve $E_1(\F_5)$ is given by the set of all pairs $(x,y)$ from $\F_5$ that satisfy the equation $y^2=x^3+x+1$, together with the special symbol $\Oinf$, which represents the ``point at infinity''. 

To get a better understanding of that curve, observe that if we choose arbitrarily the pair $(x,y)=(1,1)$, we see that $1^2 \neq 1^3+1 + 1$ and hence $(1,1)$ is not an element of the curve $E_1(\F_5)$. On the other hand choosing for example $(x,y)=(2,1)$ gives $1^2 = 2^3 + 2 + 1$ and hence the pair $(2,1)$ is an element of $E_1(\F_5)$ (Remember that all computations are done in modulo $5$ arithmetics).

Now since the set $\F_5\times \F_5$ of all pairs $(x,y)$ from $\F_5$ contains only $5\cdot 5=25$ pairs, we can compute the curve, by just inserting every possible pair $(x,y)$ into the short Weierstrass equation $y^2 = x^3 + x +1$. If the equation holds, the pair is a curve point, if not that means that the point is not on the curve. Combining the result of this computation with the point at infinity gives the curve as follows:
$$
E_1(\F_5) = \{\Oinf, (0,1),(2,1),(3,1),(4,2),(4,3),(0,4),(2,4),(3,4)\}
$$
This means that the elliptic curve is a set of $9$ elements, $8$ of which are pairs of elements from $\F_5$ and one special symbol $\Oinf$. Visualizing $E_1(\F_5)$ gives the following plot:
\begin{sagesilent}
F5 = GF(5)
E1 = EllipticCurve(F5, [1,1])
C1 = E1.plot()
\end{sagesilent}
\begin{center} 
\sageplot[scale=.5]{C1}
\end{center}
% sage: AffinePoints = [P.xy() for P in E1.points() if P.order > 1]
\end{example}
In the development of SNARKs, it is sometimes necessary to do elliptic curve cryptography ``in a circuit", which basically means that the elliptic curves need to be implemented in a certain SNARK-friendly way. We will look at what this means in chapter \ref{chap:circuit-compilers}. To be able to do this efficiently, it is desirable to have curves with special properties. The following example is a pen-and-paper version of such a curve, called Tiny-\comms{jubjub}, which resembles a well known cryptographically secure curve, called Baby-jubjub, which is extensively used in real-world SNARKs. In the literature the Baby-jubjub curve is commonly introduced as a so called twisted Edwards curve, which we will introduce in \ref{sec:edwards}. However as we will see in \ref{sec:edwards}, every twisted Edwards curve is equivalent to a short Weierstrass curve and hence we start with an introduction of Tiny-Jubjub in its short Weierstrass version. The interested reader is advised to study this example carefully, as we will use it and build on it in various places throughout the book. 

\begin{example}[Tiny-Jubjub]\label{TJJ13} Consider the prime field $\F_{13}$ from exercise \ref{prime_field_F13}. If we choose $a=8$ and $b=8$, then $\kongru{4a^3+ 27b^2}{6}{13}$ and the corresponding elliptic curve is given by all pairs $(x,y)$ from $\F_{13}$ such that $y^2=x^3+8x+8$ holds. We call this curve the \term{Tiny-jubjub} curve (in its affine short Weierstrass representation), or $\mathit{TJJ\_13}$ for short.

Since the set $\F_{13}\times \F_{13}$ of all pairs $(x,y)$ from $\F_{13}$ contains only $13\cdot 13=169$ pairs, we can compute the curve by just inserting every possible pair $(x,y)$ into the short Weierstrass equation $y^2 = x^3 +8x +8$.  We get the following result:
\begin{multline}\label{eq:TJJ13-weierstrass}
%\begin{split}
\mathit{TJJ\_13} = \{\Oinf, (1, 2), (1, 11), (4, 0), (5, 2), (5, 11), (6, 5), (6, 8), (7,2), (7, 11), \\ (8, 5), (8, 8), (9, 4), (9, 9), (10, 3), (10,10), (11, 6), (11, 7), (12, 5), (12, 8)\}
%\end{split}
\end{multline}
As we can see, the curve consists of $20$ points; $19$ pairs of elements from $\F_{13}$ and the point at infinity. To get a visual impression of the $\mathit{TJJ\_13}$ curve, we might plot all of its points (except the point at infinity). We get the following plot: 
\begin{sagesilent}
F13 = GF(13)
TJJ_13 = EllipticCurve(F13, [8,8])
CTJJ_13 = TJJ_13.plot()
\end{sagesilent}
\begin{center} 
\sageplot[scale=.5]{CTJJ_13}
\end{center}
As we will see in what follows, this curve is rather special, as it is possible to represent it in two alternative forms called the \term{Montgomery} and the \term{twisted Edwards form} (See sections \ref{sec:montgomery} and \ref{sec:edwards}, respectively).
\end{example}
Now that we have seen two pen-and-paper friendly elliptic curves, let us look at a curve, that is used in actual cryptography. Cryptographically secure elliptic curves are not \hilight{qualitatively} different from the curves we looked at so far, but the prime number modulus of their prime field is much larger. Typical examples use prime numbers that have binary representations in the magnitude of more than double the size of the desired security level. If, for example, a security of $128$ bits is desired, a prime modulus of binary size $\geq 256$ is chosen. The following example provides such a curve. 

\begin{example}[Bitcoin's secp256k1 curve]\label{secp256k1}
To give an example of a real-world, cryptographically secure curve, let us look at curve secp256k1, which is famous for being used in the public key cryptography of Bitcoin. The prime field $\F_p$ of secp256k1 is defined by the following prime number:
$$
p = \scriptstyle 115792089237316195423570985008687907853269984665640564039457584007908834671663
$$
 
 The binary representation of this number needs $256$ bits, which implies that the prime field $\F_p$  contains approximately $2^{256}$ many elements, which is considered quite large. To get a better impression of how large the base field is, consider that the number $2^{256}$ is approximately in the same order of magnitude as the estimated number of atoms in the observable universe. 

The curve secp256k1 is defined by the parameters $a,b\in \F_p$ with $a=0$ and $b=7$. Since $\Zmod{4\cdot 0^3 + 27\cdot 7^2}{p}=1323$, those parameters indeed define an elliptic curve given as follows:
$$
\mathit{secp256k1} = \{(x,y)\in \F_p\times \F_p \;|\; y^2 = x^3 +7\;\} 
$$
Clearly, the secp256k1 curve is too large to do computations by hand, since it can be shown that  the number of its elements is a prime number $r$ that also has a binary representation of $256$ bits:
$$
r = \scriptstyle 11579208923731619542357098500868790785283756427907490438260516
3141518161494337
$$
Cryptographically secure elliptic curves are therefore not useful in pen-and-paper computations. Fortunately, Sage handles large curves efficiently:
\begin{sagecommandline}
sage: p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
sage: # Hexadecimal representation
sage: p.str(16)
sage: p.is_prime()
sage: p.nbits()
sage: Fp = GF(p)
sage: secp256k1 = EllipticCurve(Fp,[0,7])
sage: r = secp256k1.order() # number of elements
sage: r.str(16)
sage: r.is_prime()
sage: r.nbits()
\end{sagecommandline}
%\seqsplit{115792089237316195423570985008687907853269984665640564039457584007908834671663}
\end{example}
\begin{exercise}
Look up the definition of curve BLS12-381, implement it in Sage and compute its order.
\end{exercise}

\paragraph{Affine compressed representation} As we have seen in example \ref{secp256k1}, cryptographically secure elliptic curves are defined over large prime fields, where elements of those fields typically need more than $255$ bits of storage on a computer. Since elliptic curve points consist of pairs of those field elements, they need double that amount of storage.

However, we can reduce the amount of space needed to represent a curve point by using a technique called \term{point compression}. To understand this, note that for each given $x\in\F$, there are only $2$ possible $y\in \F$, such that the pair $(x,y)$ is a point on an affine short Weierstrass curve, since $x$ and $y$ have to satisfy the equation $y^2 = x^3 + a\cdot x + b$. From this follows that $y$ can be computed from $x$, since it is an element from the set $\sqrt{x^3 + a\cdot x +b}$ of square roots \ref{ded:square_root}, which contains exactly two elements. 

This implies that we can represent a curve point in \term{compressed form} by simply storing the $x$ coordinate together with a single bit called the \term{sign bit}, the latter of which deterministically decides which of the two roots to choose. One convention could be to always choose the root closer to $0$ when the sign bit is $0$, and the root closer to the order of $\F$ when the sign bit is $1$. In case the $y$ coordinate is zero, both sign bits give the same result.

\begin{example}[Tiny-jubjub] To understand the concept of compressed curve points a bit better, consider the $\mathit{TJJ\_13}$ curve from example \ref{TJJ13} again. Since this curve is defined over the prime field $\F_{13}$, and numbers between $0$ and $13$ need approximately $4$ bits to be represented, each $\mathit{TJJ\_13}$ point on this curve needs $8$ bits of storage in uncompressed form. The following set represents the uncompressed form of the points on this curve:
\begin{multline*}
\mathit{TJJ\_13} = \{\Oinf, (1, 2), (1, 11), (4, 0), (5, 2), (5, 11), (6, 5), (6, 8), (7,2), (7, 11), \\ (8, 5), (8, 8), (9, 4), (9, 9), (10, 3), (10,
10), (11, 6), (11, 7), (12, 5), (12, 8)\}
\end{multline*}
Using the technique of point compression, we can reduce the bits needed to represent the points on this curve to  $5$ per point. To achieve this, we can replace the $y$ coordinate in each $(x,y)$ pair by a sign bit indicating whether or not $y$ is closer to $0$ or to $13$. As a result $y$ values in the range $[0,\ldots,6]$ will have the sign bit $0$, while $y$-values in the range $[7,\ldots,12]$ will have the sign bit $1$. Applying this to the points in $\mathit{TJJ\_13}$ gives the compressed representation as follows:
\begin{multline*}
\mathit{TJJ\_13} = \{\Oinf, (1, 0), (1, 1), (4, 0), (5, 0), (5, 1), (6, 0), (6, 1), (7,0), (7, 1), \\ (8, 0), (8, 1), (9, 0), (9, 1), (10, 0), (10,1), (11, 0), (11, 1), (12, 0), (12, 1)\}
\end{multline*} 
Note that the numbers $7,\ldots, 12$ are the negatives (additive inverses) of the numbers $1,\ldots, 6$ in modular $13$ arithmetics and that $-0=0$.

To recover the uncompressed counterpart of, say, the compressed point $(5,1)$, we insert the $x$ coordinate $5$ into the short Weierstrass equation and get $y^2 = 5^3 + 8\cdot 5 +8 = 4$. As expected, $4$ is a quadratic residue in $\F_{13}$ with roots $\sqrt{4}= \{2,11\}$. Since the sign bit of the point is $1$, we have to choose the root closer to the modulus $13$, which is $11$. The uncompressed point is therefore $(5,11)$. 
\end{example}
\begin{comment}
Looking at the previous examples, the compression rate does not look very impressive. However, looking at the real-life example of the secp256k1 curve shows that compression is has significant practical advantages.
\begin{example}
Consider the secp256k1 curve from example \ref{secp256k1} again. The following code invokes Sage to generate a random affine curve point, then applies our compression method to it:
\begin{sagecommandline}
sage: P = secp256k1.random_point().xy()
sage: P
sage: # uncompressed affine point size
sage: ZZ(P[0]).nbits()+ZZ(P[1]).nbits()
sage: # compute the compression
sage: if P[1] > Fp(-1)/Fp(2):
....:     PARITY = 1
....: else:
....:     PARITY = 0
sage: PCOMPRESSED = [P[0],PARITY]
sage: PCOMPRESSED
sage: # compressed affine point size
sage: ZZ(PCOMPRESSED[0]).nbits()+ZZ(PCOMPRESSED[1]).nbits()
\end{sagecommandline}
\end{example}\sme{add explanation of how this shows what we claim}
\end{comment}

\subsection{Affine Group Law}
\label{sec:affine_group_law}
%group law
% http://wwwmayr.informatik.tu-muenchen.de/konferenzen/Jass07/courses/1/Lukyanenko/Lukyanenk_Paper.pdf
One of the key properties of an elliptic curve is that it is possible to define a group law on the set of its points such that the point at infinity serves as the neutral element and inverses are reflections on the $x$-axis. The origin of this law can be understood in a geometric picture and is known as the \term{chord-and-tangent rule}. In the affine representation of a short Weierstrass curve, the rule can be described in the following way, using the symbol $\oplus$ for the group law:

\begin{itemize}
\label{def:chord-and-tangent}
\item (Point at infinity) We define the point at infinity $\Oinf$ as the neutral element of addition, that is, we define $P\oplus\Oinf = P$ for all points $P\in E(\F)$.
\item (Chord Rule) Let $P, Q\in E(\F)\textbackslash \{\Oinf\}$ with $P\neq Q$ be two distinct points on an elliptic curve, neither of them the point at infinity. The sum of $P$ and $Q$ is defined as follows:\\
Consider the line $l$ which intersects the curve in $P$ and $Q$. If $l$ intersects the elliptic curve at a third point $R'$, define the sum $R=P\oplus Q$ of $P$ and $Q$ as the reflection of $R'$ at the $x$-axis. If the line $l$ does not intersect the curve at a third point, define the sum to be the point at infinity $\Oinf$. Calling such a line a \term{chord}, it can be shown that no chord will intersect the curve in more than three points. This implies that addition is not ambiguous.
\item (Tangent Rule) Let $P \in E(\F)\textbackslash \{\Oinf\}$ be a point on an elliptic curve, that is not the point at infinity. The sum of $P$ with itself (the doubling of $P$) is defined as follows:\\
Consider the line which is tangential to the elliptic curve at $P$, which means that it ''just touches'' the curve at that point. If this line intersects the elliptic curve at a second point $R'$, the sum $P\oplus P$ is the reflection of $R'$ at the $x$-axis. If it does not intersect the curve at a third point define the sum to be the point at infinity $\Oinf$. Calling such a line a \term{tangent}, it can be shown that no such tangent will intersect the curve in more than two points. This implies that doubling is not ambiguous.
\end{itemize}
It can be shown that the points of an elliptic curve form a commutative group with respect to the previously stated chord-and-tangent rule such that $\Oinf$ acts the neutral element, and the inverse of any element $P\in E(\F)$ is the reflection of $P$ on the $x$-axis. 

The chord-and-tangent rule defines the group law of an elliptic curve geometrically. In order to apply those rules on a computer we have to translate it into algebraic equations. To do so first observe that for any two given curve points $(x_1,y_1), (x_2,y_2)\in E(\F)$ the identity $x_1=x_2$ implies $y_2=\pm y_1$, which shows that the following rules are a complete description of elliptic curve group $(E(\F),\oplus)$:
\begin{itemize}
\label{def:chord-tangent-algebra}
\item (The neutral element) The point at infinity $\Oinf$ is the neutral element.
\item (The inverse element) The inverse of $\mathcal{O}$ is $\mathcal{O}$. For any other curve point $(x,y) \in E(\F)\textbackslash \{\mathcal{O}\}$, the inverse is given by $(x,-y)$.
\item (The group law) For any two curve points $P, Q \in E(\F)$, the group law is defined by one of the following cases:
\begin{enumerate}
\item (Neutral element) If $Q=\Oinf$, then the group law is defined as $P\oplus Q=P$.
\item (Inverse elements)  If $P=(x,y)$ and $Q=(x,-y)$, the group law is defined as $P\oplus Q=\Oinf$.
\item (Tangent Rule) If $P=(x,y)$ with $y\neq 0$, the group law $P\oplus P=(x',y')$ is defined as follows:
$$
\begin{array}{llr}
x' = \left(\frac{3x^2+a}{2y}\right)^2 -2x &,&
y' = \left(\frac{3x^2+a}{2y}\right)^2\left(x-x'\right) - y
\end{array} 
$$
\item (Chord Rule) If $P=(x_1,y_1)$ and $Q=(x_2,y_2)$ such that $x_1 \neq x_2$, the group law $R=P\oplus Q$ with $R=(x_3,y_3)$ is defined as follows:
$$
\begin{array}{llr}
x_3 = \left(\frac{y_2-y_1}{x_2-x_1}\right)^2 -x_1-x_2 &, &
y_3 = \left(\frac{y_2-y_1}{x_2-x_1} \right)\left(x_1-x_3\right) - y_1
\end{array} 
$$
\end{enumerate}
\end{itemize}
\begin{notation}
Let $\F$ be a field and $E(\F)$ be an elliptic curve over $\F$. We write $\oplus$ for the group law on $E(\F)$, $(E(\F),\oplus)$ for the commutative group of elliptic curve points and use the additive notation \ref{def:additive_notation} on this group. If $P$ is a point on a short Weierstrass curve with $P=(x,0)$ then $P$ is called \term{self-inverse}.
\end{notation}
As we can see, it is very efficient to compute inverses on elliptic curves. However, computing the addition of elliptic curve points in the affine representation needs to consider many cases and involves extensive finite field divisions. As we will see in \ref{sec:projective_group_law}, the addition law is simplified in projective coordinates.

To get some practical impression of how the group law on an elliptic curve is computed, let's look at some actual cases: 
\begin{example}\label{ex:01+42}
Consider the elliptic curve $E_1(\F_5)$ from example \ref{E1F5} again. As we have seen, the curve conists of the following $9$ elements:
$$
E_1(\F_5) = \{\Oinf, (0,1),(2,1),(3,1),(4,2),(4,3),(0,4),(2,4),(3,4)\}
$$
We know that this set defines a group, so we can add any two elements from $E_1(\F_5)$ to get a third element. 

To give an example, consider the elements $(0,1)$ and $(4,2)$. Neither of these elements is the neutral element $\Oinf$, and since, the $x$ coordinate of $(0,1)$ is different from the $x$ coordinate of $(4,2)$, we know that we have to use the chord rule from definition \ref{def:chord-tangent-algebra} to compute the sum $(0,1)\oplus (4,2)$:
%\begin{tabular}{lr}
\begin{align*}
x_3  & = \left(\frac{y_2-y_1}{x_2-x_1}\right)^2 -x_1-x_2 & \text{\# insert points}\\
     & = \left(\frac{2-1}{4-0}\right)^2 -0-4  & \text{\# simplify in } \F_5\\
     & = \left(\frac{1}{4}\right)^2 +1
       = 4^2 +1
       = 1 +1 
       = 2
\\
\\
y_3  & = \left(\frac{y_2-y_1}{x_2-x_1} \right)\left(x_1-x_3\right) - y_1  & \text{\# insert points}\\     
     & = \left(\frac{2-1}{4-1} \right)\left(0-2\right) - 1   & \text{\# simplify in } \F_5\\    
     & = \left(\frac{1}{4} \right)\cdot 3 + 4   
       = 4\cdot 3 + 4
       = 2 + 4
       = 1          
\end{align*} 
%\end{tabular}
So, in the elliptic curve $E_1(\F_5)$ we get $(0,1)\oplus (4,2) =(2,1)$, and, indeed, the pair $(2,1)$ is an element of $E_1(\F_5)$ as expected. On the other hand, $(0,1)\oplus (0,4) =\Oinf$, since both points have equal $x$ coordinates and inverse $y$ coordinates, rendering them inverses of each other. Adding the point $(4,2)$ to itself, we have to use the tangent rule from definition \ref{def:chord-tangent-algebra}:
\begin{align*}
x'  & = \left(\frac{3x^2+a}{2y}\right)^2 -2x   & \text{\# insert points}\\
    & = \left(\frac{3\cdot 4^2+1}{2\cdot 2}\right)^2 -2\cdot 4 & \text{\# simplify in } \F_5 \\
    & = \left(\frac{3\cdot 1+1}{4}\right)^2 +3\cdot 4
      = \left(\frac{4}{4}\right)^2 +2
      = 1 +2 
      = 3
\\
\\
y'  & = \left(\frac{3x^2+a}{2y}\right)^2\left(x-x'\right) - y  & \text{\# insert points} \\
    & = \left(\frac{3\cdot 4^2+1}{2\cdot 2}\right)^2\left(4-3\right) - 2 & \text{\# simplify in } \F_5\\
    & = 1\cdot 1 + 3
      = 4
\end{align*}
So, in the elliptic curve $E_1(\F_5)$, we get the doubling  of $(4,2)$, that is, $(4,2)\oplus (4,2) =(3,4)$, and, indeed the pair $(3,4)$ is an element of $E_1(\F_5)$ as expected. The group $E_1(\F_5)$ has no self-inverse points other than the neutral element $\Oinf$, since no point has $0$ as its $y$ coordinate. We can invoke Sage to double-check the computations. 
\begin{sagecommandline}
sage: F5 = GF(5)
sage: E1 = EllipticCurve(F5,[1,1])
sage: INF = E1(0) # point at infinity
sage: P1 = E1(0,1)
sage: P2 = E1(4,2)
sage: P3 = E1(0,4)
sage: R1 = E1(2,1)
sage: R2 = E1(3,4)
sage: R1 == P1+P2
sage: INF == P1+P3
sage: R2 == P2+P2
sage: R2 == 2*P2
sage: P3 == P3 + INF
\end{sagecommandline}
\end{example}
\begin{example}[Tiny-jubjub]\label{ex:TJJ13-self-inverse} Consider the $\mathit{TJJ\_13}$-curve from example \ref{TJJ13} again and recall that its group of points is given as follows:
\begin{multline*}
\mathit{TJJ\_13} = \{\Oinf, (1, 2), (1, 11), (4, 0), (5, 2), (5, 11), (6, 5), (6, 8), (7,2), (7, 11), \\ (8, 5), (8, 8), (9, 4), (9, 9), (10, 3), (10,
10), (11, 6), (11, 7), (12, 5), (12, 8)\}
\end{multline*}
In contrast to the group from the previous example, this group contains a self-inverse point, which is different from the neutral element, defined by $(4,0)$. To see what this means, observe that we cannot add $(4,0)$ to itself using the tangent rule 3 from definition \ref{def:chord-tangent-algebra}, as the $y$ coordinate is zero. Instead, we have to use the rule for additive inverses, since $0=-0$. We therefore get $(4,0)\oplus (4,0)=\Oinf$ in $\mathit{TJJ\_13}$. The point $(4,0)$ is therefore the inverse of itself, as adding it to itself results in the neutral element. 
\begin{sagecommandline}
sage: F13 = GF(13)
sage: TJJ = EllipticCurve(F13,[8,8])
sage: P = TJJ(4,0)
sage: INF = TJJ(0) # Point at infinity
sage: INF == P+P
sage: INF == 2*P
\end{sagecommandline}
\end{example}
\begin{example}
Consider the secp256k1 curve from example \ref{secp256k1} again. The following code invokes Sage to generate two random affine curve points and to add these points together: 
\begin{sagecommandline}
sage: P = secp256k1.random_point()
sage: Q = secp256k1.random_point()
sage: R = P + Q
sage: P.xy()
sage: Q.xy()
sage: R.xy()
\end{sagecommandline}
\end{example}
\begin{exercise}
Consider the commutative group $(\mathit{TJJ\_13},\oplus)$ of the Tiny-jubjub-curve from example \ref{TJJ13}. 
\begin{enumerate}
\item Compute the inverse of $(10,10)$, $\Oinf$, $(4,0)$ and $(1,2)$.
\item Solve the equation $x + (9,4) = (5,2) $ for some $x\in \mathit{TJJ\_13}$
\end{enumerate}
\end{exercise}

\paragraph{Scalar multiplication}
As we have seen in the previous section, elliptic curves $E(\F)$ have the structure of a commutative group associated to them. It can be shown that this group is finite and cyclic whenever the underlying field $\F$ is finite and as we know from \ref{scalarmultiplication} this implies, that there is a notation of scalar multiplication associated to any elliptic curve over finite fields.

To understand this scalar multiplication, recall from \pageref{cyclic-groups} that every finite cyclic group of order $n$ has a generator $g$ and an associated exponential map $g^{(\cdot)}: \Z_n \to \G$, where $g^x$ is the $x$-fold product of $g$ with itself.  

Elliptic curve scalar multiplication is the exponential map written in additive notation. To be more precise, let $\F$ be a finite field, $E(\F)$ an elliptic curve of order $n$, and $P$ a generator of $E(\F)$. Then the \term{elliptic curve scalar multiplication} with base $P$ is defined as follows ( where $[0]P = \Oinf$ and $[m]P = P+P+\ldots + P$ is the $m$-fold sum of $P$ with itself ):
$$
[\cdot]P: \Z_n \to E(\F); m \mapsto [m]P
$$
Therefore, elliptic curve scalar multiplication is an instantiation of the general exponential map using additive instead of multiplicative notation.

\paragraph{Logarithmic Ordering}
\label{def:logarithmic_ordering}
As explained in \ref{logarithm_map} the inverse of the exponential map exists and is usually called the \term{elliptic curve discrete logarithm map}. However since elliptic curves are believed to be DL-secure \ref{def:DL-secure}, we don't know of any efficient way to actually compute this map.

One useful property of the exponential map in regard to the examples in this book is that it can be used to greatly simplify pen-and-paper computations. As we have seen in example \ref{ex:01+42}, computing the elliptic curve addition law takes quite a bit of effort when done without a computer. However, when $g$ is a generator of a small pen-and-paper elliptic curve group of order $n$, we can use the exponential map to write the elements of the group in the following way, which we call its \term{logarithmic order} with respect to the generator $g$:
\begin{equation}\label{def:logarithmic_order}
\G = \{[1]g\to [2]g \to [3]g\to\cdots\to [n-1]g\to \Oinf\}
\end{equation} 
For small pen and paper groups, the logarithmic order greatly simplifies complicated elliptic curve addition to the much simpler case of modular $n$ arithmetic. In order to add two curve points $P$ and $Q$, we only have to look up their discrete log relations with the generator $P=[l]g$ and $Q=[m]g$, and compute the group law as $P\oplus Q = [l+m]g$, where $l+m$ is addition in modular $n$ arithmetics. 

The reader should keep in mind though, that elliptic curves are believed to be DL-secure \ref{def:DL-secure}, which implies that the logarithmic order can only be computed for very small groups.  

In the following example, we will look at some implications of the fact that elliptic curves are finite cyclic groups and apply the logarithmic order:
\begin{example}\label{ex:G1G2-subgroups} Consider the elliptic curve group $E_1(\F_5)$ from example \ref{E1F5}. Since it is a finite cyclic group of order $9$, and the prime factorization of $9$ is $3\cdot 3$, we can use the fundamental theorem of finite cyclic groups \ref{def:fundamental_theorem_groups} to reason about all its subgroups. In fact, since the only  factors of $9$ are $1$, $3$ and $9$, we know that $E_1(\F_5)$ has the following subgroups:
\begin{itemize}
\item $E_1(\F_5)[9]$ is a subgroup of order $9$. By definition, any group is a subgroup of itself.
\item $E_1(\F_5)[3] = \{(2,1),(2,4),\Oinf\}$ is a subgroup of order $3$. This is the subgroup associated to the prime factor $3$.
\item $E_1(\F_5)[1] = \{\Oinf\}$ is a subgroup of order $1$. This is the trivial subgroup.
\end{itemize}
Moreover, since $E_1(\F_5)$ and all its subgroups are cyclic, we know from \pageref{cyclic-groups} that they must have generators. For example, the curve point $(2,1)$ is a generator of the order $3$ subgroup $E_1(\F_5)[3]$, since every element of $E_1(\F_5)[3]$ can be generated by repeatedly adding $(2,1)$ to itself: 
\begin{align*}
[1](2,1) & = (2,1) \\
[2](2,1) & = (2,4) \\
[3](2,1) & = \Oinf
\end{align*}
Since $(2,1)$ is a generator, we know from \ref{exponentialmap} that it gives rise to an exponential map from the finite field $\F_3$ onto $\G_2$ defined by scalar multiplication:
$$
[\cdot](2,1): \F_3 \to E_1(\F_5)[3]\; : \; x\mapsto [x](2,1) 
$$
To give an example of a generator that generates the entire group $E_1(\F_5)$, consider the point $(0,1)$. Applying the tangent rule repeatedly, we compute as follows:
$$
\begin{array}{lccr}
{}\begin{array}{lcl}
{}[0](0,1) &=& \Oinf \\
{}[2](0,1) &=& (4, 2) \\ 
{}[4](0,1) &=& (3, 4) \\ 
{}[6](0,1) &=& (2, 4) \\ 
{}[8](0,1) &=& (0, 4) \\ 
\end{array} & & &
{}\begin{array}{lcl}
{}[1](0,1) &=& (0, 1) \\
{}[3](0,1) &=& (2, 1) \\
{}[5](0,1) &=& (3, 1) \\
{}[7](0,1) &=& (4, 3) \\
{}[9](0,1) &=& \Oinf
\end{array}
\end{array}
$$
Again, since $(2,1)$ is a generator, we know from \ref{exponentialmap} that it gives rise to an exponential map. However, since the group order is not a prime number, the exponential map does not map from any field, but from the ring $\Z_9$ of modular $9$ arithmetics:
$$
[\cdot](0,1): \Z_9 \to E_1(\F_5)\; : \; x\mapsto [x](0,1) 
$$
Using the generator $(0,1)$ and its associated exponential map, we can write $E(\F_1)$ i logarithmic order with respect to $(0,1)$ as explained in \ref{def:logarithmic_ordering}. We get the following:
$$
E_1(\F_5) = \{(0, 1)\to (4, 2)\to (2, 1)\to (3, 4)\to (3, 1)\to (2, 4)\to (4, 3)\to (0, 4)\to \Oinf \}
$$
This indicates that the first element is a generator, and the $n$-th element is the scalar product of $n$ and the generator. To see how logarithmic orders like this simplify the computations in small elliptic curve groups, consider example \ref{ex:01+42} again. In that example, we use the chord-and-tangent rule to compute $(0,1)\oplus (4,2)$. Now, in the logarithmic order of $E_1(\F)$, we can compute that sum much easier, since we can directly see that $(0,1)=[1](0,1)$ and $(4,2)=[2](0,1)$. We can then deduce $(0,1)\oplus (4,2)= (2,1)$ immediately, since $[1](0,1)\oplus [2](0,1)= [3](0,1)=(2,1)$.

To give another example, we can immediately see that $(3,4)\oplus (4,3) = (4,2)$, without doing any expensive elliptic curve addition, since we know $(3,4)= [4](0,1)$ as well as $(4,3)= [7](0,1)$ from the logarithmic representation of $E_1(\F_5)$. Since $4+7 = 2$ in $\Z_9$, the result must be $[2](0,1)=(4,2)$.

Finally we can use $E_1(\F_5)$ as an example to understand the concept of cofactor clearing from \label{def:cofactor_clearing}. Since the order of $E_1(\F_5)$ is $9$, we only have a single factor, which happen to be the cofactor as well. Cofactor clearing then implies that we can map any element from $E_1(\F_5)$ onto its prime factor group $E_1(\F_5)[3]$ by scalar multiplication with $3$. For example, taking the element $(3,4)$, which is not in $E_1(\F_5)[3]$, and multiplying it with $3$, we get $[3](3,4)= (2,1)$, which is an element of $E_1(\F_5)[3]$ as expected.
\end{example}
In the following example, we will look at the subgroups of the tiny-jubjub curve, define generators, and compute the logarithmic order for pen-and-paper computations. Then we take another look at the principle of cofactor clearing.

\begin{example}\label{ex:TJJ13-cofactor-clearing} Consider the tiny-jubjub curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}\sme{check reference} again. Since the order of $\mathit{TJJ\_13}$ is $20$, and the prime factorization of $20$ is $2^2\cdot 5$, we know that the $\mathit{TJJ\_13}$ contains a ``large'' prime-order subgroup of size $5$ and a small prime oder subgroup of size $2$. 

To compute those groups, we can apply the technique of cofactor clearing in a try-and-repeat loop. We start the loop by arbitrarily choosing an element $P\in \mathit{TJJ\_13}$, then multiplying that element with the cofactor of the group that we want to compute. If the result is $\Oinf$, we try a different element and repeat the process until the result is different from the point at infinity $\Oinf$.  

To compute a generator for the small prime-order subgroup $(\mathit{TJJ\_13})_2$, first observe that the cofactor is $10$, since $20=2\cdot 10$. We then arbitrarily choose the curve point $(5,11)\in \mathit{TJJ\_13}$ and compute $[10](5,11)=\Oinf$. Since the result is the point at infinity, we have to try another curve point, say $(9,4)$. We get $[10](9,4)=(4,0)$ and we can deduce that $(4,0)$ is a generator of $(\mathit{TJJ\_13})_2$. Logarithmic order then gives
$(\mathit{TJJ\_13})[2] = \{(4,0)\to \Oinf\}$
as expected, since we know from example \ref{ex:TJJ13-self-inverse}\sme{check reference} that $(4,0)$ is self-inverse, with $(4,0)\oplus (4,0)=\Oinf$. We double check the computations using Sage: 
\begin{sagecommandline}
sage: F13 = GF(13)
sage: TJJ = EllipticCurve(F13,[8,8])
sage: P = TJJ(5,11)
sage: INF = TJJ(0)
sage: 10*P == INF
sage: Q = TJJ(9,4)
sage: R = TJJ(4,0)
sage: 10*Q == R
\end{sagecommandline}
We can apply the same reasoning to the ``large'' prime-order subgroup $(\mathit{TJJ\_13})[5]$, which contains $5$ elements. To compute a generator for this group, first observe that the associated cofactor is $4$, since $20=5\cdot 4$. We choose the curve point $(9,4)\in \mathit{TJJ\_13}$ again, and compute $[4](9,4)=(7,11)$. Since the result is not the point at infinity, we know that $(7,11)$ is a generator of $(\mathit{TJJ\_13})[5]$. Using the generator $(7,11)$, we compute the exponential map $[\cdot](7,11): \F_5 \to \mathit{TJJ\_13}[5]$ and get the following:
\begin{align*}
[0](7,11) &= \Oinf\\
[1](7,11) &= (7,11)\\
[2](7,11) &= (8,5)\\
[3](7,11) &= (8,8)\\
[4](7,11) &= (7,2)
\end{align*}
We can use this computation to write the large-order prime group $(\mathit{TJJ\_13})[5]$ of the tiny-jubjub curve in logarithmic order, which we will use quite frequently in what follows. We get the following:
\begin{equation}\label{eq:TJJ13-logarithmic-order}
(\mathit{TJJ\_13})[5] = \{(7,11)\to(8,5)\to(8,8)\to(7,2)\to \Oinf\}
\end{equation}
From this, we can immediately see, for example that  $(8,8)\oplus (7,2)= (8,5)$, since 
$3+4=2$ in $\F_5$.
\end{example}
From the previous two examples, the reader might get the impression that elliptic curve computation can be largely replaced by modular arithmetics. This however, is not true in general, but only an artifact of small groups, where it is possible to write the entire group in a logarithmic order.

\subsection{Projective short Weierstrass form}
% https://www.cosic.esat.kuleuven.be/bcrypt/lecture%20slides/wouter.pdf
As we have seen in the previous section, describing elliptic curves as pairs of points that satisfy a certain equation is relatively straight-forward. However, in order to define a group structure on the set of points, we had to add a special point at infinity to act as the neutral element. 

Recalling from the definition of projective planes \ref{sec:planes}, we know that points at infinity are handled as ordinary points in projective geometry. Therefore, it makes  sense to look at the definition of a short Weierstrass curve in projective geometry.

To see what a short Weierstrass curve in projective coordinates is, let $\F$ be a finite field of order $q$ and characteristic $>3$, let $a,b\in \F$ be two field elements such that $\Zmod{4a^3+ 27b^2}{q}\neq 0$ and let $\F\mathrm{P}^2$ be the projective plane over $\F$ as introduced in \ref{sec:planes}. Then a \term{projective short Weierstrass elliptic curve} over $\F$ is the set of all points $[X:Y:Z]\in \F\mathrm{P}^2$ from the projective plane that satisfy the cubic equation $Y^2\cdot Z = X^3+a\cdot X\cdot Z^2 + b\cdot Z^3$:

\begin{equation}
\label{def:projective_cubic_equation}
E(\F\mathrm{P}^2) = \{[X:Y:Z]\in \F\mathrm{P}^2\;|\; Y^2\cdot Z = X^3+a\cdot X\cdot Z^2 + b\cdot Z^3 \}
\end{equation}

To understand how the point at infinity is unified in this definition, recall from \ref{sec:planes} that, in projective geometry, points at infinity are given by projective coordinates $[X:Y:0]$. Inserting representatives $(x_1,y_1,0)\in [X:Y:0]$ from those coordinates into the defining cubic equation \ref{def:projective_cubic_equation} results in the following identity:
\begin{align*}
y_1^2\cdot 0 & = x_1^3+a\cdot x_1\cdot 0^2 + b\cdot 0^3 & \Leftrightarrow \\
0 & = x_1^3
\end{align*} 

This implies $X=0$ and shows that the only projective point at infinity, that is also a point on a projective short Weierstrass curve is the class $[0,1,0] = \{(0,y,0)\;|\; y\in \F\}$. The point $[0:1:0]$ is the projective representation of the point at infinity $\mathcal{O}$ in the affine representation. The projective representation of a short Weierstrass curve, therefore, has the advantage that it does not need a special symbol to represent the point at infinity from the affine definition.

\begin{example}
\label{ex:E1F5-projective}
 To get an intuition of how an elliptic curve in projective geometry looks, consider curve $E_1(\F_5)$ from example \ref{E1F5}. We know that, in its affine representation, the set of points on the affine short Weierstrass curve is given as follows:

\begin{equation}\label{eq:E1F5-affine}
E_1(\F_5) = \{\Oinf, (0,1),(2,1),(3,1),(4,2),(4,3),(0,4),(2,4),(3,4)\}
\end{equation}

This is defined as the set of all pairs $(x,y)\in \F_5\times \F_5$ such that the affine short Weierstrass equation $y^2 = x^3 + ax +b$ with $a=1$ and $b=1$ is satisfied.

To find the set of elements of $E_1(\F_5)$ in the projective representation of a short Weierstrass curve with the same parameters $a=1$ and $b=1$, we have to compute the set of projective points $[X:Y:Z]$ from the projective plane $\F_5\mathrm{P}^2$ that satisfy the following homogenous cubic equation for any representative $(x_1,y_1,z_1)\in [X:Y:Z]$:
\begin{equation}\label{eq:homogenous-cubic}
y_1^2z_1 = x_1^3 + 1\cdot x_1 z_1^2 + 1\cdot z_1^3
\end{equation}
We know from \ref{sec:planes} that the projective plane $\F_5\mathrm{P}^2$ contains $5^2+5+1= 31$ elements, so we can take the effort and insert all elements into equation \ref{eq:homogenous-cubic} and see if both sides match.

For example, consider the projective point $[0:4:1]$. We know from \ref{def:projective_coordinate} that this point in the projective plane represents the following line in $\F_5^3\backslash\{(0,0,0)\}$:
\begin{equation}
\label{ex:projective_coordinate_1}
[0:4:1] = \{(0,4,1),(0,3,2),(0,2,3),(0,1,4)\}
\end{equation} 
To check whether or not $[0:4:1]$ satisfies \ref{eq:homogenous-cubic}, we can insert any representative, in other words, any element from \ref{ex:projective_coordinate_1}. Each element satisfies the equation if and only if all other elements satisfy the equation. So, we insert $(0,3,2)$ and get the following result:
$$
3^2\cdot 2 = 0^3 + 1\cdot 0\cdot 2^2 + 1\cdot 2^3 \Leftrightarrow
3 = 3
$$
This tells us that the affine point $[0:4:1]$ is indeed a solution to the equation \ref{eq:homogenous-cubic}, but we could just as well have inserted any other representative. For example, inserting $(0,1,4)$ also satisfies \ref{eq:homogenous-cubic}: 
$$
1^2\cdot 4 = 0^3 + 1\cdot 0\cdot 4^2 + 1\cdot 4^3 \Leftrightarrow
4=4
$$
To find the projective representation of $E_1(\F_5)$, we first observe that the projective line at infinity $[1:0:0]$ is not a curve point on any projective short Weierstrass curve, since it cannot satisfy the defining equation in \ref{def:projective_cubic_equation} for any parameter $a$ and $b$. Therefore, we can exclude it from our consideration. 

Moreover, a point at infinity $[X:Y:0]$ can only satisfy the equation in \ref{def:projective_cubic_equation} for any $a$ and $b$, if $X=0$, which implies that the only point at infinity relevant for short Weierstrass elliptic curves is $[0:1:0]$, since $[0:k:0]= [0:1:0]$ for all $k\in\F^*$. Therefore, we can exclude all points at infinity except the point $[0:1:0]$.

All points that remain are the affine points $[X:Y:1]$. Inserting all of them into \ref{eq:homogenous-cubic} we get the set of all projective curve points as follows:

\begin{multline*}
E_1(\F_5\mathrm{P}^2)=\{[0:1:0], [0:1:1], [2:1:1], [3:1:1], \\ [4:2:1], [4:3:1], [0:4:1], [2:4:1], [3:4:1]\}
\end{multline*}

If we compare this with the affine representation, we see that there is a 1:1 correspondence between the points in the affine representation in \ref{eq:E1F5-affine} and the affine points in projective geometry, and that the projective point $[0:1:0]$ represents the additional point $\Oinf$ in the affine representation.
\end{example} 

\begin{exercise}
Compute the projective representation of the tiny-jubjub curve and the logarithmic order of its large prime-order subgroup with respect to the generator $(7,11)$.
\end{exercise}

\paragraph{Projective Group law}
\label{sec:projective_group_law}
As we have seen in section \ref{sec:affine_group_law}, one of the key properties of an elliptic curve is that it comes with a definition of a group law on the set of its points, described geometrically by the chord-and-tangent rule \ref{def:chord-and-tangent}. This rule was kind of intuitive, with the exception of the distinguished point at infinity, which appeared whenever the chord or the tangent did not have a third intersection point with the curve.

One of the key features of projective coordinates is that, in projective space, it is guaranteed that any chord will always intersect the curve in three points, and any tangent will intersect it in two points. So, the geometric picture simplifies, as we don't need to consider external symbols and associated cases. The price to pay for this mathematical simplification is of course that for a beginner, projective coordinates might be less intuitive.

It can be shown that the points of an elliptic curve in projective space form a commutative group with respect to the tangent-and-chord rule such that the projective point $[0:1:0]$ is the neutral element, and the additive inverse of a point $[X:Y:Z]$ is given by $[X:-Y:Z]$. The addition law is usually described by the following algorithm, minimizing the number of necessary additions and multiplications in the base field. \final{Check if following Alg is floated too far}
% https://www.hyperelliptic.org/EFD/precomp.pdf

\begin{algorithm}\caption{Projective short Weierstrass Addition Law}
% https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Standard_Projective_Coordinates
\begin{algorithmic}[0]
\Require $[X_1:Y_1:Z_1],[X_2:Y_2:Z_2] \in E(\F\mathbb{P}^2)$
\Procedure{Add-Rule}{$[X_1:Y_1:Z_1],[X_2:Y_2:Z_2]$}
\If{$[X_1:Y_1:Z_1] == [0:1:0]$}
  \State $[X_3:Y_3:Z_3] \gets [X_2:Y_2:Z_2]$
\ElsIf{$[X_2:Y_2:Z_2] == [0:1:0]$}
  \State $[X_3:Y_3:Z_3] \gets [X_1:Y_1:Z_1]$
\Else
  \State $U_1 \gets Y_2\cdot Z_1$
  \State $U_2 \gets Y_1\cdot Z_2$
  \State $V_1 \gets X_2\cdot Z_1$
  \State $V_2 \gets X_1\cdot Z_2$
  \If{$V_1 == V_2$}
    \If{$U_1 \neq U_2$}
      $[X_3:Y_3:Z_3] \gets [0:1:0]$
    \Else
      \If{$Y_1 == 0$}
        $[X_3:Y_3:Z_3] \gets [0:1:0]$
      \Else
        \State $W \gets a\cdot Z_1^2 + 3\cdot X_1^2$
        \State $S \gets Y_1\cdot Z_1$
        \State $B \gets X_1\cdot Y_1\cdot S$
        \State $H \gets W^2 - 8\cdot B$
        \State $X' \gets 2\cdot H\cdot S$
        \State $Y' \gets W\cdot (4\cdot B - H) - 8\cdot Y_1^2\cdot S^2$
        \State $Z' \gets 8\cdot S^3$
        \State $[X_3:Y_3:Z_3] \gets [X':Y':Z']$
      \EndIf
    \EndIf
  \Else
    \State $U = U_1 - U_2$
    \State $V = V_1 - V_2$
    \State $W = Z_1\cdot Z_2$
    \State $A = U^2\cdot W - V^3 - 2\cdot V^2\cdot V_2$
    \State $X' = V\cdot A$
    \State $Y' = U\cdot(V^2\cdot V_2 - A) - V^3\cdot U_2$
    \State $Z' = V^3\cdot W$
    \State $[X_3:Y_3:Z_3]\gets [X':Y':Z']$
  \EndIf
\EndIf
\State \textbf{return} $[X_3:Y_3:Z_3]$
\EndProcedure
\Ensure $ [X_3:Y_3:Z_3] == [X_1:Y_1:Z_1] \oplus [X_2:Y_2:Z_2]$
\end{algorithmic}
\end{algorithm}
%\begin{example}[Polynomial evaluation on secret points]
%Since scalar multiplication is assumed to be a one way function, it can be used to encrypt computations. For example it can be used to proof identities of bounded degree polynomials (with some probability), without actually revealing the polynomials. To see what this means, consider the moon-jubjub curve $TJJ(\F_{13})$ from XXX\sme{add reference} and the set $\F_{13}[x]_{\leq 2}$ of all polynomials with coefficients in $\F_{13}$ and maximum degree $2$.

%Now assume that there are two parties $A$ and $B$ such that $A$ choose polynomial $P_A$ and $B$ chooses polynomial $P_B$ from $\F_{13}[x]_{\leq 2}$. The task is to check (with some probability) weather or not $P_A$ equals $P_B$ without actually revealing any information about the polynomials. 

%This task can be solved, by evaluating the polynomials at a secret point in the exponent of a (DFHM-PROPERTY) group and then compare the results.

%So we assume that there is some trusted third party $C$ that chooses a publicly known generator of a large prime-order subgroup of $TJJ(\F_{13})$, say  a secrete point $s\in\F_{13}$, say $s=2$. $C$ then c
%\end{example}

\begin{exercise}
Compare the affine addition law for short Weierstrass curves with the projective addition rule. Which branch in the projective rule corresponds to which case in the affine law? 
\end{exercise}

\paragraph{Coordinate Transformations} As we have seen in example 
\ref{ex:E1F5-projective}, there was a close relation between the affine and the projective representation of a short Weierstrass curve. This was not a coincidence. In fact, from a mathematical point of view, projective and affine short Weierstrass curves describe the same thing, as there is a one-to-one correspondence (an isomorphism) between both representations for any parameters $a$ and $b$. 

To specify the isomorphism, let $E(\F)$ and $E(\F\mathrm{P}^2)$ be an affine and a projective short Weierstrass curve defined for the same parameters $a$ and $b$. Then the following function maps points from the affine representation to points from the projective representation of a short Weierstrass curve. In other words, if the pair of field elements $(x,y)$ satisfies the affine short Weierstrass equation $y^2= x^3 + ax + b$, then all homogeneous coordinates $(x_1,y_1,z_1)\in [x:y:1]$ satisfy the projective short Weierstrass equation $y_1^2\cdot z_1= x_1^3 + ay_1\cdot z_1^2 + b\cdot z_1^3$. 

\begin{equation}\label{eq:weierstrass-isomorphism-map}
I : E(\F) \to E(\F\mathrm{P}^2)\;:\;
\begin{array}{lcl}
(x,y)       &\mapsto & [x:y:1]\\
\mathcal{O} &\mapsto & [0:1:0]
\end{array}
\end{equation}
This map is a $1:1$ correspondense, which means that it maps exactly one point from the affine representation onto one point from the projective representation. It is therefore possible to invert this map in order to map points from the projective representation to points from the affine representation of a short Weierstrass curve. The inverse is given by the following map:
\begin{equation}
I^{-1} : E(\F\mathbb{P}^2)\to E(\F) \;:\; [X:Y:Z] \mapsto \begin{cases}
(\frac{X}{Z},\frac{Y}{Z}) & \text{ if } Z\neq 0\\
\mathcal{O} & \text{ if } Z=0
\end{cases}
\end{equation}
Note that the only projective point $[X:Y:Z]$ with $Z\neq 0$ that satisfies the equation in \ref{def:projective_cubic_equation} is given by the class $[0:1:0]$. A key feature of $I$ and its inverse is that both mps respect the group structure, which means that the neutral element is mapped to the neutral element, i.e. $I(\mathcal{O})=[0:1:0]$ and that  $I((x_1,y_1)\oplus (x_2,y_2))$ is equal to $I(x_1,y_1)\oplus I(x_2,y_2)$ and the same holds true for the inverse map $I^{-1}$.

Maps with these properties are called \term{group isomorphisms}, and, from a mathematical point of view, the existence of function $I$ implies that the affine and the projective definition of short Weierstrass elliptic curves are equivalent. Implementations can therefore choose freely between both representations. 


\section{Montgomery Curves}\label{sec:montgomery}
% https://eprint.iacr.org/2017/212.pdf
Both the affine and the projective short Weierstrass forms are the most general ways to describe elliptic curves over fields of characteristics larger then $3$. However in certain situations it might be advantageous to consider more specialized representations of elliptic curves for example to get faster algorithms for the group law or the scalar multiplication. 

As we will see in this section so called Montgomery curves are a subset of all elliptic curves that can be written in the \term{Montgomery form}. Those curves allow for constant time algorithms for (specializations of) the elliptic curve scalar multiplication. 

To see what a Montgomery curve in its affine representation is, let $\F$ be a finite field of characteristic $p>3$, and let $A,B\in \F$ be two field elements such that $B\neq 0$ and $A^2 \neq 4$.  A \term{Montgomery elliptic curve} $M(\F)$ over $\F$ in its affine representation is then the set of all pairs of field elements $(x,y)\in \F\times \F$ that satisfy the \term{Montgomery cubic equation} $B\cdot y^2 = x^3 + A\cdot x^2 + x$, together with a distinguished symbol $\Oinf$, called the \term{point at infinity}.

\begin{equation}
\label{eq:montgomery-curve}
M(\F) = \{(x,y)\in \F\times \F\;|\; B\cdot y^2 = x^3 + A\cdot x^2 + x  \} \bigcup \{\Oinf\}
\end{equation}

Despite the fact that Montgomery curves look different from short Weierstrass curves, they are just a special way to describe certain short Weierstrass curves. In fact, every curve in affine Montgomery form can be transformed into an elliptic curve in short Weierstrass form. To see that, assume that a curve is given in Montgomery form $B y^2 = x^3 + A x^2 + x$. The associated short Weierstrass form is then defined as follows:

\begin{equation}\label{eq:montgomery-to-weierstrass}
y^2 = x^3 + \frac{3-A^2}{3\cdot B^2}\cdot x + \frac{2\cdot A^3-(\Zmod{9}{q})\cdot A}{(\Zmod{27}{q})\cdot B^3}
\end{equation}

On the other hand, not every elliptic curve $E(\F)$ over base field $\F$ given in short Weierstrass form $y^2 = x^3 + a x + b$ can be converted into Montgomery form. For a short Weierstrass curve to be a Montgomery curve the following conditions need to hold:
\begin{itemize}
\label{def:montgomery}
\item The number of points on $E(\F)$ is divisible by $4$
\item The polynomial $z^3 + a z + b \in \F[z]$ has at least one root $z_0\in\F$
\item $3z_0^2 + a$ is a quadratic residue in $\F^*$.
\end{itemize}

When these conditions are satisfied, then for $s=({\sqrt{3z_0^{2}+a}})^{-1}$, a Montgomery curve is defined by the following equation:
\begin{equation}\label{eq:montgomery-form}
sy^{2}=x^{3}+(3z_0 s)x^{2}+x
\end{equation}

In the following example we will look at the tiny-jubjub curve again, and show that it is actually a Montgomery curve.
\begin{example}\label{TJJ13-montgomery}
Consider the prime field $\F_{13}$ and the tiny-jubjub curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}. To see that it is a Montgomery curve, we have to check the requirements from \ref{def:montgomery}: 

Since the order  of $\mathit{TJJ\_13}$ is $20$, which is divisible by $4$, the first requirement is met. Moreover, since $a=8$ and $b=8$, we have to check that the polynomial $P(z) = z^3 + 8z + 8$ has a root in $\F_{13}$. To see this we simply evaluate $P$ at all numbers $z\in \F_{13}$, and find that $P(4)=0$, so a root is given by $z_0=4$. In the last step, we have to check that $3\cdot z_0^2 + a$ has a root in $\F_{13}^*$. We compute as follows:
\begin{align*}
3z_0^2 + a & = 3\cdot 4^2 + 8 \\
           & = 3 \cdot 3 + 8 \\
           & = 9 + 8 \\
           & = 4
\end{align*}

To see that $4$ is a quadratic residue in $\F_{13}$, we use Euler's criterion (\ref{eq: Euler_criterion}) to compute the Legendre symbol of $4$. We get the following:

$$
\left(\frac{4}{13}\right) = 4^{\frac{13-1}{2}} = 4^6 = 1
$$ 
This means that $4$ does have a root in $\F_{13}$. In fact, computing a root of $4$ in $\F_{13}$ is easy, since the integer root $2$ of $4$ is also one of its roots in $\F_{13}$. The other root is given by $13-4=9$.

Since all requirements are meet, we have shown that $\mathit{TJJ\_13}$ is indeed a Montgomery curve, and we can use \ref{eq:montgomery-form} to compute its associated Montgomery form. We compute as follows:
\begin{align*}
s & = \left(\sqrt{3\cdot z_0^2 +8}\right)^{-1} \\
  & = 2^{-1} & \text{\# Fermat's little theorem} \\
  & = 2^{13-2} & \text{\# }\Zmod{2048}{13} = 7\\
  & = 7
\end{align*}
The defining equation for the Montgomery form of the tiny-jubjub curve is then given by the following equation:
\begin{align*}
sy^{2} & =x^{3}+(3z_0 s)x^{2}+x  & \Rightarrow\\
7\cdot y^{2} & =x^{3}+(3\cdot 4 \cdot 7)x^{2}+x &\Leftrightarrow\\
7\cdot y^{2} & =x^{3}+6x^{2}+x
\end{align*}
So, we get the defining parameters as $B= 7$ and $A=6$, and we can write the tiny-jubjub curve in its affine Montgomery representation as follows:
\begin{equation}\label{eq:TJJ13-montgomery-representation}
\mathit{TJJ\_13} = \{(x,y)\in \F_{13}\times \F_{13}\;|\; 7\cdot y^{2} =x^{3}+6x^{2}+x \}\bigcup \{\Oinf\}
\end{equation}

Now that we have the abstract definition of the tiny-jubjub curve in Montgomery form, we can compute the set of points by inserting all pairs $(x,y)\in\F_{13}\times \F_{13}$ similarly to how we computed the curve points in its short Weierstrass representation. We get the following:
\begin{multline*}
\mathit{TJJ\_13} = \{\Oinf, (0, 0),(1, 4),(1, 9),(2, 4),(2, 9),(3, 5),(3, 8),(4, 4),(4, 9),\\ (5, 1),(5, 12),(7, 1),(7, 12),(8, 1),(8, 12),(9, 2),(9, 11),(10, 3),(10, 10)\}
\end{multline*}
\begin{sagecommandline}
sage: F13 = GF(13)
sage: L_MTJJ = []
....: for x in F13:
....:     for y in F13:
....:         if F13(7)*y^2 == x^3 + F13(6)*x^2 +x:
....:             L_MTJJ.append((x,y))
sage: MTJJ = Set(L_MTJJ)
sage: # does not compute the point at infinity
\end{sagecommandline}
\end{example}
\paragraph{Affine Montgomery coordinate transformation} Comparing the Montgomery representation of the previous example \ref{eq:TJJ13-montgomery-representation} with the short Weierstrass representation of the same curve \ref{eq:TJJ13-weierstrass}, we see that there is a 1:1 correspondence between the curve points in both examples. This is no accident. In fact, if $M_{A,B}$ is a Montgomery curve, and $E_{a,b}$ a short Weierstrass curve with $a = \frac{3-A^2}{3B^2}$ and $b= \frac{2A^2 -9A}{27B^3}$ then the following function maps all points in Montgomery representation onto the points in short Weierstrass representation:
\begin{equation}
I: M_{A,B} \to E_{a,b}\; : \; (x,y) \mapsto \left(\frac{3x + A}{3B}, \frac{y}{B}\right)
\end{equation}
The point at infinity of the Montgomery form is mapped to the point at infinity of the short Weierstrass form. This map is a 1:1 correspondence (an isomorphism), and its inverse map is given by the following equation (where $z_0$ is a root of the polynomial $z^3 + a z + b \in \F[z]$ and $s=({\sqrt{3z_0^{2}+a}})^{-1}$).
\begin{equation}
I^{-1}: E_{a,b} \to M_{A,B}\; : \; (x,y) \mapsto \left(s\cdot(x-z_0), s\cdot y\right)
\end{equation}
The point at infinity of the short Weierstrass form is mapped to the point at infinity of the Montgomery form. Using this map, it is therefore possible for implementations of Montgomery curves to freely transit between the short Weierstrass and the Montgomery form. 
 
\begin{example} Consider the tiny-jubjub curve again. In \ref{eq:TJJ13-weierstrass} we defined its short Weierstrass representation and in example \ref{eq:TJJ13-montgomery-representation}, we derived its Montgomery representation. 

To see how the coordinate transformation $I$ works in this example, let's map points from the Montgomery representation onto points from the short Weierstrass representation. Inserting, for example, the point $(0,0)$ from the Montgomery representation \ref{eq:TJJ13-montgomery-representation} into $I$ gives the following:
\begin{align*}
I(0,0) & = \left(\frac{3\cdot 0 + A}{3B}, \frac{0}{B}\right) \\
          & = \left(\frac{3\cdot 0 + 6}{3\cdot 7}, \frac{0}{7}\right) \\
          & = \left(\frac{6}{8}, 0\right) \\
          & = \left(4, 0\right) \\
\end{align*}

As we can see, the Montgomery point $(0,0)$ maps to the self-inverse point $(4,0)$ of the short Weierstrass representation. On the other hand, we can use our computations of $s=7$ and $z_0=4$ from example \ref{TJJ13-montgomery} to compute the inverse map $I^{-1}$, which maps points on the short Weierstrass representation to points on the Mongomery form. Inserting, for example, $(4,0)$ we get the following:
\begin{align*}
I^{-1}(4,0) & = \left(s\cdot(4-z_0), s\cdot 0\right)\\
               & = \left(7\cdot(4-4), 0\right)\\
               & = (0,0)
\end{align*}

As expected, the inverse map maps the short Weierstrass point back to where it originated in the Montgomery form. We can invoke Sage to check that our computation of $I$ is correct:
\begin{sagecommandline}
sage: # Compute I of Montgomery form:
sage: L_I_MTJJ = []
sage: for (x,y) in L_MTJJ: # LMTJJ as defined previously                                   
....:     v = (F13(3)*x + F13(6))/(F13(3)*F13(7))
....:     w = y/F13(7)
....:     L_I_MTJJ.append((v,w))
sage: I_MTJJ = Set(L_I_MTJJ)
sage: # Computation short Weierstrass form
sage: C_WTJJ = EllipticCurve(F13,[8,8]) 
sage: L_WTJJ = [P.xy() for P in C_WTJJ.points() if P.order() > 1]
sage: WTJJ = Set(L_WTJJ)
sage: # check I(Montgomery) == Weierstrass
sage: WTJJ == I_MTJJ
sage: # check the inverse map I^(-1)
sage: L_IINV_WTJJ = []
sage: for (v,w) in L_WTJJ:
....:     x = F13(7)*(v-F13(4))
....:     y = F13(7)*w
....:     L_IINV_WTJJ.append((x,y))
sage: IINV_WTJJ = Set(L_IINV_WTJJ)
sage: MTJJ == IINV_WTJJ
\end{sagecommandline}
\end{example}

\subsection{Montgomery group law} We have seen that Montgomery curves are special cases of short Weierstrass curves. As such, they have a group structure defined on the set of their points, which can also be derived from the chord-and-tangent rule. In accordance with short Weierstrass curves, it can be shown that the identity $x_1=x_2$ implies $y_2=\pm y_1$, meaning that the following rules are a complete description of the elliptic curve group law:

\begin{itemize}
\label{def:montgomery-group-law}
\item (The neutral element) The point at infinity $\Oinf$ is the neutral element.
\item (The inverse element) The inverse of $\mathcal{O}$ is $\mathcal{O}$. For any other curve point $(x,y) \in M(\F_q)\textbackslash \{\mathcal{O}\}$, the inverse is given by $(x,-y)$.
\item (The group law) For any two curve points $P, Q \in M(\F_q)$, the group law is defined by one of the following cases:
\begin{enumerate}
\item (Neutral element) If $Q=\Oinf$, then the sum is defined as $P\oplus Q=P$.
\item (Inverse elements)  If $P=(x,y)$ and $Q=(x,-y)$, the group law is defined as $P\oplus Q=\Oinf$.
\item (Tangent rule) If $P=(x,y)$ with $y\neq 0$, the group law $P\oplus P=(x',y')$ is defined as follows:
$$
\begin{array}{llr}
x' = (\frac{3x_1^2 + 2A x_1 +1}{2By_1})^2\cdot B - (x_1 + x_2) - A &,&
y' = \frac{3x_1^2 + 2A x_1 +1}{2By_1}(x_1-x') - y_1
\end{array} 
$$
\item (Chord rule) If $P=(x_1,y_1)$ and $Q=(x_2,y_2)$ such that $x_1 \neq x_2$, the group law $R=P\oplus Q$ with $R=(x_3,y_3)$ is defined as follows:
$$
\begin{array}{llr}
x' = (\frac{y_2-y_1}{x_2-x_1})^2B - (x_1 + x_2) - A &, &
y' = \frac{y_2-y_1}{x_2-x_1}(x_1-x') - y_1
\end{array} 
$$
\end{enumerate}
\end{itemize}
%\paragraph{Projective Montgomery Form}
%As with more general curves in short Weierstrass form, we can look at Montgomery curves in projective space. To see how such a curve looks in projective coordinates is, let $\F_{q}$ be a finite field and $A,B\in \F_q$ two field elements such that $B\neq 0$ and $A^2\neq 4$. Then a \term{Montgomery elliptic curve} $E/\F_q$ over $\F_q$ in its projective representation is the set
%\begin{equation}
%\label{def_short_weierstrass_curve}
%E/\F_q\mathbb{P}^2 = \{[X:Y:Z]\in \F_q\mathbb{P}^2\;|\; B\cdot Y^2 \cdot Z = X^3 + A\cdot X^2\cdot Z + X\cdot Z^2  \}
%\end{equation}
%of all points $[X:Y:Z]\in \F_q\mathbb{P}^2$ from the projective plane that satisfy the \term{homogenous} cubic equation $B\cdot Y^2 \cdot Z = X^3 + A\cdot X^2\cdot Z + X\cdot Z^2$.

% TODO: https://maths-people.anu.edu.au/~brent/pd/Subramanya-thesis.pdf
% x-coordinate only aka differential arithmetics on Montgomery curves
\section{Twisted Edwards Curves}\label{sec:edwards}
As we have seen in \ref{def:chord-tangent-algebra} and \ref{def:montgomery-group-law} both short Weierstrass and Montgomery curves have somewhat complicated group laws, as many cases have to be distinguished. Those various cases translate to branches in computer programs.

In the context of SNARK development, two computational models for bounded computations are used, called \term{circuits} \ref{sec:circuits} and \term{rank-1 constraint systems} \ref{sec:R1CS} and program branches are undesirably costly when implemented in those models. It is therefore advantageous to look for curves with a group law that requires no branches and as few field operations as possible.

\term{Twisted Edwards curves} are particularly useful here, as a subclass of these curves has a compact and easily implementable group law that works for all points including the point at infinity. Implementing this law needs no branching. 

% https://eprint.iacr.org/2008/013.pdf
To see what a \term{twisted Edwards curve} in its affine form looks like, let $\F$ be a finite field of characteristic $>3$, and let $a,d\in \F\backslash\{0\}$ be two non-zero field elements with $a\neq d$.  A \term{twisted Edwards elliptic curve} in its affine representation is then the set of all pairs $(x,y)$ from $\F\times \F$ that satisfy the twisted Edwards equation $a\cdot x^2+y^2= 1+d\cdot x^2y^2$:
\begin{equation}
E(\F)=\{(x,y)\in\F\times\F\;|\; a\cdot x^2+y^2= 1+d\cdot x^2y^2\}
\end{equation} 
A twisted Edwards curve is called a \term{SNARK-friendly twisted Edwards curve} if the parameter $a$ is a quadratic residue and the parameter $d$ is a quadratic non-residue.

As we can see from the definition, affine twisted Edwards curves look somewhat different from short Weierstrass curves, as their affine representation does not need a special symbol to represent the point at infinity. In fact, the pair $(0,1)$ is always a point on any twisted Edwards curve, and it takes the role of the point at infinity.

Despite their different appearances however, twisted Edwards curves are equivalent to Montgomery curves in the sense that, for every twisted Edwards curve, there is a Montgomery curve, and a way to map the points of one curve in a 1:1 correspondence onto the other and vice versa. To see that, assume that a curve in twisted Edwards form is given. The associated Montgomery curve is then defined by the Montgomery equation:
\begin{equation}
\frac{4}{a-d} y^2 = x^3 + \frac{2(a+d)}{a-d}\cdot x^2 + x 
\end{equation}

On the other hand, a Montgomery curve $By^{2}=x^{3}+Ax^{2}+x$ with $B\neq 0$ and $A^2\neq 4$ gives rise to a twisted Edwards curve defined by the following equation:
\begin{equation}\label{eq:montgomery-to-twisted-edwards}
(\frac{A+2}{B})x^2+y^2= 1+(\frac{A-2}{B})x^2y^2
\end{equation}

\begin{example}Consider the tiny-jubjub curve from example \ref{TJJ13} again. We know from example \ref{TJJ13-montgomery} that it is a Montgomery curve, and, since Montgomery curves are equivalent to twisted Edwards curves, we want to write this curve in twisted Edwards form. We use equation \ref{eq:montgomery-to-twisted-edwards} and compute the parameters $a$ and $d$ as follows:
\begin{align*}
a & = \frac{A+2}{B} & \text{\# insert A=6 and B=7}\\
  & = \frac{8}{7} = 3 & \text{\# } 7^{-1}= 2 \\
  \\
d & = \frac{A-2}{B} \\
  & = \frac{4}{7} = 8 
\end{align*}

Thus, we get the defining parameters as $a= 3$ and $d=8$. Since our goal is to use this curve later on in implementations of pen-and-paper SNARKs, let us show that tiny-jubjub is also a \term{SNARK-friendly} twisted Edwards curve. To see that, we  have to show that $a$ is a quadratic residue and $d$ is a quadratic non-residue. We therefore compute the Legendre symbols of $a$ and $d$ using Euler's criterion. We get the following:
\begin{align*}
\left(\frac{3}{13}\right) &= 3^{\frac{13-1}{2}} \\
                          & = 3^6 
                            = 1\\
                          \\
\left(\frac{8}{13}\right) &= 8^{\frac{13-1}{2}} \\
                          & = 8^6 
                            = 12
                            = -1                     
\end{align*}

This proves that tiny-jubjub is SNARK-friendly. We can write the tiny-jubjub curve in its affine twisted Edwards representation as follows:
\begin{equation}\label{TJJ13-twisted-edwards}
\mathit{TJJ\_13} = \{(x,y)\in \F_{13}\times \F_{13}\;|\; 3\cdot x^{2} + y^2 =1+ 8\cdot x^{2}\cdot y^2 \}
\end{equation}

Now that we have the abstract definition of our tiny-jubjub curve in twisted Edwards form, we can compute the set of points by inserting all pairs $(x,y)\in\F_{13}\times \F_{13}$, similarly to how we computed the curve points in its short Weierstrass or Edwards representation. We get the following:
\begin{equation}
\begin{split}
\mathit{TJJ\_13} = \{(0, 1),(0, 12),(1, 2),(1, 11),(2, 6),(2, 7),(3, 0),(5, 5),(5, 8),(6, 4),\\
(6, 9),(7, 4),(7, 9),(8, 5),(8, 8),(10, 0),(11, 6),(11, 7),(12, 2),(12, 11)\}
\end{split}
\end{equation}
\begin{sagecommandline}
sage: F13 = GF(13)
sage: L_ETJJ = []
....: for x in F13:
....:     for y in F13:
....:         if F13(3)*x^2 + y^2 == 1+ F13(8)*x^2*y^2:
....:             L_ETJJ.append((x,y))
sage: ETJJ = Set(L_ETJJ)
\end{sagecommandline}


\end{example}
\subsection{Twisted Edwards group law} As we have seen, twisted Edwards curves are equivalent to Montgomery curves, and, as such, also have a group law. However, in contrast to Montgomery and short Weierstrass curves, the group law of SNARK-friendly twisted Edwards curves can be described by a single computation that works in all cases, no matter if we add the neutral element, the inverse, or if we have to double a point. 

To see what the twisted Edwards group law looks like let $(x_1, y_1)$, $(x_2, y_2)$ be two points on an Edwards curve $E(\F)$. The sum of those points is then given by the following equation:

\begin{equation}\label{twisted-edwards-group-law}
(x_1, y_1) \oplus (x_2, y_2) =\left(\frac{x_1y_2+y_1x_2}{1 +dx_1x_2y_1y_2},\frac{y_1y_2-ax_1x_2}{1-dx_1x_2y_1y_2}\right)
\end{equation}

In order to see what the neutral element of the group law is, first observe that the point $(0,1)$ is a solution to the twisted Edwards equation $a\cdot x^{2} + y^2 =1+ d\cdot x^{2}\cdot y^2$ for any parameters $a$ an $d$ and hence $(0,1)$ is a point on any twisted Edwards curve. It can be shown that $(0,1)$ serves as the neutral element and that the inverse of a point $(x_1, y_1)$ is given by the point $(-x_1, y1)$.
\begin{example} Lets look at the tiny-jubjub curve in Edwards form from example \ref{TJJ13-twisted-edwards} again. As we have seen, this curve is given by
\begin{multline*}
\mathit{TJJ\_13} = \{(0, 1),(0, 12),(1, 2),(1, 11),(2, 6),(2, 7),(3, 0),(5, 5),(5, 8),(6, 4),\\
(6, 9),(7, 4),(7, 9),(8, 5),(8, 8),(10, 0),(11, 6),(11, 7),(12, 2),(12, 11)\}
\end{multline*}
To get an understanding of the twisted Edwards addition law, let's first add the neutral element $(0,1)$ to itself. We apply the group law \ref{twisted-edwards-group-law} and get the following:
\begin{align*}
(0, 1) \oplus (0, 1) &= \left(\frac{0\cdot 1+1 \cdot 0}{1 +8\cdot0\cdot 0\cdot 1\cdot 1},\frac{1\cdot 1-3\cdot 0\cdot 0}{1-8\cdot 0\cdot 0\cdot 1\cdot 1}\right)\\
                     & = (0,1)
\end{align*}
So, as expected, the neutral element added to itself gives the neutral element again. Now let's add the neutral element to some other curve point. We get the following:
\begin{align*}
(0, 1) \oplus (8, 5) &= \left(\frac{0\cdot 5+1 \cdot 8}{1 +8\cdot0\cdot 8\cdot 1\cdot 5},\frac{1\cdot 5 - 3\cdot 0\cdot 8}{1-8\cdot 0\cdot 8\cdot 1\cdot 5}\right)\\
                     & = (8,5)
\end{align*}

Again, as expected, adding the neutral element to any element will result in that element again. Given any curve point $(x,y)$, we know that its inverse is given by $(-x,y)$. To see how the addition of a point to its inverse works, we compute as follows:
\begin{align*}
(5, 5) \oplus (8, 5) &= \left(\frac{5\cdot 5+5 \cdot 8}{1 +8\cdot 5\cdot 8\cdot 5\cdot 5},\frac{5\cdot 5 - 3\cdot 5\cdot 8}{1-8\cdot 5\cdot 8\cdot 5\cdot 5}\right)\\
                     &= \left(\frac{12+1}{1 +5},\frac{12 - 3}{1-5}\right)\\
                     &= \left(\frac{0}{6},\frac{12 + 10}{1+8}\right)\\
                     &= \left(0,\frac{9}{9}\right)\\
                     &=  (0,1)
\end{align*}

Adding a curve point to its inverse gives the neutral element, as expected. As we have seen from these examples, the twisted Edwards addition law handles edge cases particularly well and in a unified way.
\end{example}

%\begin{example}[Non twisted Edwards curves have order 4 points]
%In this example, we will show that every Edwards curve has a point of order $4$. To see that let $E$ be an arbitrary Edwards curve ($a=1$). Then the point $(1,0)$ is on that curve, since $1^2+0^2= 1+d 1^2 0^2$. We compute 
%\begin{align*}
%[4](1,0) = \\
%[2]([2](1,0))=\\
%[2]\left(\frac{1 0 +1 0}{1 +d 1 1 0 0},\frac{00-1\cdot 1}{1-d1 1 00}\right)=\\
%[2](0,-1)=\\
%\left(\frac{0(-1)+(-1)0}{1 +d 0 0 (-1)(-1)},\frac{(-1)(-1)-00}{1-d00(-1)(-1)}\right) =\\
%(0,1)
%\end{align*} 

%Now having seen that every Edwards curve has point of order $4$, we can deduce that the order of every Edwards curve must contain $4$ as a factor. This is restrictive and in fact Edwards curves are rare. 
%\end{example}
\section{Elliptic Curve Pairings}
\label{sec:elliptic_curve_pairings}
As introduced in \ref{pairing-map}, some groups come with the notion of a pairing map. In this section, we discuss \term{pairings on elliptic curves}, which form the basis of several zk-SNARKs and other zero-knowledge proof schemes. We start out by defining some important subgroups of the so called full torsion group of an elliptic curve. We then introduce the Weil pairing of an elliptic curve and describe Miller's algorithm, which makes these pairings practically interesting.

\paragraph{Embedding Degrees} As we will see in what follows, every elliptic curve gives rise to a pairing map. However, we will also see in example \ref{ex:pairings_on_secp256k1} that not every such pairing can be efficiently computed. In order to distinguish curves with efficiently computable pairings from the rest, we need to start with an introduction to the so-called \term{embedding degree} of a curve. 

To see what the embedding degree of an elliptic curve is, let $\F$ be a finite field of order $|\F|=q$, $E(\F)$ an elliptic curve over $\F$, and let $n$ be a prime factor of the order of $E(\F)$. The embedding degree of $E(\F)$ with respect to $n$ is then the smallest integer $k$ such that
\begin{equation}
\label{def:embedding-degree}
n\,|\, q^k-1
\end{equation}
Fermat's little theorem \ref{fermats-little-theorem} implies that there always exists an embedding degree $k(n)$ for every elliptic curve and any factor $n$ of the curves order $n$, since $k=n-1$ is always a solution to the congruency $\kongru{q^{k}}{1}{n}$. This implies that the remainder of the integer division of $q^{n-1}-1$ by $n$ is $0$.

\begin{notation} Let $\F$ be a finite field of order $q$ and $E(\F)$ an elliptic curve over $\F$, such that $n$ is a prime factor of the order of $E(\F)$. We then write $k(n)$ for the embedding degree of $E(\F)$ with respect to $n$.
\end{notation}

\begin{example} To get a better intuition of the embedding degree, let's consider the elliptic curve $E_1(\F_5)$ from example \ref{E1F5}. We know that the order of $E_1(\F_5)$ is $9$, and, since the only prime factor of $9$ is $3$, we compute the embedding degree of $E_1(\F_5)$ with respect to $3$. 

To find the embedding degree, we have to find the smallest integer $k$ such that $3$ divides $q^k-1= 5^k-1$. We try and increment until we find a proper $k$. 

\begin{align*}
k=1 &\text{ : } 5^1-1 = 4 & \text{ not divisible by } 3\\ 
k=2 &\text{ : } 5^2-1 = 24 & \text{ divisible by } 3
\end{align*} 

This shows that the embedding degree of the elliptic curve $E_1(\F_5)$ is $2$ relative to the the prime factor $3$ of the order of $E_1(\F_5)$.
\end{example}

\begin{example}\label{ex:TJJ13-embedding-degree} Let us consider the tiny-jubjub curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}. We know that the order of $\mathit{TJJ\_13}$ is $20$, and that the order therefore has two prime factors. A ``large'' prime factor $5$ and a small prime factor $2$. 

We start by computing the embedding degree of $\mathit{TJJ\_13}$ with respect to the large prime factor $5$. To find that embedding degree, we have to find the smallest integer $k$ such that $5$ divides $q^k-1= 13^k-1$. We try and increment until we find a proper $k$. 
\begin{align*}
k=1 &\text{: } 13^1-1 = 12 & \text{ not divisible by } 5\\ 
k=2 &\text{: } 13^2-1 = 168 & \text{ not divisible by } 5\\ 
k=3 &\text{: } 13^3-1 = 2196 & \text{ not divisible by } 5\\ 
k=4 &\text{: } 13^4-1 = 28560 & \text{ divisible by } 5
\end{align*} 
Now we know that the embedding degree of $\mathit{TJJ\_13}$ relative to the the prime factor $5$ is $k(5)=4$.

In real-world applications, like on pairing-friendly elliptic curves such as BLS\_12-381, usually only the embedding degree of the large prime factor is relevant, which in the case of our tiny-jubjub curve is represented by $5$. It should be noted, however that every prime factor of a curve's order has its own notation of embedding degree despite the fact that this is mostly irrelevant in applications.

To find the embedding degree of the small prime factor $2$, we have to find the smallest integer $k$ such that $2$ divides $q^k-1= 13^k-1$. We try and increment until we find a proper $k$. 
\begin{align*}
k=1 &\text{: } 13^1-1 = 12 & \text{ divisible by } 2
\end{align*} 

Now we know that the embedding degree of $\mathit{TJJ\_13}$ is $1$ relative to the the prime factor $2$. As we have seen, different prime factors can have different embedding degrees in general.

\begin{sagecommandline}
sage: p = ZZ(13)
sage: # large prime factor
sage: n = ZZ(5)
sage: k = ZZ(1)
sage: while k < n:  # Fermat's little theorem
....:     if (p^k-1)%n == 0:
....:         break
....:     k=k+1
sage: k
sage: # small prime factor
sage: n = ZZ(2)
sage: k = ZZ(1)
sage: while k < n:  # Fermat's little theorem
....:     if (p^k-1)%n == 0:
....:         break
....:     k=k+1
sage: k
\end{sagecommandline}
\end{example}

\begin{example}
\label{ex:pairings_on_secp256k1}
 To give an example of a cryptographically secure real-world elliptic curve that does not have a small embedding degree, let's look at curve secp256k1 again. We know from \ref{secp256k1} that the order of this curve is a prime number, so we only have a single embedding degree.

To test potential embedding degrees $k$, say, in the range $1\leq k < 1000$, we can invoke Sage and compute as follows:
\begin{sagecommandline}
sage: p = ZZ(115792089237316195423570985008687907853269984665640564039457584007908834671663)
sage: n = ZZ(115792089237316195423570985008687907852837564279074904382605163141518161494337)
sage: k = ZZ(1)
sage: while k < 1000:
....:     if (p^k-1)%n == 0:
....:         break
....:     k=k+1
sage: k
\end{sagecommandline}
We see that secp256k1 has at least no embedding degree $k<1000$, which renders secp256k1 a curve that has no small embedding degree. This property will be of importance later on.
\end{example}

\paragraph{Elliptic Curves over extension fields} Suppose that $p$ is a prime number, and $\F_p$ its associated prime field. We know from equation \ref{eq:prime-extension-field}\sme{check reference} that the fields $\F_{p^m}$ are extensions of $\F_p$ in the sense that $\F_{p}$ is a subfield of $\F_{p^m}$. This implies that we can extend the affine plane that an elliptic curve is defined on by changing the base field to any extension field. To be more precise, let 
$E(\F)=\{ (x,y)\in \F \times \F \;|\; y^2 = x^3 +a\cdot x +b \}$ be an affine short Weierstrass curve, with parameters $a$ and $b$ taken from $\F$. If $\F'$ is an extension field of $\F$, then we extend the domain of the curve by defining $E(\F')$ as follows:

\begin{equation}\label{elliptic-curve-extension}
E(\F')=\{ (x,y)\in \F' \times \F' \;|\; y^2 = x^3 +a\cdot x +b \}
\end{equation}   

While we did not change the defining parameters, we consider curve points from the affine plane over the extension field now. Since $\F\subset \F'$, it can be shown that the original elliptic curve $E(\F)$ is a sub-curve of the extension curve $E(\F')$.

\begin{example}\label{ex:EF52} Consider the prime field $\F_5$ from example \ref{prime-field-F5} and the elliptic curve $E_1(\F_5)$ from example \ref{E1F5}. We constructed the extension field $\F_{5^2}$ relative to the polynomial $t^2+2 \in \F_5[t]$ in exercise \ref{exercise:finite_fieldF5_2}. In this example we extend the definition of $E_1(\F_5)$ to an elliptic curve over $\F_{5^2}$ and compute its set of points:
$$
E_1(\F_{5^2}) = \{ (x,y)\in \F_{5^2}\times \F_{5^2} \;|\; y^2 = x^3 + x +1 \}
$$
Since $\F_{5^2}$ contains $25$ points, in order to compute the set $E_1(\F_{5^2})$, we have to try $25\cdot 25 = 625$ pairs, which is probably a bit tedious. Instead, we invoke Sage to compute the curve for us. To do, we choose the representation of $\F_{5^2}$ from \ref{exercise:finite_fieldF5_2}. We get:
\begin{sagecommandline}
sage: F5= GF(5)
sage: F5t.<t> = F5[] 
sage: P_MOD_2 = F5t(t^2+2)
sage: P_MOD_2.is_irreducible()
sage: F5_2.<t> = GF(5^2, name='t', modulus=P_MOD_2)
sage: E1F5_2 = EllipticCurve(F5_2,[1,1])
sage: E1F5_2.order()
\end{sagecommandline}
The curve $E_1(\F_{5^2})$ consist of $27$ points, in contrast to curve $E_1(\F_{5})$, which consists of $9$ points. Writing those points down gives the following:
\begin{multline*}
E_1(\F_{5^2}) = \{\Oinf, (0, 4), (0, 1), (3, 4), (3, 1), (4, 3), (4, 2), (2, 4), (2, 1),\\ 
(4t + 3, 3t + 4), (4t + 3, 2t + 1),  (3t + 2, t), (3t + 2, 4t),\\ 
(2t + 2, t), (2t + 2, 4t), (2t + 1, 4t + 4), (2t + 1, t + 1),\\ 
(2t + 3, 3), (2t + 3, 2), (t + 3, 2t + 4), (t + 3, 3t + 1),\\ 
(3t + 1, t + 4), (3t + 1, 4t + 1), (3t + 3, 3), (3t + 3, 2), (1, 4t),  (1, t)
\}
\end{multline*}
As we can see, the set of points from the elliptic curve $E_1(\F_5)$ is a subset of the sets of points from the elliptic curve $E(\F_{5^2})$. This was expected since the prime field $\F_5$ is a subfield of the finite field $\F_{5^2}$.
\end{example}
\paragraph{Full torsion groups} As we will see in what follows, cryptographically interesting pairings are defined on so called torsion subgroups of elliptic curves. To define \term{torsion groups} of an elliptic curve, let $\F$ be a finite field, $E(\F)$ an elliptic curve of order $n$ and $r$ a factor of $n$. Then the \term{$r$-torsion group} of the elliptic curve $E(\F)$ is defined as the set
\begin{equation}
\label{def:torsion_group}
E(\F)[r]:= \{P\in E(\F)\;|\; [r]P = \mathcal{O}\}
\end{equation} 
The fundamental theorem of finite cyclic groups \ref{def:fundamental_theorem_groups} states that every factor $r$ of a cyclic group's order uniquely defines a subgroup of the size of that factor and those subgroup are important examples of $r$-torsion groups. We have seen examples of those subgroups in \ref{ex:G1G2-subgroups} and \ref{ex:TJJ13-cofactor-clearing}.

When we consider elliptic curve extensions as defined in \ref{elliptic-curve-extension}, we could ask what happens to the $r$-torsion groups in the extension. One might intuitively think that their extension just parallels the extension of the curve. For example, when $E(\F_p)$ is a curve over prime field $\F_p$, with some $r$-torsion group $E(\F_p)[r]$ and when we extend the curve to $E(\F_{p^m})$, then there might be a bigger $r$-torsion group $E(\F_{p^m})[r]$ such that $E(\F_p)[r]$ is a subgroup of $E(\F_{p^m})[r]$. This might make intuitive sense, as $E(\F_p)$ is a subset of $E(\F_{p^m})$. 

However, the actual situation is a bit more surprising than that. To see that, let $\F_p$ be a prime field and let $E(\F_p)$ be an elliptic curve of order $n$, such that $r$ is a factor of $n$, with embedding degree $k(r)$ and $r$-torsion group $E(\F_p)[r]$. Then it can be shown that the $r$-torsion group $E(\F_{p^m})[r]$ of a curve extension is equal to $E(\F_p)[r]$, only as long as the power $m$ is less than the embedding degree $k(r)$ of $E(\F_p)$. 

For the prime power $p^{k(r)}$, the $r$-torsion group $E(\F_{p^{k(r)}})[r]$ might then be larger than $E(\F_p)[r]$ and it contains $E(\F_p)[r]$ as a subgroup. We call it the \term{full $r$-torsion group} of that elliptic curve and write is as follows
\begin{equation}
\label{def:full_torsion_group}
E[r] := E(\F_{p^{k(r)}})[r]
\end{equation}
It can be shown that the $r$-torsion groups $E(\F_{p^m})[r]$ of any curve extensions for $m>k(r)$ are all equal to $E[r]$. In this sense $E[r]$ is already the largest $r$-torsion group, which justifies the name. The full $r$-torsion group contains $r^2$ many elements and consists of $r+1$ subgroups, one of which is $E(\F_{p})[r]$. The following diagram summarizes the situation:
\begin{equation}
\label{def:full_torsion_group_tower}
\begin{array}{lccclclclcl}
E(\F_{p}) & \subset & \cdots  & \subset & E(\F_{p^{k(r)-1}}) & \subset & E(\F_{p^{k(r)}})[r] & \subset & E(\F_{p^{k(r)+1}})[r] & \subset & \ldots\\
E(\F_{p})[r] & = & \cdots  & = & E(\F_{p^{k(r)-1}})[r] & \subset & E(\F_{p^{k(r)}})[r] & = & 
E(\F_{p^{k(r)+1}})[r] & = & \ldots
\end{array}
\end{equation}

So, when we consider nested elliptic curve extensions as in \ref{def:full_torsion_group_tower}, ordered by the prime power $m$, then the $r$-torsion group stays constant for every level $m$ that is smaller than the embedding degree $k(r)$, while it suddenly blossoms into a larger group on level $k(r)$ with $r+1$ subgroups, and then all $r$-torsion groups on higher levels $m\geq k(r)$ stay the same. In other words, once the extension field is big enough to find one more curve point $P$ with $[r]P=\mathcal{O}$ that is not an element of the curve over the base field, then we actually find all of the points in the full torsion group.

\begin{example}
\label{example:E1_full_torsion}
 Consider curve $E_1(\F_5)$ again. We know from \ref{ex:G1G2-subgroups} that it contains a $3$-torsion group and that the embedding degree of $3$ is $k(3)=2$. From this we can deduce that we can find the full $3$-torsion group $E_1[3]$ in the curve extension $E_1(\F_{5^2})$, the latter of which we computed in example \ref{ex:EF52}. 

Since that curve is small, in order to find the full $3$-torsion, we can loop through all elements of $E_1(\F_{5^2})$ and check the defining equation $[3]P= \Oinf$. Invoking Sage and using our implementation of $E_1(\F_{5^2})$ in sage from \ref{ex:EF52}, we compute as follows:
\begin{sagecommandline}
sage: INF = E1F5_2(0) # Point at infinity
sage: L_E1_3 = []
sage: for p in E1F5_2:
....:     if 3*p == INF:
....:         L_E1_3.append(p)
sage: E1_3 = Set(L_E1_3) # Full 3-torsion set
\end{sagecommandline}
$$
E_1[3] = \{\Oinf,(2,1),(2,4),(1,t),(1,4t), (2t + 1,t + 1), (2t + 1, 4t + 4), (3t + 1,t + 4), (3t + 1, 4t + 1) \}
$$
As we can see the group $E_1[3]$ contains $9=3^3$ many elements and the $3$-torsion group $E_1(\F_5)[3]$ is a subset of the full torsion group. 
\end{example}
\begin{example}\label{ex:TJJ13-full-torsion} Consider the tiny-jubjub curve from example \ref{TJJ13}. We know from example \ref{ex:TJJ13-embedding-degree} that it contains a $5$-torsion group and that the embedding degree of $5$ is $4$. This implies that we can find the full $5$-torsion group $\mathit{TJJ\_13}[5]$ in the curve extension $\mathit{TJJ\_13}(\F_{13^4})$. 

To compute the full torsion, first observe that, since $\F_{13^4}$ contains $28561$ elements, computing $\mathit{TJJ\_13}(\F_{13^4})$ means checking $28561^2=815730721$ elements. From each of these curve points $P$, we then have to check the equation $[5]P=\Oinf$. Doing this for $815730721$ is a bit too slow even on a computer.

Fortunately, Sage has a funcion that computes all points $P$, such that $[m]P=Q$ for given integer $m$ and curve point $Q$. The following Sage code  provides a way to compute the full torsion group:
\begin{sagecommandline}
sage: # define the extension field
sage: F13= GF(13) # prime field
sage: F13t.<t> = F13[] # polynomials over t
sage: P_MOD_4 = F13t(t^4+2) # irreducible polynomial of degree 4
sage: P_MOD_4.is_irreducible()
sage: F13_4.<t> = GF(13^4, name='t', modulus=P_MOD_4) # F_{13^4}
sage: TJJF13_4 = EllipticCurve(F13_4,[8,8]) # tiny-jubjub extension
sage: # compute the full 5-torsion
sage: INF = TJJF13_4(0) # point at infinity
sage: L_TJJF13_4_5 = INF.division_points(5) # All P with [5]P == INF
sage: TJJF13_4_5 = Set(L_TJJF13_4_5)
sage: TJJF13_4_5.cardinality()	# number of elements
\end{sagecommandline}
As expected, we get a group that contains $5^2=25$ elements. As it's rather tedious to write this group down, and as we don't need it in what follows, we adivese the interested reader to do it as an exercise. To see that the embedding degree $4$ is actually the smallest prime power to find the full $5$-torsion group, let's compute the $5$-torsion group over of the tiny-jubjub curve of the extension field $\F_{13^3}$. We get the following:
\begin{sagecommandline}
sage: # define the extension field
sage: P_MOD_3 = F13t(t^3+2) # irreducible polynomial of degree 3
sage: P_MOD_3.is_irreducible()
sage: F13_3.<t> = GF(13^3, name='t', modulus=P_MOD_3) # F_{13^3}
sage: TJJF13_3 = EllipticCurve(F13_3,[8,8]) # tiny-jubjub extension
sage: # compute the 5-torsion
sage: INF = TJJF13_3(0)
sage: L_TJJF13_3_5 = INF.division_points(5) # [5]P == INF
sage: TJJF13_3_5 = Set(L_TJJF13_3_5) # $5$-torsion
sage: TJJF13_3_5.cardinality()	# number of elements
\end{sagecommandline}

As we can see, the $5$-torsion group of tiny-jubjub over $\F_{13^3}$ is equal to the $5$-torsion group of tiny-jubjub over $\F_{13}$ itself. 
\end{example}

\begin{example} 
\label{example:secp256k1}
% https://www.sikoba.com/docs/SKOR_SV_Pairing_Based_Crypto.pdf
Let's look at the curve secp256k1. We know from example \ref{secp256k1} that the curve is of some prime order $r$. Because of this, the only torsion group to consider is the curve itself, so the curve group is the $r$-torsion. 

In order to find the full $r$-torsion of secp256k1, we need to compute the embedding degree $k$. And as we have seen in \ref{ex:pairings_on_secp256k1} it is at least not small. However, we know from Fermat's little theorem \ref{fermats-little-theorem} that a finite embedding degree must exist. It can be shown that it is given by the following 256-bit number:
$$
k = \scriptstyle 192986815395526992372618308347813175472927379845817397100860523586360249056 
$$
This means that the embedding degree is very large, which implies that the field extension $\F_{p^k}$ is very large too. To understand how big $\F_{p^k}$ is, recall that an element of $\F_{p^m}$ can be represented as a string $<x_0,\ldots,x_m>$ of $m$ elements, each containing a number from the prime field $\F_p$. Now, in the case of secp256k1, such a representation has $k$-many entries, each of them $256$ bits in size. So, without any optimizations, representing such an element would need $k\cdot 256$ bits, which is too much to be representable in the observable universe. It follows that it is not only infeasible to compute the full $r$-torsion group of secp256k1, but moreover to even write down single elements of that group in general. 
\end{example}

\paragraph{Pairing groups} As we have stated above, any full $r$-torsion group contains $r+1$ cyclic subgroups, two of which are of particular interest in pairing-based elliptic curve cryptography. To characterize these groups, we need to consider the so-called \term{Frobenius endomorphism} of an elliptic curve $E(\F)$ over some finite field $\F$ of characteristic $p$:
\begin{equation}\label{eq:frobenius-enomorphism}
\pi : E(\F) \to E(\F): \;\; 
\begin{array}{lcl}
(x,y)       &\mapsto & (x^p,y^p)\\
\Oinf &\mapsto & \Oinf
\end{array} 
\end{equation}
It can be shown that $\pi$ maps curve points to curve points. The first thing to note is that, in case  $\F$ is a prime field, the Frobenius endomorphism acts as the identity map, since $(x^p,y^p) = (x,y)$ on prime fields due to Fermat's little theorem \ref{fermats-little-theorem}. This means that the Frobenius map is more interesting on elliptic curves over prime field extensions.

With the Frobenius map at hand, we can characterize two important subgroups of the full $r$-torsion group $E[r]$ of an elliptic curve. The first subgroup is the group of elements from the full $r$-torsion group, on which the Frobenius map acts trivially. Since in pairing-based cryptography, this group is usually written as $\G_1$, assuming that the prime factor $r$ in the definition is implicitly given, we define $\G_1$ as follows:

\begin{equation}
\label{def:pairing_group_G1}
\G_1[r] := \{(x,y)\in E[r]\;|\; \pi(x,y) = (x,y)\;\}
\end{equation}

It can be shown that $\G_1$ is precisely the $r$-torsion group $E(\F_p)$ of the unextended elliptic curve defined over the prime field. There is another subgroup of the full $r$-torsion group that can be characterized by the Frobenius map and in the context of pairing-based cryptography, this subgroup is usually called $\G_2$. This group is defined as follows:

\begin{equation}
\label{def:pairing_group_G2}
\G_2[r]:= \{(x,y)\in E[r]\;|\; \pi(x,y) = [p](x,y)\;\}
\end{equation}

\begin{notation} If $E(\F)$ is an elliptic curve and $r$ is the largest prime factor of the curves order, we call $\G_1[r]$ and $G_2[r]$ \term{pairing groups}. If the prime factor $r$ is clear from the context, we sometimes simply write $\G_1$ and $\G_2$ to mean $\G_1[r]$ and $\G_2[r]$, respectively. 
\end{notation}

It should be noted that other definitions of $\G_2$ also exists in the literature. However, in the context of pairing-based cryptography, this is a common choise as it is particularly useful because we can define hash functions that map into $\G_2$, which is not possible for all subgroups of the full $r$-torsion.

\begin{example} Consider the curve $E_1(\F_5)$ from example \ref{E1F5} again. As we have seen, this curve has the embedding degree $k=2$, and a full $3$-torsion group is given as follows:
\begin{multline}
E_1[3] = \{\Oinf,(2,1),(2,4), (1,t), (1,4t), (2t + 1,t + 1),\\ (2t + 1, 4t + 4),
(3t + 1,t + 4), (3t + 1, 4t + 1) \}
\end{multline}

According to the general theory, $E_1[3]$ contains $4$ subgroups, and we can characterize the subgroups $\G_1$ and $\G_2$ using the Frobenius endomorphism. Unfortunately, at the time of writing, Sage does not have a predefined Frobenius endomorphism for elliptic curves, so we have to use the Frobenius endomorphism of the underlying field as a temporary workaround. Using our implementation of $E_1[3]$ in sage from example \ref{example:E1_full_torsion}, we compute $\G_1$ as follows:
\begin{sagecommandline}
sage: L_G1 = []
sage: for P in E1_3: 
....:     PiP = E1F5_2([a.frobenius() for a in P]) # pi(P)
....:     if P == PiP:
....:         L_G1.append(P)
sage: G1 = Set(L_G1)
sage: G1
\end{sagecommandline}
As expected, the group $\G_1=\{\Oinf, (2,4), (2,1)\}$ is identical to the $3$-torsion group of the (unextended) curve over the prime field $E_1(\F_5)$. 

In order to compute the group $\G_2$ for the curve $E_1(\F_5)$, we can use almost the same algorithm as we used for the computation of $\G_1$. Since $p=5$ we get the following:
\begin{sagecommandline}
sage: L_G2 = []
sage: for P in E1_3: 
....:     PiP = E1F5_2([a.frobenius() for a in P]) # pi(P)
....:     pP = 5*P # [5]P
....:     if pP == PiP:
....:         L_G2.append(P)
sage: G2 = Set(L_G2)
sage: G2
\end{sagecommandline}

Thus, we have computed the pairing group $\G_2$ of the full $3$-torsion group of curve $E_1(\F_5)$ as the set $\G_2 = \{\Oinf, (1,t), (1,4t)\}$. 
\end{example}

\begin{example}
\label{example:TJJ_pairing_groups}
Consider the tiny-jubjub curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}. In example \ref{ex:TJJ13-full-torsion} we computed its full $5$ torsion, which is a group that has $6$ subgroups. We compute $\G_1$ using Sage as follows:
\begin{sagecommandline}
sage: L_TJJ_G1 = []
sage: for P in TJJF13_4_5: 
....:     PiP = TJJF13_4([a.frobenius() for a in P]) # pi(P)
....:     if P == PiP:
....:         L_TJJ_G1.append(P)
sage: TJJ_G1 = Set(L_TJJ_G1)
sage: TJJ_G1
\end{sagecommandline}
We get $\G_1= \{\Oinf, (7,2), (8,8), (8,5), (7,11)\}$ and as expected, $\G_1$ is identical to the $5$-torsion group of the (unextended) curve over the prime field $TJJ_13$ as computed in example \ref{eq:TJJ13-logarithmic-order}.

In order to compute the group $\G_2$ for the tiny jubjub curve, we can use almost the same algorithm as we used for the computation of $\G_1$. Since $p=13$ we get the following:
\begin{sagecommandline}
sage: L_TJJ_G2 = []
sage: for P in TJJF13_4_5: 
....:     PiP = TJJF13_4([a.frobenius() for a in P]) # pi(P)
....:     pP = 13*P # [13]P
....:     if pP == PiP:	# pi(P) ==[13]P
....:         L_TJJ_G2.append(P)
sage: TJJ_G2 = Set(L_TJJ_G2)
sage: TJJ_G2
\end{sagecommandline}
$\G_2 = \{\Oinf, (9t^2 + 7,t^3 + 11t), (9t^2 + 7, 12t^3 + 2t), (4t^2 + 7,5t^3 + 10t),(4t^2 + 7,8t^3 + 3t)\}$
\end{example}

\begin{example}
\label{example:secp256k1_pairing_groups}
Consider Bitcoin's curve secp256k1 again. Since the group $\G_1$ is identical to the torsion group of the unextended curve, and since secp256k1 has prime order, we know that, in this case, $\G_1$ is identical to secp256k1 itself. However it is infeasible to compute elements from $\G_2$, since according to example \ref{example:secp256k1} we can not store avarage curve points from the extension curve $secp256k1(\F_{p^k})$ on any computer, let alone compute their images under the Frobenious map.
\end{example}

\paragraph{The Weil pairing} Recall the definition of a non-degenerate group pairing from \ref{pairing-map}. In this part, we consider a pairing function defined on
the subgroups $\G_1[r]$ and $\G_2[r]$ of the full $r$-torsion $E[r]$ of a short Weierstrass elliptic curve. To be more precise, let $E(\F_p)$ be an elliptic curve of embedding degree $k$ such that $r$ is a prime factor of its order. Then the \term{Weil pairing} is defined as the following bilinear, non-degenerate map:

\begin{equation}\label{eq:weil-pairing}
e(\cdot,\cdot) : \G_1[r] \times \G_2[r] \to \F^*_{p^k}\; ;\; 
(P,Q)\mapsto (-1)^r \cdot \frac{f_{r,P}(Q)}{f_{r,Q}(P)}
\end{equation} 

The extension field elements $f_{r,P}(Q), f_{r,Q}(P)\in \F_{p^k}$ in the definition of the Weil pairing are computed by \term{Miller's algorithm}:\final{check floating of algorithm}
\begin{algorithm}\caption{Miller's algorithm for short Weierstrass curves $y^2 = x^3 +ax +b$}
% https://www.math.u-bordeaux.fr/~damienrobert/csi2018/pairings.pdf
\begin{algorithmic}[0]
\Require $r>3$, $P \in E[r]$, $Q\in E[r]$ and
\State $b_0,\ldots, b_t\in \{0,1\}$ with $r= b_0\cdot 2^0 + b_1\cdot 2^1 + \ldots + b_t\cdot 2^t$ and $b_t=1$
\Procedure{Miller's Algorithm}{$P,Q$}
\If{$P = \Oinf$ or $Q = \Oinf$ or $P = Q$}
	\State \textbf{return} $f_{r,P}(Q) \gets (-1)^r$
\EndIf
\State $(x_T,y_T) \gets (x_P,y_P)$
\State $f_1\gets 1$
\State $f_2\gets 1$
\For{$j\gets t-1,\ldots, 0$}
	\State $m \gets \frac{3\cdot x_T^2+a}{2\cdot y_T}$	
    \State $f_1 \gets f_1^2\cdot (y_Q - y_T - m\cdot(x_Q-x_T))$
	\State $f_2 \gets f_2^2\cdot (x_Q + 2x_T -m^2)$
	\State $x_{2T} \gets m^2 - 2 x_T$
	\State $y_{2T} \gets -y_T - m\cdot (x_{2T}-x_T)$
	\State $(x_T,y_T)\gets (x_{2T},y_{2T})$ 
	\If{$b_j = 1$}
		\State $m \gets \frac{y_T -y_P}{x_T - x_P}$
		\State $f_1 \gets f_1\cdot (y_Q -y_T -m\cdot (x_Q - x_T))$
		\State $f_2 \gets f_2\cdot (x_Q + (x_P+x_T) - m^2)$
		\State $x_{T+P} \gets m^2 -x_T -x_P$
		\State $y_{T+P}\gets -y_T - m\cdot (x_{T+P}-x_T)$
		\State $(x_T,y_T)\gets (x_{T+P},y_{T+P})$
	\EndIf
\EndFor
\State $f_1 \gets f_1\cdot (x_Q - x_T)$
\State \textbf{return} $f_{r,P}(Q) \gets \frac{f_1}{f_2}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Understanding the details of how and why this algorithm works requires the concept of \term{divisors}, which is outside of the scope this book. The interested reader might look at XXX.\sme{add references} As we can see the algorithm is more efficient on prime numbers $r$, that have a low Hamming weight \ref{def:binary_representation_integer}.

We call an elliptic curve $E(\F_p)$ \term{pairing-friendly} if there is a prime factor of the groups order such that the Weil pairing is efficiently computable with respect to that prime factor. In real-world applications of pairing-friendly elliptic curves, the embedding degree is usually a small number like $2$, $4$, $6$ or $12$, and the number $r$ is the largest prime factor of the curve's order. 

\begin{example}Consider curve $E_1(\F_5)$ from example \ref{E1F5}. Since the only prime factor of the group's order is $3$, we cannot compute the Weil pairing on this group using our definition of Miller's algorithm. In fact, since $\G_1$ is of order $3$, executing the algorithm will lead to a ``division by zero''.
\end{example}

\begin{example} Consider the tiny-jubjub curve $\mathit{TJJ\_13}(\F_{13})$ from example \ref{TJJ13} and its associated pairing groups from example \ref{example:TJJ_pairing_groups}:
\begin{align*}
\G_1[5] & = \{\Oinf, (7,2), (8,8), (8,5), (7,11)\}\\
\G_2[5] & = \{\Oinf, (9t^2 + 7,t^3 + 11t), (9t^2 + 7, 12t^3 + 2t), 
(4t^2 + 7, 5t^3 + 10t), (4t^2 + 7, 8t^33 + 3t)\}
\end{align*}

Since we know from example \ref{ex:TJJ13-embedding-degree} that the embedding degree of $5$ id $4$, we can instantiate the general definition of the Weil pairing for this example as follows:
$$
e(\cdot,\cdot): \G_1[5] \times \G_2[5] \to \F_{13^4}
$$ 

The first if-statement in Miller's algorithm, implies that $e(\Oinf,Q)=1$ as well as $e(P,\Oinf)=1$ for all arguments $P\in\G_1[5]$ and $Q\in \G_2[5]$. In order to compute a non-trivial Weil pairing, we choose the argument $P=(7,2)\in \G_1$ and $Q=(9t^2 + 7, 12t^3 + 2t)\in\G_2$. Invoking sage we get the following computation of the Weil pairing:  
\begin{sagecommandline}
sage: F13 = GF(13)
sage: F13t.<t> = F13[]
sage: P_MOD_4 = F13t(t^4+2)
sage: F13_4.<t> = GF(13^4, name='t', modulus=P_MOD_4)
sage: TJJF13_4 = EllipticCurve(F13_4,[8,8])
sage: P=TJJF13_4([7,2])
sage: Q=TJJF13_4([9*t^2+7,12*t^3+2*t])
sage: P.weil_pairing(Q,5)
\end{sagecommandline}
\end{example}
\begin{example}
Consider Bitcoin's curve secp256k1 again. As we have seen in example \ref{example:secp256k1_pairing_groups}, it is infeasible to compute elements from the pairing group $\G_2$ and as we know from example \ref{example:secp256k1} it is moreover infeasible to do calculations in the extension field $\F_{p^k}$. It follows that the Weil pairing is not efficiently computable and that secp256k1 is not pairing friendly. 
\end{example}

% http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
% p. 396ff

\section{Hashing to Curves} Elliptic curve cryptography frequently requires the ability to hash data onto elliptic curves. If the order of the curve is not a prime number, hashing to prime number subgroups is also of importance. In the context of pairing-friendly curves, it is also sometimes necessary to hash specifically onto the group $\G_1$ or $\G_2$.

As we have seen in section \ref{sec:hashing-to-groups}\sme{check reference}, many general methods are known for hashing into groups in general, and finite cyclic groups in particular. As elliptic groups are cyclic, those methods can be utilized in this case, too. However, in what follows we want to describe some methods specific to elliptic curves that are frequently used in real-world applications. 

\paragraph{Try-and-increment hash functions}
One of the most straight-forward ways of hashing a bitstring onto an elliptic curve point in a  secure way is to use a cryptographic hash function together with one of the methods we described in section \ref{sec:hashing-to-groups}\sme{check reference} to hash to the modular arithmetics base field of the curve. Ideally, the hash function generates an image that is at least one bit longer than the bit representation of the base field modulus.

The image in the base field can then be interpreted as the $x$ coordinate of the curve point, and the two possible $y$ coordinates are derived from the curve equation, while one of the bits that exceeded the modulus determines which of the two $y$ coordinates to choose.

Such an approach would be deterministic and easy to implement, and it would conserve the cryptographic properties of the original hash function. However, not all $x$ coordinates generated in such a way will result in quadratic residues when inserted into the defining equation. It follows that not all field elements give rise to actual curve points. In fact,
% https://www.cs.umd.edu/users/gasarch/TOPICS/res/burgess.pdf
on a prime field, only half of the field elements are quadratic residues. Hence, assuming an even distribution of the hash values in the field, this method would fail to generate a curve point in about half of the attempts. 

One way to account for this problem is the so-called \term{try-and-increment} method. Its basic assumption is that, when hashing different values, the result will eventually lead to a valid curve point. 

Therefore, instead of simply hashing a string $s$ to the field, we hash the concatenation of $s$ with additional bytes to the field instead. In other words, we use a try-and-increment hash as described in \ref{alg_try_and_increment}\sme{check reference}. If the first try of hashing to the field does not result in a valid curve point, the counter is incremented, and the hashing is repeated again. This is done until a valid curve point is found.\final{check if the algorithm is floated properly}

\begin{algorithm}\caption{Hash-to-$E(\F_r)$}
\begin{algorithmic}[0]
\Require $r \in \Z$ with $r.nbits()=k$ and $s\in\{0,1\}^*$
\Require Curve equation $y^2 = x^3 + ax +b$ over $\F_r$
\Procedure{Try-and-Increment}{$r,k,s$}
\State $c \gets 0$
\Repeat
\State $s' \gets s||c\_bits()$
\State $z \gets H(s')_0\cdot 2^0 + H(s')_1\cdot 2^1 + \ldots + H(s')_{k}\cdot 2^{k}$
\State $x\gets z^3 + a\cdot z + b$
\State $c\gets c+1$
\Until{$z<r$ and $\Zmod{x^{\frac{r-1}{2}}}{r}=1$ }
\If {$H(s')_{k+1} == 0$}
\State $y \gets \sqrt{x}$ \#(root in $\F_r$)
\Else 
\State $y \gets r-\sqrt{x}$ \#(root in $\F_r$)
\EndIf
\State \textbf{return} $(x,y)$
\EndProcedure
\Ensure $(x,y)\in E(\F_r)$
\end{algorithmic}
\end{algorithm}

This method has a number of advantages: It is relatively easy to implement in code, and it maintains the cryptographic properties of the original hash function. However, it is not guaranteed to find a valid curve point, as there is a chance that all possible values in the chosen size of the counter will fail to generate a quadratic residue. Fortunately, it is possible to make the probability for this arbitrarily small by choosing large enough counters and relying on the (approximate) uniformity of the hash-to-field function. 

%One might think that another disadvantage of this method in the context of SNARKs is that it can not be implemented as a circuit effectively. This however, is not fully true, as a circuit/r1cs only needs to enforce the correctness of the computation. Hence for the circuit it is enough to check the hash of the string and the correct counter. It does not need to find that counter.

%Considering certain subgroups of the elliptic curve, the usefulness of this methods depends highly on the actual situation. For example if a hash to the $n$-torsion subgroup $\mathbb{G}_1$ is desired, there are two possibilities: 

If the curve is not of prime order, the result will be a general curve point that might not be in the ``large'' prime-order subgroup. In this case, a \term{cofactor clearing} step is then necessary to project the curve point onto the subgroup. This is done by scalar multiplication with the cofactor of prime order with respect to the curves order.

\begin{example} Consider the tiny-jubjub curve from example \ref{TJJ13}\sme{check reference}. We want to construct a try-and-increment hash function that hashes a binary string $s$ of arbitrary length onto the large prime-order subgroup of size $5$. 

Since the curve, as well as our targeted subgroup, is defined over the field $\F_{13}$, and the binary representation of $13$ is $13.bits()=1101$, we apply SHA256 from Sage's hashlib library on the concatenation $s||c$ for some binary counter string, and use the first $4$ bits of the image to try to hash into $\F_{13}$. In case we are able to hash to a value $z$ such that $z^3 +8\cdot z + 8$ is a quadratic residue in $\F_{13}$, we use the $5$-th bit to decide which of the two possible roots of $z^3 + 8\cdot z + 8$ we will choose as the $y$ coordinate. The result is a curve point different from the point at infinity. To project it to a point of $\G_1$, we multiply it with the cofactor $4$. If the result is still not the point at infinity, it is the result of the hash.

To make this concrete, let $s='10011001111010110100000111'$ be our binary string that we want to hash onto $\G_1$. We use a $4$-bit binary counter starting at zero, that is, we choose $c=0000$. Invoking Sage, we define the try-hash function as follows:
\begin{sagecommandline}
sage: import hashlib
sage: def try_hash(s,c):
....:     s_1 = s+c
....:     hasher = hashlib.sha256(s_1.encode('utf-8'))
....:     digest = hasher.hexdigest()
....:     d = Integer(digest,base=16)
....:     sign = d.str(2)[-5:-4]
....:     d = d.str(2)[-4:]
....:     z = Integer(d,base=2)
....:     return (z,sign)
sage: try_hash('10011001111010110100000111','0000')
\end{sagecommandline}

As we can see, our first attempt to hash into $\F_{13}$ was not successful, as $15$ is not a number in $\F_{13}$, so we increment the binary counter by $1$ and try again: 
\begin{sagecommandline}
sage: try_hash('10011001111010110100000111','0001')
\end{sagecommandline}

With this try, we found a hash into $\F_{13}$. However, this point is not guaranteed to define a curve point. To see that, we insert $z=3$ into the right side of the short Weierstrass equation of the tiny-jubjub curve, and compute $3^3 + 8*3 + 8 = 7$. However, $7$ is not a quadratic residue in $\F_{13}$, since $7^{\frac{13-1}{2}}=7^6=12=-1$. This means that $3$ is a not a suitable point, and we have to increment the counter two more times: 
\begin{sagecommandline}
sage: try_hash('10011001111010110100000111','0010')
sage: try_hash('10011001111010110100000111','0011')
\end{sagecommandline}
Since $6^3 + 8\cdot 6 + 8 = 12$, and we have $\sqrt{12}\in\{5, 8\}$, we finally found the valid $x$ coordinate $x=6$ for the curve point hash. Now, since the sign bit of this hash is $1$, we choose the larger root $y=8$ as the $y$ coordinate and get the following hash which is a valid curve point point on the tiny-jubjub curve:
$$
H('10011001111010110100000111') = (6,8)
$$

In order to project this onto the ``large'' prime-order subgroup, we have to do cofactor clearing, that is, we have to multiply the point with the cofactor $4$. We get the following:
$$
[4](6,8) = \Oinf
$$ 

This means that the hash value is still not right. We therefore have to increment the counter two more times again, until we finally find a correct hash to $\G_1$:
\begin{sagecommandline}
sage: try_hash('10011001111010110100000111','0100')
sage: try_hash('10011001111010110100000111','0101')
\end{sagecommandline}

Since $12^3 + 8\cdot 12 + 8 = 12$, and we have $\sqrt{12}\in\{5, 8\}$, we found another valid $x$ coordinate $x=12$ for the curve point hash. Since the sign bit of this hash is $0$, we choose the smaller root $y=5$ as the $y$ coordinate, and get the following hash, which is a valid curve point point on the tiny-jubjub curve:
$$
H('10011001111010110100000111') = (12,5)
$$
In order to project this onto the ``large'' prime-order subgroup we have to do cofactor clearing,\sme{again?} that is, we have to multiply the point with the cofactor $4$. We get the following:
$$
[4](12,5) = (8,5)
$$
So, hashing the binary string $'10011001111010110100000111'$ onto $\G_1$ gives the hash value $(8,5)$ as a result. 
\end{example}

\section{Constructing elliptic curves} Cryptographically secure elliptic curves like secp256k1 from example \ref{secp256k1}\sme{check reference} have been known for quite some time. Given the latest advancements of cryptography, however, it is often necessary to design and instantiate elliptic curves from scratch that satisfy certain very specific properties. 

For example, in the context of SNARK development, it was necessary to design a curve that can be efficiently implemented inside of a so-called \uterm{circuit} in order to enable primitives like elliptic curve \uterm{signature schemes} in a zero-knowledge proof. Such a curve is given by the Baby-jubjub curve in XXX\sme{add reference}, and we have paralleled its definition by introducing the tiny-jubjub curve from example \ref{TJJ13}\sme{check reference}. As we have seen, those curves are instances of so-called twisted Edwards curves, and as such have easy to implement addition laws that work without branching. However, we introduced the tiny-jubjub curve out of thin air, as we just gave the curve parameters without explaining how we came up with them.

Another requirement in the context of many so-called \term{pairing-based zero-knowledge proofing systems} is the existence of a suitable, pairing-friendly curve with a specified security level and a low embedding degree as defined in \ref{def:embedding-degree}\sme{check reference}. Famous examples are the BLS\_12 and the NMT curves.\sme{add references}

The major goal of this section is to explain the most important method of designing elliptic curves with predefined properties from scratch, called the \term{complex multiplication method}. We will apply this method in section XXX\sme{add reference} to synthesize a particular BLS\_6 curve, which is one of the most insecure curves, but it will serve as the main curve to build our pen-and-paper SNARKs on. As we will see, this curve has a ``large'' prime factor subgroup of order $13$, which implies that we can use our tiny-jubjub curve to implement certain elliptic curve cryptographic primitives in circuits over that BLS\_6 curve. 
 
Before we introduce the complex multiplication method, we have to explain a few properties of elliptic curves that are of key importance in understanding the complex multiplication method. 

\paragraph{The Trace of Frobenius} To understand the complex multiplication method of elliptic curves, we have to define the so-called \term{trace} of an elliptic curve first.

We know from XXX\sme{reference text to be written in Algebra} that elliptic curves over finite fields are products of cyclic groups of finite order. Therefore, an interesting question is whether it is possible to estimate the number of elements that this curve contains. Since an affine short Weierstrass curve consists of pairs $(x,y)$ of elements from a finite field $\F_q$ plus the point at infinity, and the field $\F_q$ contains $q$ elements, the number of curve points cannot be arbitrarily large, since it can contain at most $q^2+1$ many elements. 

There is however, a more precise estimation, usually called the \term{Hasse bound}. To understand it, let $E(\F_q)$ be an affine short Weierstrass curve over a finite field $\F_w$ of order $q$, and let $|E(\F_q)|$ be the order of the curve. Then there is an integer $t\in \Z$, called the \term{trace of Frobenius} of the curve, such that $|t| \leq 2\sqrt{q}$ and the following equation holds:
\begin{equation}\label{hasse-bound}
|E(\F)| = q +1 -t
\end{equation}

A positive trace, therefore, implies that the curve contains less points than the underlying field, whereas a negative trace means that the curve contains more points. However, the estimation $|t| \leq 2\sqrt{q}$ implies that the difference is not very large in either direction, and the number of elements in an elliptic curve is always approximately in the same order of magnitude as the size of the curve's base field.

\begin{example}\label{ex:E1F5-frobenius} Consider the elliptic curve $E_1(\F_5)$ from example \ref{E1F5}\sme{check reference}. We know that it contains $9$ curve points. Since the order of $\F_5$ is $5$, we compute the trace of $E_1(\F)$ to be $t=-3$, since the Hasse bound is given by the following equation:
$$
9 = 5 + 1 - (-3)
$$
Indeed, we have $|t| \leq 2\sqrt{q}$, since $\sqrt{5}> 2.23$ and 
$|-3|= 3 \leq 4.46 = 2\cdot 2.23< 2\cdot \sqrt{5}$.
\end{example}

\begin{example}\label{ex:TJJ13-frobenius} To compute the trace of the tiny-jubjub curve, recall from example \ref{ex:TJJ13-cofactor-clearing}\sme{check reference} that the order of $\mathit{TJJ\_13}$ is $20$. Since the order of $\F_{13}$ is $13$, we can therefore use the Hasse bound and compute the trace as $t=-6$:
\begin{equation}
20 = 13 + 1 - (-6)
\end{equation}

Again, we have $|t| \leq 2\sqrt{q}$, since $\sqrt{13}> 3.60$ and 
$|-6|= 6 \leq 7.20 = 2\cdot 3.60< 2\cdot \sqrt{13}$.
\end{example}

\begin{example}\label{ex:secp256k1-trace}To compute the trace of secp256k1, recall from example \ref{secp256k1}\sme{check reference} that this curve is defined over a prime field with $p$ elements, and that the order of that group is given by $r$:  
\begin{align*}
p &= \scriptstyle 115792089237316195423570985008687907853269984665640564039457584007908834671663\\
r &= \scriptstyle 115792089237316195423570985008687907852837564279074904382605163141518161494337
\end{align*}

Using the Hesse bound $r = p + 1 -t$, we therefore compute $t= p+1 -r$, which gives the trace of curve secp256k1 as follows:
$$
t = \scriptstyle 432420386565659656852420866390673177327
$$

As we can see, secp256k1 contains less elements than its underlying field. However,  the difference is tiny, since the order of secp256k1 is in the same order of magnitude as the order of the underlying field. Compared to $p$ and $r$, $t$ is tiny.

\begin{sagecommandline}
sage: p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
sage: r = 115792089237316195423570985008687907852837564279074904382605163141518161494337
sage: t = p + 1 -r
sage: t.nbits()
sage: abs(RR(t)) <= 2*sqrt(RR(p))
\end{sagecommandline}
\end{example} 

\paragraph{The $j$-invariant} As we have seen in XXX\sme{add reference}, two elliptic curves $E_1(\F)$ defined by $y^2 = x^3 + ax +b$ and $E_2(\F)$ defined by $y^2 + a'x + b'$ are strictly isomorphic if and only if there is a quadratic residue $d\in \F$ such that $a' = a d^2$ and $b' = b d^3$. 

There is, however, a more general way to classify elliptic curves over finite fields $\F_q$, based on the so-called \term{$j$-invariant} of an elliptic curve with $j(E(\F_q))\in\F_q$, as defined below:
\begin{equation}\label{eq:j-invariant1}
j(E(\F_q)) = \left(\Zmod{1728}{q}\right) \frac{4\cdot a^3}{4\cdot a^3+ (\Zmod{27}{q})\cdot b^2}
\end{equation}

A detailed description of the $j$-invariant is beyond the scope of this book. For our present purposes, it is sufficient to note that two elliptic curves $E_1(\F)$ and $E_2(\F')$ are isomorphic over the \uterm{algebraic closures} of $\F$ and $\F'$, if and only if $\overline{\F}=\overline{\F'}$ and $j(E_1)=j(E_2)$.

So, the $j$-invariant is an important tool to classify elliptic curves and it is needed in the complex multiplication method to decide on an actual curve instantiation that implements abstractly chosen properties.

\begin{example} Consider the elliptic curve $E_1(\F_5)$ from example \ref{E1F5}\sme{check reference}. We compute its $j$-invariant as follows:
\begin{align*}
j(E_1(\F_5)) &= \left(\Zmod{1728}{5}\right) \frac{4\cdot 1^3}{4\cdot 1^3+ (\Zmod{27}{5})\cdot 1^2}\\
             &= 3 \frac{4}{4+ 2}\\
             &= 3\cdot 4
             & = 2
\end{align*}
\end{example}
\begin{example} Consider the elliptic curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}\sme{check reference}. We compute its $j$-invariant as follows:
\begin{align*}
j(E_1(\F_5)) &= \left(\Zmod{1728}{13}\right) \frac{4\cdot 8^3}{4\cdot 8^3+ (\Zmod{27}{13})\cdot 8^2}\\
             &= 12\cdot \frac{4\cdot 5}{4\cdot 5+ 1\cdot 12}\\
             &= 12\cdot \frac{7}{7+ 12}\\
             &= 12\cdot 7\cdot 6^{-1}\\
             &= 12\cdot 7\cdot 11\\
             &0 1 
\end{align*}
\end{example}
\begin{example}Consider secp256k1 from example secp256k1\sme{check reference}. We compute its $j$-invariant using Sage: 
\begin{sagecommandline}
sage: p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
sage: F = GF(p)
sage: j = F(1728)*((F(4)*F(0)^3)/(F(4)*F(0)^3+F(27)*F(7)^2))
sage: j == F(0)
\end{sagecommandline}
\end{example} 
\paragraph{The Complex Multiplication Method}\label{complex-multiplication-method}
As we have seen in the previous sections, elliptic curves have various defining properties, like their order, their prime factors, the embedding degree, or the cardinality (number of elements) of the base field. The \term{complex multiplication} (CM) method provides a practical way of constructing elliptic curves with pre-defined restrictions on the order and the base field.

% the detailed method is here https://arxiv.org/pdf/1207.6983.pdf
% http://users.uoa.gr/~kontogar/files/ElisavetDaras.pdf
% https://hal.inria.fr/inria-00075302/PDF/RR-1256.pdf
% https://www.ams.org/journals/mcom/2007-76-260/S0025-5718-07-01980-1/S0025-5718-07-01980-1.pdf
% https://graui.de/code/elliptic2/ //draw curves
% https://hal.inria.fr/inria-00075302/PDF/RR-1256.pdf proposition 2.1

The method usually starts by choosing a base field $\F_{q}$ of the curve $E(\F_q)$ we want to construct such that $q = p^m$ for some prime number $p$, and  `` $m\in \N$ with $m\geq 1$. We assume $p>3$ to simplify things in what follows. 

Next, the trace of Frobenius $t\in \Z$ of the curve is chosen such that $p$ and $t$ are coprime, that is, $gcd(p,t)=0$ holds true. The choice of $t$ also defines the curve's order $r$, since $r=p+1-t$ by the Hasse bound (equation \ref{hasse-bound})\sme{check reference}, so choosing $t$ will define the large order subgroup as well as all small cofactors. $r$ has to be defined in such a way that the elliptic curve meets the security requirements of the application it is designed for. 

Note that the choice of $p$ and $t$ also determines the embedding degree $k$ of any prime-order subgroup of the curve, since $k$ is defined as the smallest number such that the prime order $n$ divides the number $q^k-1$.

\begin{equation}\label{eq:D-criteria}
\begin{split}
D<0\\
\Zmod{D}{4}=0 \text{ or } \Zmod{D}{4}=1\\
4q  = t^2 + |D|v^2 
\end{split}
\end{equation}

In order for the complex multiplication method to work, neither $q$ nor $t$ can be arbitrary, but must be chosen in such a way that two additional integers $D\in \Z$ and $v\in \Z$ exist and the following conditions hold:


If such numbers exist, we call $D$ the \term{CM-discriminant}, and we know that we can construct a curve $E(\F_q)$ over a finite field $\F_q$ such that the order of the curve is $|E(\F_q)|= q+1-t$. 

It is the content of the complex multiplication method to actually construct such a curve, that is finding the parameters $a$ and $b$ from $\F_q$ in the defining Weiertraß equation such that the curve has the desired order $r$. 

Finding solutions to equation \ref{hasse-bound}\sme{check reference},= can be achieved in different ways, but we will forego the fine detail here. In general, it can be said that there are well-known constraints for elliptic curve families (e.g. the BLS (ECT) families) that provides families of solutions. In what follows, we will look at one type curve in the BLS-family, which gives an entire range of solutions.\sme{disambiguate}\smelong{Are we looking at a subtype of BLS or is BLS the specific type we're referring to?}

Assuming that the proper parameters $q$, $t$, $D$ and $v$ are found, we have to compute the so-called \term{Hilbert class polynomial} $H_D\in \Z[x]$ of the CM-discriminant $D$, which is a polynomial with integer coefficients. To do so, we first have to compute the following set:
\begin{multline*}
ICG(D)=\{(A,B,C)\;|\; A,B,C\in\Z, D = B^2-4AC, gcd(A,B,C)=1, \\
|B|\leq A \leq \sqrt{\frac{|D|}{3}}, A\leq C, 
\text{ if } B< 0 \text{ then } |B| < A < C\}
\end{multline*} 
One way to compute this set is to first compute the integer $A_{max}= Floor(\sqrt{\frac{|D|}{3}})$, then loop through all the integers $A$ in the range $[0,\ldots,A_{max}]$, as well as through all the integers $B$ in the range $[-A_{max},\ldots,A_{max}]$, then see if there is an integer $C$ that satisfies $D = B^2-4AC$ and the rest of the requirements in XXX\sme{add reference}.

To compute the Hilbert class polynomial, the so-called \term{$j$-function} (or $j$-invariant) is needed, which is a complex function defined on the upper half $\mathbb{H}$ of the complex plane $\mathbb{C}$, usually written as follows:\smelong{is this the same as equation {eq:j-invariant1 No they just sound very similar. But they are very different}?}\sme{unify terminology}
\begin{equation}\label{eq:j-invariant2}
j: \mathbb{H} \to \mathbb{C}
\end{equation}

Roughly speaking, what this means is that the $j$-functions takes complex numbers 
$(x +i\cdot y)$ with a positive imaginary part $y>0$ as inputs and returns a complex number $j(x+i\cdot y)$ as a result.

For the purposes of this book, it is not important to understand the $j$-function in detail, and we can use Sage to compute it in a similar way that we would use Sage to compute any other well-known function. It should be noted, however, that the computation of the $j$-function in Sage is sometimes prone to precision errors. For example, the $j$-function has a root in $\frac{-1+i\sqrt{3}}{2}$, which Sage only approximates. Therefore, when using Sage to compute the $j$-function, we need to take precision loss into account and possibly round to the nearest integer.

\begin{sagecommandline}
sage: z = ComplexField(100)(0,1)
sage: z # (0+1i)
sage: elliptic_j(z)
sage: # j-function only defined for positive imaginary arguments
sage: z = ComplexField(100)(1,-1)
sage: try:
....:     elliptic_j(z)
....: except PariError:
....:     pass
sage: # root at (-1+i sqrt(3))/2
sage: z = ComplexField(100)(-1,sqrt(3))/2
sage: elliptic_j(z)
sage: elliptic_j(z).imag().round()
sage: elliptic_j(z).real().round()
\end{sagecommandline}

With a way to compute the $j$-function and the precomputed set $ICG(D)$ at hand, we can now compute the Hilbert class polynomial as follows:
\begin{equation}
H_D(x) = \Pi_{(A,B,C)\in ICG(D)} \left(x - j\left(\frac{-B + \sqrt{D}}{2A}\right)\right)
\end{equation}

In other words, we loop over all elements $(A,B,C)$ from the set $ICG(D)$ and compute the $j$-function at the point $\frac{-B + \sqrt{D}}{2A}$, where $D$ is the CM-discriminant that we chose in a previous step. The result defines a factor of the Hilbert class polynomial and all factors are multiplied together.

It can be shown that the Hilbert class polynomial is an integer polynomial, but actual computations need high-precision arithmetics to avoid approximation errors that usually occur in computer approximations of the $j$-function (as shown above). So, in case the calculated Hilbert class polynomial does not have integer coefficients, we need to round the result to the nearest integer. Given that the precision we used was high enough, the result will be correct.

In the next step, we use the Hilbert class polynomial $H_D\in \Z[x]$, and project it to a polynomial $H_{D,q}\in\F_q[x]$ with coefficients in the base field $\F_q$ as chosen in the first step. We do this by simply computing the new coefficients as the old coefficients modulus $p$, that is, if $H_D(x)= a_mx^m +a_{m-1}x^{m-1}+\ldots + a_1 x + a_0$, we compute the $q$-modulus of each coefficient
$\tilde{a}_j = \Zmod{a_j}{p}$, which defines the \term{projected Hilbert class polynomial} as follows:
$$
H_{D,p}(x)=\tilde{a}_mx^m +\tilde{a}_{m-1}x^{m-1}+\ldots + \tilde{a}_1 x + \tilde{a}_0
$$
We then search for roots of $H_{D,p}$, since every root $j_0$ of $H_{D,p}$ defines a family of elliptic curves over $\F_q$, which all have a $j$-invariant \ref{eq:j-invariant1} or \ref{eq:j-invariant2}\sme{check reference} equal to $j_0$. We can pick any root, since all of them will lead to proper curves eventually.

However, some of the curves with the correct $j$-invariant might have an order different from the one we initially decided on. Therefore, we need a way to decide on a curve with the correct order. 

To compute such a curve, we have to distinguish a few different cases based on our choice of the root $j_0$ and of the CM-discriminant $D$. If $j_0\neq 0$ or $j_0\neq \Zmod{1728}{q}$, we compute $c_1=\frac{j_0}{(\Zmod{1728}{q}) -j_0}$, then we chose some arbitrary quadratic non-residue $c_2\in \F_q$, and some arbitrary cubic non-residue $c_3\in \F_q$. 

The following table is guaranteed to define a curve with the correct order $r= q+1 -t$ for the trace of Frobenius $t$ we initially decided on:\sme{actually make this a table?}
\begin{definition}\label{def:curve-order-frobenius}
\begin{itemize}
\item Case $j_0 \neq 0 $ and $j_0\neq \Zmod{1728}{q}$. A curve with the correct order is defined by one of the following equations:
\begin{equation}
y^2 = x^3 + 3c_1x + 2c_1 \text{\;\; or \;\; } y^2 = x^3 + 3c_1c_2^2x + 2c_1c_2^3
\end{equation}
\item Case $j_0 = 0 $ and $D\neq -3$. A curve with the correct order is defined by one of the following equations:
\begin{equation}
y^2 = x^3 + 1 \text{\;\; or \;\; } y^2 = x^3 + c_2^3
\end{equation}
\item Case $j_0 = 0 $ and $D= -3$. A curve with the correct order is defined by one of the following equations:
\begin{align*}
y^2 = x^3 +1 & \text{\;\; or \;\; } y^2 = x^3 + c_2^3 \text{ \;\; or}\\  
y^2 = x^3 + c_3^2 & \text{\;\; or \;\; } y^2 = c_3^2 c_2^3 \text{\;\; or}\\
y^2 = x^3 + c_3^{-2} & \text{\;\; or \;\; }  y^2 = x^3 + c_3^{-2}c_2^3 
\end{align*}
\item Case $j_0 = \Zmod{1728}{q} $ and $D\neq -4$. A curve with the correct order is defined by one of the following equations:
\begin{equation}
y^2 = x^3 + x \text{\;\; or \;\; } y^2 = x^3 + c_2^2x
\end{equation}
\item Case $j_0 = \Zmod{1728}{q} $ and $D= -4$. A curve with the correct order is defined by one of the following equations:
\begin{align*}
y^2 = x^3 +x & \text{\;\; or \;\; } y^2 = x^3 + c_2x \text{ \;\; or}\\  
y^2 = x^3 + c_2^2x & \text{\;\; or \;\; } y^2 = x^3 + c_2^3x
\end{align*}
\end{itemize} 
\end{definition}
To decide the proper defining short Weierstrass equation, we therefore have to compute the order of any of the potential curves above, and then choose the one that fits our initial requirements. Since it can be shown that the Hilbert class polynomials for the CM-discriminants $D=-3$ and $D=-4$ are given by  $H_{-3,q}(x)=x$ and $H_{-4,q}= x-(\Zmod{1728}{q})$ (EXERCISE), the previous cases are exhaustive.\sme{exercise still to be written?}

To summarize, using the complex multiplication method, it is possible to synthesize elliptic curves with predefined order over predefined base fields from scratch. However, the curves that are constructed this way are just some representatives of a larger class of curves, all of which have the same order. Therefore, in real-world applications, it is sometimes more advantageous to choose a different representative from that class. To do so recall from XXX\sme{add reference} that any curve defined by the short Weierstrass equation $y^2 = x^3 + ax b$ is isomorphic to a curve of the form $y^2 = x^3 + ad^2 x + bd^3$ for some quadratic residue $d\in \F_q$. 

In order to find a suitable representative (e.g. with small parameters $a$ and $b$) in the last step, the curve designer might choose a quadratic residue $d$ such that the transformed curve has the properties they wanted.

\begin{example} Consider curve $E_1(\F_5)$ from example \ref{E1F5}\sme{check reference}. We want to use the complex multiplication method to derive that curve from scratch. Since $E_1(\F_5)$ is a curve of order $r=9$ over the prime field of order $q=5$, we know from example \ref{ex:E1F5-frobenius}\sme{check reference} that its trace of Frobenius is $t=-3$, which also implies that $q$ and $|t|$ are coprime. 

We then have to find parameters $D,v\in\Z$ such that the criteria in \ref{eq:D-criteria} hold. We get the following:
\begin{align*}
4q & = t^2+ |D|v^2 & \Rightarrow \\
20 & = (-3)^2 + |D|v^2 & \Leftrightarrow \\
11 & = |D|v^2
\end{align*}
Now, since $11$ is a prime number, the only solution is $|D|=11$ and $v=1$ here. With $D=-11$ and  the Euclidean division of $-11$ by $4$ being $-11 = -3\cdot 4 +1$, we have $\Zmod{-11}{4}=1$, which shows that $D=-11$ is a proper choice.

In the next step, we have to compute the Hilbert class polynomial $H_{-11}$. To do so, we first have to find the set $ICG(D)$. To compute that set, observe that, since $\sqrt{\frac{|D|}{3}}\approx 1.915<2$, we know from $A\leq \sqrt{\frac{|D|}{3}}$ and $A\in\Z$ that $A$ must be either $0$ or $1$. 

For $A=0$, we know $B=0$ from the constraint $|B|\leq A$. However, in this case, there could be no $C$ satisfying $-11= B^2 -4AC$. So we try $A=1$ and deduce $B\in\{-1,0,1\}$ from the constraint $|B|\leq A$. The case $B=-1$ can be excluded, since then $B<0$ has to imply $|B|<A$. The case $B=0$ can also be excluded, as there cannot be an integer $C$ with $-11 = -4C$, since $11$ is a prime number. 

This leaves the case $B=1$, and we compute $C=3$ from the equation $-11 = 1^2 -4C$, which gives the solution $(A,B,C)=(1,1,3)$:
$$
ICG(D)=\{(1,1,3)\}
$$

With the set $ICG(D)$ at hand, we can compute the Hilbert class polynomial of $D=-11$. To do so, we have to insert the term $\frac{-1+\sqrt{-11}}{2\cdot1}$ into the $j$-function. To do so, first observe that $\sqrt{-11}=i\sqrt{11}$, where $i$ is the imaginary unit, defined by $i^2=-1$. Using this, we can invoke Sage to compute the $j$-invariant and get the following:
$$
H_{-11}(x) = x - j\left(\frac{-1+i\sqrt{11}}{2}\right) = x + 32768
$$

As we can see, in this particular case, the Hilbert class polynomial is a linear function with a single integer coefficient. In the next step, we have to project it onto a polynomial from $\F_5[x]$ by computing the modular $5$ remainder of the coefficients $1$ and $32768$. We get $\Zmod{32768}{5}=3$, from which it follows that the projected Hilbert class polynomial is considered a polynomial from $\F_5[x]$:
$$
H_{-11,5}(x)=x+3
$$ 
 As we can see, the only root of this polynomial is $j=2$, since $H_{-11,5}(2)=2+3=0$. We therefore have a situation with $j\neq 0$ and $j\neq 1728$, which tells us that we have to compute the parameter $c_1$ in modular $5$ arithmetics:
$$
c_1=\frac{2}{1728-2}
$$
 Since $\Zmod{1728}{5}=3$, we get $c_1=2$. 
 
 Next, we have to check if the curve $E(\F_5)$ defined by the short Weierstrass equation  $y^2 = x^3 + 3\cdot 2 x + 2\cdot 2$ has the correct order. We invoke Sage, and find that the order is indeed $9$, so it is a curve with the required parameters. Thus, we have successfully constructed the curve with the desired properties.

Note, however, that in real-world applications, it might be useful to choose parameters $a$ and $b$ that have certain properties, e.g. to be a small as possible. As we know from XXX\sme{add reference}, choosing any quadratic residue $d\in \F_5$ gives a curve of the same order defined by $y^2 = x^2 + a k^2 x + bk^3$. Since $4$ is a quadratic residue in $\F_4$, we can transform the curve defined by 
$y^2 = x^3 +x+4$ into the curve $y^2 = x^3 + 4^2 + 4\cdot 4^3$ which gives the following:
$$
y^2 = x^3 + x +1
$$

This is the curve $E_1(\F_5)$ that we used extensively throughout this book. Thus, using the complex multiplication method, we were able to derive a curve with specific properties from scratch.
\end{example}

\begin{example} Consider the tiny-jubjub curve $\mathit{TJJ\_13}$ from example \ref{TJJ13}\sme{check reference}. We want to use the complex multiplication method to derive that curve from scratch. Since $\mathit{TJJ\_13}$ is a curve of order $r=20$ over the prime field of order $q=13$, we know from example \ref{ex:TJJ13-frobenius}\sme{check reference} that its trace of Frobenius is $t=-6$, which also implies that $q$ and $|t|$ are coprime. 

We then have to find parameters $D,v\in\Z$ such that \ref{eq:D-criteria} holds. We get the following:
\begin{align*}
4q & = t^2+ |D|v^2 & \Rightarrow \\
4\cdot 13 & = (-6)^2+ |D|v^2 & \Rightarrow \\
52 & = 36 + |D|v^2 & \Leftrightarrow \\
16 & = |D|v^2
\end{align*}

This equation has two solutions for $(D,v)$, namely $(-4,\pm 2)$ and $(-16,\pm 1)$. Looking at the first solution, we know that  $D=-4$ implies $j=1728$, and the constructed curve is defined by a short Weierstrass equation \ref{def_short_weierstrass_curve}\sme{check reference} that has a vanishing parameter $b=0$. We can therefore conclude that choosing $D=-4$ will not help us reconstructing $\mathit{TJJ\_13}$. It will produce curves with order $20$, just not the one we are looking for.

So we choose the second solution $D=-16$. In the next step, we have to compute the Hilbert class polynomial $H_{-16}$. To do so, we first have to find the set $ICG(D)$. To compute that set, observe that since $\sqrt{\frac{|-16|}{3}}\approx 2.31<3$, we know from $A\leq \sqrt{\frac{|-16|}{3}}$ and $A\in\Z$ that $A$ must be in the range $0..2$. So we loop through all possible values of $A$ and through all possible values of $B$ under the constraints $|B|\leq A$, and if $B<0$ then $|B|<A$.
Then we compute potential $C$'s from $-16 = B^2 -4AC$. We get the following two solutions for $ICG(D)$:
% sage has precomputed Hilbert class polynomials 
% https://doc.sagemath.org/html/en/reference/databases/sage/databases/db_class_polynomials.html
we get
$$
ICG(D)=\{(1,0,4),(2,0,2)\}
$$
With the set $ICG(D)$ at hand, we can compute the Hilbert class polynomial of $D=-16$. We can invoke Sage to compute the $j$-invariant and get the following:
\begin{align*}
H_{-16}(x) &= \left(x - j\left(\frac{i\sqrt{16}}{2}\right)\right)
 \left(x - j\left(\frac{i\sqrt{16}}{4}\right)\right) \\
           &= (x- 287496)(x-1728)
\end{align*}

As we can see, in this particular case, the Hilbert class polynomial is a quadratic function with two integer coefficients. In the next step, we have to project it onto a polynomial from $\F_5[x]$ by computing the modular $5$ remainder of the coefficients $1$, $287496$ and $1728$. We get $\Zmod{287496}{13}=1$ and $\Zmod{1728}{13}=2$, which means that the projected Hilbert class polynomial is as follows:
$$
H_{-11,5}(x)=(x-1)(x-12)= (x+12)(x+1)
$$ 
This is considered a polynomial from $\F_5[x]$. Thus, we have two roots, namely $j=1$ and $j=12$. We already know that $j=12$ is the wrong root to construct the tiny-jubjub curve, since $\Zmod{1728}{13}=2$, and that case is not compatible with a curve with $b\neq 0$. So we choose $j=1$.

Another way to decide the proper root is to compute the $j$-invariant of the tiny-jubjub curve. We get the following:
\begin{align*}
j(\mathit{TJJ\_13}) & = 12\frac{4\cdot 8^3}{4\cdot 8^3+ 1\cdot 8^2}\\
                    & = 12\frac{4\cdot 5}{4\cdot 5+ 12}\\
                    & = 12\frac{7}{7+ 12}\\
                    & = 12\frac{7}{7+ 12}\\
                    & = 1
\end{align*}

This is equal to the root $j=1$ of the Hilbert class polynomial $H_{-16,13}$ as expected. We therefore have a situation with $j\neq 0$ and $j\neq 1728$, which tells us that we have to compute the parameter $c_1$ in modular $5$ arithmetics:
$$
c_1=\frac{1}{12-1} = 6
$$
Since $\Zmod{1728}{13}=12$, we get $c_1=6$. Then we have to check if the curve $E(\F_5)$ defined by the short Weierstrass  equation $y^2 = x^3 + 3\cdot 6 x + 2\cdot 6$, which is equivalent to
$
y^2 = x^3 + 5x +12
$, has the correct order. We invoke Sage and find that the order is $8$, which implies that the trace of this curve is $6$, not $-6$ as required. So we have to consider the second possibility, and choose some quadratic non-residue $c_2\in\F_{13}$. We choose $c_2=5$ and compute the short Weierstrass equation $y^2 = x^3 + 5 c_2^2 + 12 c_2^3$ as follows:
$$
y^2 = x^3 + 8 x + 5
$$
We invoke Sage and find that the order is $20$, which is indeed the correct one. As we know from XXX\sme{add reference}, choosing any quadratic residue $d\in \F_5$ gives a curve of the same order defined by $y^2 = x^2 + a d^2 x + bd^3$. Since $12$ is a quadratic residue in $\F_{13}$, we can transform the curve defined by 
$y^2 = x^3 +8x+5$ into the curve $y^2 = x^3 + 12^2\cdot 8 + 5\cdot 12^3$ which gives the following:
$$
y^2 = x^3 + 8x +8
$$

This is the tiny-jubjub curve that we used extensively throughout this book. So using the complex multiplication method, we were able to derive a curve with specific properties from scratch.
\end{example}

\begin{example} To consider a real-world example, we want to use the complex multiplication method in combination with Sage to compute secp256k1 from scratch. So based on example \ref{secp256k1}\sme{check reference}, we decided to compute an elliptic curve over a prime field $\F_p$ of order $r$ for the following security parameters:
\begin{align*}
p &= \scriptstyle 115792089237316195423570985008687907853269984665640564039457584007908834671663\\
r &= \scriptstyle 115792089237316195423570985008687907852837564279074904382605163141518161494337
\end{align*}
According to example \ref{ex:secp256k1-trace}\sme{check reference}, this gives the following trace of Frobenius:
$$t = \scriptstyle 432420386565659656852420866390673177327$$ 

We also decided that we want a curve of the form $y^2 = x^3 + b$, that is, we want the parameter $a$ to be zero. This implies that the $j$-invariant of our curve must be zero.

In a first step, we have to find a CM-discriminant $D$ and some integer $v$ such that the equation 
$
4p = t^2 +|D|v^2
$
is satisfied. Since we aim for a vanishing $j$-invariant, the first thing to try is $D=-3$. In this case, we can compute $v^2 = (4p -t^2)$, and if $v^2$ happens to be an integer that has a square root $v$, we are done. Invoking Sage we compute as follows:
\begin{sagecommandline}
sage: D = -3
sage: p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
sage: r = 115792089237316195423570985008687907852837564279074904382605163141518161494337
sage: t = p+1-r
sage: v_sqr = (4*p - t^2)/abs(D)
sage: v_sqr.is_integer()
sage: v = sqrt(v_sqr)
sage: v.is_integer()
sage: 4*p == t^2 + abs(D)*v^2
sage: v
\end{sagecommandline}
The pair $(D,v)=(-3, 303414439467246543595250775667605759171)$ does indeed solve the equation, which tells us that there is a curve of order $r$ over a prime field of order $p$, defined by a short Weierstrass equation $y^2 = x^3 + b$ for some $b\in \F_p$. Now we need to compute $b$.

For $D=-3$, we already know that the associated Hilbert class polynomial is given by $H_{-3}(x)=x$, which gives the projected Hilbert class polynomial as 
$H_{-3,p}=x$ and the $j$-invariant of our curve is guaranteed to be $j=0$. Now, looking at \ref{def:curve-order-frobenius}\sme{check reference}, we see that there are $6$ possible cases to construct a curve with the correct order $r$. In order to construct the curves in question, we have to choose some arbitrary quadratic and cubic non-residue. So we loop through $\F_p$ to find them, invoking Sage:

\begin{sagecommandline}
sage: F = GF(p)
sage: for c2 in F:
....:     try: # quadratic residue
....:         _ = c2.nth_root(2)
....:     except ValueError: # quadratic non-residue
....:         break
sage: c2
sage: for c3 in F:
....:     try:
....:         _ = c3.nth_root(3)
....:     except ValueError:
....:         break
sage: c3
\end{sagecommandline}

We found the quadratic non-residue $c_2=3$ and the cubic non-residue $c_3=2$. Using those numbers, we check the six cases against the the expected order $r$ of the curve we want to synthesize:
\begin{sagecommandline}
sage: C1 = EllipticCurve(F,[0,1])
sage: C1.order() == r
sage: C2 = EllipticCurve(F,[0,c2^3])
sage: C2.order() == r
sage: C3 = EllipticCurve(F,[0,c3^2])
sage: C3.order() == r
sage: C4 = EllipticCurve(F,[0,c3^2*c2^3])
sage: C4.order() == r
sage: C5 = EllipticCurve(F,[0,c3^(-2)])
sage: C5.order() == r
sage: C6 = EllipticCurve(F,[0,c3^(-2)*c2^3])
sage: C6.order() == r
\end{sagecommandline}

As expected, we found an elliptic curve of the correct order $r$ over a prime field of size $p$. In principle. we are done, as we have found a curve with the same basic properties as secp256k1. However, the curve is defined by the following equation, which uses a very large parameter $b_1$, and so it might perform too slowly in certain algorithms.
$$
\scriptstyle y^2 = x^3 + 86844066927987146567678238756515930889952488499230423029593188005931626003754
$$
 It is also not very elegant to be written down by hand.\sme{what does this mean? Maybe just delete it}  It might therefore be advantageous to find an isomorphic curve with the smallest possible parameter $b_2$. In order to find such a $b_2$, we have to choose a quadratic residue $d$ such that $b_2 = b_1\cdot d^3$ is as small as possible. To do so, we rewrite the last equation into the following form:
$$
d = \sqrt[3]{\frac{b_2}{b_1}}
$$ 

Then we invoke Sage to loop through values $b_2\in \F_p$ until it finds some number such that the quotient $\frac{b_2}{b_1}$ has a cube root $d$ and this cube root itself is a quadratic residue. 
\begin{sagecommandline}
sage: b1=86844066927987146567678238756515930889952488499230423029593188005931626003754
sage: for b2 in F:
....:     try:
....:         d = (b2/b1).nth_root(3)
....:         try:
....:             _ = d.nth_root(2)
....:             if d != 0:
....:                 break
....:         except ValueError:
....:             pass
....:     except ValueError:
....:         pass
sage: b2
\end{sagecommandline}
Indeed, the smallest possible value is $b_2=7$ and the defining short Weierstrass equation of a curve over $\F_p$ with prime order $r$ is 
$
y^2 = x^3 + 7
$,
which we might call secp256k1. As we have just seen, the complex multiplication method is powerful enough to derive cryptographically secure curves like secp256k1 from scratch.
\end{example}
%\section{twists}
%I think this has to wait for Volume 2, due to timing constraints...

\paragraph{The $BLS6\_6$ pen-and-paper curve}\label{BLS6}

% https://arxiv.org/pdf/1207.6983.pdf
% construction 6.6 in https://eprint.iacr.org/2006/372.pdf
In this paragraph, we summarize our understanding of elliptic curves to derive our main pen-and-paper example for the rest of the book. To do so, we want to use the complex multiplication method to derive a pairing-friendly elliptic curve that has similar properties to curves that are used in actual cryptographic protocols. However, we design the curve specifically to be useful in pen-and-paper examples, which mostly means that the curve should contain only a few points so that we are able to derive exhaustive addition and pairing tables.

A well-understood family of pairing-friendly curves is the the group of BLS curves \smelong{(STUFF ABOUT THE HISTORY AND THE NAMING CONVENTION)}\sme{write up this part}, which are derived in [XXX\sme{add reference}]. BLS curves are particularly useful in our case if the embedding degree $k$ satisfies $\kongru{k}{6}{0}$. Of course, the smallest embedding degree $k$ that satisfies this congruency is $k=6$ and we therefore aim for a BLS6 curve as our main pen-and-paper example. 

To apply the complex multiplication method from page \pageref{complex-multiplication-method} ff.\sme{check reference}, recall that this method starts with a definition of the base field $\F_{p^m}$, as well as the trace of Frobenius $t$ and the order of the curve. If the order $p^m+1-t$ is not a prime number, then the order $r$ of the largest prime factor group needs to be controlled. 

In the case of BLS\_6 curves, the parameter $m$ is chosen to be $1$, which means that the curves are defined over prime fields. All relevant parameters $p$, $t$ and $r$ are then themselves parameterized by the following three polynomials:
\begin{equation}
\begin{split}
r(x) &= \Phi_6(x)\\
t(x) &= x+1\\
q(x) &= \frac{1}{3}(x-1)^2(x^{2}-x+1) +x
\end{split}
\end{equation}

In the equations above, $\Phi_6$ is the $6$-th \uterm{cyclotomic polynomial} and  $x\in\N$ is a parameter that the designer has to choose in such a way that the evaluation of $p$, $t$ and $r$ at the point $x$ gives integers that have the proper size to meet the security requirements of the curve that they want to design. It is then guaranteed that the complex multiplication method can be used in combination with those parameters to define an elliptic curve with CM-discriminant $D=-3$, embedding degree $k=6$, and curve equation $y^2 = x^3 +b$ for some $b\in\F_p$. 

For example, if the curve should target the $128$-bit security level, due to the \uterm{Pholaard-rho attack} (TODO)\sme{todo} the parameter $r$ should be prime number of at least $256$ bits.

In order to design the smallest BLS\_6 curve, we therefore have to find a parameter $x$ such that $r(x)$, $t(x)$ and $q(x)$ are the smallest natural numbers that satisfy $q(x)>3$ and $r(x)>3$.\footnote{The smallest BLS curve will also be the most insecure BLS curve. However, since our goal with this curve is ease of pen-and-paper computation rather than security, it fits the purposes of this book.}

We therefore initiate the design process of our $BLS6$ curve by looking up the $6$-th cyclotomic polynomial, which is $\Phi_{6}=x^2-x+1$, and then insert small values for $x$ into the defining polynomials $r,t,q$. We get the following results:
$$
\begin{array}{lcr}
x=1 & (r(x),t(x),q(x)) & (1,2,1)\\
x=2 & (r(x),t(x),q(x)) & (3,3,3)\\
x=3 & (r(x),t(x),q(x)) & (7,4,\frac{37}{3})\\
x=4 & (r(x),t(x),q(x)) & (13,5,43)\\
\end{array}
$$
Since $q(1)=1$ is not a prime number, the first $x$ that gives a proper curve is $x=2$. However, such a curve would be defined over a base field of characteristic $3$, and \smelong{we would rather like to avoid that}.\sme{why? Because in this book elliptic curves are only defined for fields of chracteristic > 3 } We therefore find $x=4$, which defines a curve over the prime field of characteristic $43$ that has a trace of Frobenius $t=5$ and a larger order prime group of size $r=13$. 

Since the prime field $\F_{43}$ has $43$ elements and $43$'s binary representation is $43_2= 101011$, which consists of $6$ digits, the name of our pen-and-paper curve should be $BLS6\_6$, since its is common to name a BLS curve by its embedding degree and the bit-length of the modulus in the base field. We call $BLS6\_6$ the \term{moon-math-curve}.

Based on \ref{hasse-bound}\sme{check reference}, we know that the Hasse bound implies that $BLS6\_6$ will contain exactly $39$ elements. Since the prime factorization of $39$ is $39=3\cdot 13$, we have a ``large'' prime factor group of size $13$, as expected, and a small cofactor group of size $3$. Fortunately, a subgroup of order $13$ is well suited for our purposes, as $13$ elements can be easily handled in the associated addition, scalar multiplication and pairing tables in a pen-and-paper style. 

We can check that the embedding degree is indeed $6$ as expected, since $k = 6$ is the smallest number $k$ such that $r=13$ divides $43^k-1$. 
\begin{sagecommandline}
sage: for k in range(1,42): # Fermat's little theorem
....:     if (43^k-1)%13 == 0:
....:         break
sage: k
\end{sagecommandline}

In order to compute the defining equation $y^2=x^3 + ax + b$ of BLS6-6, we use the complex multiplication method as described in \ref{complex-multiplication-method}\sme{check reference}. The goal is to find $a,b\in\F_{43}$ representations that are particularly \smelong{nice to work with}\sme{what does this mean?}. The authors of XXX\sme{add reference} showed that the CM-discriminant of every BLS curve is $D=-3$ and, indeed, the following equation has the four solutions $(D,v)\in\{(-3,-7),(-3,7),(-49,-1),(-49,1)\}$ if $D$ is required to be negative, as expected: 

\begin{align*}
4p & = t^2 + |D|v^2 & \Rightarrow \\ 
4\cdot 43 & = 5^2 + |D|v^2 & \Rightarrow \\ 
172 & = 25 + |D| v^2 & \Leftrightarrow \\ 
49 & = |D| v^2
\end{align*}

This means that $D=-3$ is indeed a proper CM-discriminant, and we can deduce that the parameter $a$ has to be $0$, and that the Hilbert class polynomial is given by
$
H_{-3,43}(x) = x
$.

This implies that the $j$-invariant of $BLS6\_6$ is given by $j(BLS6\_6)=0$. We therefore have to look at case XXX\sme{add reference} in table \ref{def:curve-order-frobenius}\sme{check reference} to derive a parameter $b$. To decide the proper case for $j_0=0$ and $D=-3$, we therefore have to choose some arbitrary quadratic non-residue $c_2$ and cubic non-residue $c_3$ in $\F_{43}$. We choose $c_2 =5$ and $c_3=36$. We check these with Sage:
\begin{sagecommandline}
sage: F43 = GF(43)
sage: c2 = F43(5)
....: try: # quadratic residue
....:     c2.nth_root(2)
....: except ValueError: # quadratic non-residue
....:     c2
sage: c3 =F43(36)
....: try:
....:     c3.nth_root(3)
....: except ValueError:
....:     c3
\end{sagecommandline} 

Using those numbers we check the six possible cases from \ref{def:curve-order-frobenius}\sme{check reference} against the the expected order $39$ of the curve we want to synthesize:

\begin{sagecommandline}
sage: BLS61 = EllipticCurve(F43,[0,1])
sage: BLS61.order() == 39
sage: BLS62 = EllipticCurve(F43,[0,c2^3])
sage: BLS62.order() == 39
sage: BLS63 = EllipticCurve(F43,[0,c3^2])
sage: BLS63.order() == 39
sage: BLS64 = EllipticCurve(F43,[0,c3^2*c2^3])
sage: BLS64.order() == 39
sage: BLS65 = EllipticCurve(F43,[0,c3^(-2)])
sage: BLS65.order() == 39
sage: BLS66 = EllipticCurve(F43,[0,c3^(-2)*c2^3])
sage: BLS66.order() == 39
sage: BLS6 = BLS63 # our BLS6 curve in the book
\end{sagecommandline}
As expected, we found an elliptic curve of the correct order $39$ over a prime field of size $43$, defined by the following equation:

\begin{equation}
BLS6\_6 := \{(x,y)\;|\; y^2 = x^3 + 6 \text{ for all } x,y \in \F_{43}\}
\end{equation}

There are other choices for $b$, such as $b=10$ or $b=23$, but all these curves are isomorphic, and hence represent the same curve in a different way. Since BLS6-6 only contains $39$ points ,it is possible to give a visual impression of the curve:

\begin{sagesilent}
BLS63p = BLS63.plot()
\end{sagesilent}
\begin{center} 
\sageplot[scale=.5]{BLS63p} 
\end{center}

As we can see, our curve has some desirable properties: it does not contain self-inverse points, that is, points with $y=0$. It follows that the addition law can be optimized, since the branch for those cases can be eliminated. 

Summarizing the previous procedure, we have used the method of Barreto, Lynn and Scott\sme{add reference} to construct a pairing-friendly elliptic curve of embedding degree $6$. However, in order to do elliptic curve cryptography on this curve, note that, since the order of $BLS6\_6$ is $39$, its group of rational points is not a finite cyclic group of prime order. We therefore have to find a suitable subgroup as our main target. Since $39=13\cdot 3$, we know that the curve must contain a ``large'' prime-order group of size $13$ and a small cofactor group of order $3$. 

The following step is to construct this group. One way to do so is to find a generator. We can achieve this by choosing an arbitrary element of the group that is not the point at infinity, and then multiply that point with the cofactor of the group's order. If the result is not the point at infinity, the result will be a generator. If it is the point at infinity we have to choose a different element. 

In order to find a generator for the large order subgroup of size $13$, we first notice that the cofactor of $13$ is $3$, since $39=3\cdot 13$. We then need to construct an arbitrary element from $BLS6\_6$. To do so in a pen-and-paper style, we can choose some $arbitrary x\in\F_{43}$ and see if there is some solution $y\in\F_{43}$ that satisfies the defining short Weierstrass equation $y^2 = x^3 + 6$. We choose $x=9$, and check that $y=2$ is a proper solution:
\begin{align*}
y^2 & = x^3 + 6 & \Rightarrow \\
2^2 & = 9^3 + 6 & \Leftrightarrow \\
4 & = 4
\end{align*}   

This implies that $P=(9,2)$ is therefore a point on $BLS6\_6$. To see if we can project this point onto a generator of the large order prime group $BLS6\_6[13]$, we have to multiply $P$ with the cofactor, that is, we have to compute $[3](9,2)$. After some computation \smelong{(EXERCISE)}\sme{add exercise} we get $[3](9,2) = (13,15)$. Since this is not the point at infinity, we know that $(13,15)$ must be a generator of $BLS6\_6[13]$. The generator $g_{BLS6\_6[13]}$, which we will use in pairing computations in the remainder of this book, is given as follows:

\begin{equation}\label{gBLS6-6-13}
g_{BLS6\_6[13]} = (13,15)
\end{equation}

Since $g_{BLS6\_6[13]}$ is a generator, we can use it to construct the subgoup $BLS6\_6[13]$ by repeatedly adding the generator to itself. Using Sage, we get the following:
\begin{sagecommandline}
sage: P = BLS6(9,2)
sage: Q = 3*P
sage: Q.xy()
sage: BLS6_13 = []
sage: for x in range(0,13): # cyclic of order 13
....:     P = x*Q
....:     BLS6_13.append(P)
\end{sagecommandline}
Repeatedly adding a generator to itself, as we just did, will generate small groups in logarithmic order with respect to the generator as, explained on page \pageref{generators} ff\sme{check reference}. We therefore get the following description of the large prime-order subgroup of $BLS6\_6$:

\begin{multline}
BLS6\_6[13]=\\
\{(13,15) \rightarrow (33,34) \rightarrow  (38,15) \rightarrow  (35,28) \rightarrow (26,34) \rightarrow  (27,34) \rightarrow  \\ 
(27,9)  \rightarrow  (26,9) \rightarrow  (35,15) \rightarrow  (38,28) \rightarrow  (33,9) \rightarrow (13,28) \rightarrow  \mathcal{O}\}$$
\end{multline}
Having a logarithmic description of this group is tremendously helpful in pen-and-paper computations. To see that, observe that we know fromXXX\sme{add reference} that there is an exponential map from the scalar field $\F_{13}$ to $BLS6\_6[13]$ with respect to our generator, which generates the group in logarithmic order:
$$
[\cdot]_{(13,15)}: \F_{13} \to BLS6\_6[13]\;;\; x \mapsto [x](13,15)
$$
 So, for example, we have $[1]_{(13,15)}= (13,15)$, $[7]_{(13,15)}= (27,9)$ and $[0]_{(13,15)}= \mathcal{O}$ and so on. The relevant point here is that we can use this representation to do computations in $BLS6\_6[13]$ efficiently in our head using XXX\sme{add reference}, as in the following example:
\begin{align*}
(27,34)\oplus (33,9)  & = [6](13,15)\oplus [11](13,15)\\
                      & = [6+11](13,15)\\
                      & = [4](13,15)\\
                      & = (35,28)\\
\end{align*}
So XXX\sme{add reference} is really all we need to do computations in $BLS6\_6[13]$ in this book efficiently. However, out of convenience, the following picture lists the entire addition table of that group, as it might be useful in pen-and-paper computations:
\begingroup
    \fontsize{7pt}{7pt}\selectfont
$$
\begin{array}{c|ccccccccccccc}
\oplus & \mathcal{O}  & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28)\\
\hline
\\
\mathcal{O} & \mathcal{O}  & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28)\\
\\
(13,15) & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O}\\
\\
(33,34) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15)\\
\\
(38,15) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34)\\
\\
(35,28) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15)\\
\\
(26,34) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28)\\
\\
(27,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34)\\
\\
(27,9) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34)\\
\\
(26,9) & (26,9) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9)\\
\\
(35,15) & (35,15) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9)\\
\\
(38,28) & (38,28) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15)\\
\\
(33,9) & (33,9) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28)\\
\\
(13,28) & (13,28) & \mathcal{O} & (13,15) & (33,34) & (38,15) & (35,28) & (26,34) & (27,34) & (27,9) & (26,9) & (35,15) & (38,28) & (33,9)\\
\end{array}
$$
\endgroup
%To see how the small prime-order group of $BLS6\_6$ looks like we can apply the same approach but for the cofactor $13$ instead (EXERCISE). We get 
%$$BLS6\_6[3]=\{\mathcal{O},(0,7),(0,36)\}$$
%Now that we ha

Now that we have constructed a ``large'' cyclic prime-order subgroup of $BLS6\_6$ suitable for many pen-and-paper computations in elliptic curve cryptography, we have to look at how to do pairings in this context. We know that $BLS6\_6$ is a pairing-friendly curve by design, since it has a small embedding degree $k=6$. It is therefore possible to compute Weil pairings efficiently. However, in order to do so, we have to decide the groups $\G_1$ and $\G_2$ as explained in exercise \ref{ex:G1G2-subgroups}\sme{check reference}. 

Since $BLS6\_6$ has two non-trivial subgroups, it would be possible to use any of them as the $n$-torsion group. However, in cryptography, the only secure choice is to use the large prime-order subgroup, which in our case is $BLS6\_6[13]$. We therefore decide to consider the $13$-torsion and define ${G}_1[13]$ as the first argument for the Weil pairing function:

\begin{multline*}
\mathbb{G}_1[13]=\{(13,15) \rightarrow (33,34) \rightarrow  (38,15) \rightarrow  (35,28) \rightarrow (26,34) \rightarrow  (27,34) \rightarrow  \\ 
(27,9)  \rightarrow  (26,9) \rightarrow  (35,15) \rightarrow  (38,28) \rightarrow  (33,9) \rightarrow (13,28) \rightarrow  \mathcal{O}\}$$
\end{multline*}

In order to construct the domain for the second argument, we need to construct $\G_2[13]$, which, according to the general theory, should be defined by those elements $P$ of the full $13$-torsion group $BLS6\_6[13]$ that are mapped to $43\cdot P$ under the Frobenius endomorphism (equation \ref{eq:frobenius-enomorphism})\sme{check reference}. 

To compute $\G_2[13]$, we therefore have to find the full $13$-torsion group first. To do so, we use the technique from XXX, which tells us that the full $13$-torsion can be found in the curve extension over the extension field $\F_{43^6}$, since the embedding degree of $BLS6\_6$ is $6$:

\begin{equation}
BLS6\_6 := \{(x,y)\;|\; y^2 = x^3 + 6 \text{ for all } x,y \in \F_{43^6}\}
\end{equation}

Thus, we have to construct $\F_{43^6}$, a field that contains $6321363049$ elements. In order to do so, we use the procedure of XXX\sme{add reference} and start by choosing a non-reducible polynomial of degree $6$ from the ring of polynomials $\F_{43}[t]$. We choose $p(t) = t^6+6$. Using Sage, we get the following:
\begin{sagecommandline}
sage: F43 = GF(43)
sage: F43t.<t> = F43[]
sage: p = F43t(t^6+6)
sage: p.is_irreducible()
sage: F43_6.<v> = GF(43^6, name='v', modulus=p)
\end{sagecommandline}

Recall from XXX\sme{add reference} that elements $x\in\F_{43^6}$ can be seen as polynomials $a_0+a_1v + a_2v^2+\ldots + a_5 v^5$ with the usual addition of polynomials and multiplication modulo $t^6+6$. 

In order to compute $\G_2[13]$, we first have to extend $BLS6\_6$ to $\F_{43^6}$, that is, we keep the defining equation, but expand the domain from $\F_{43}$ to $\F_{43^6}$. After that, we have to find at least one element $P$ from that curve that is not the point at infinity, is in the full $13$-torsion and  satisfies the identity $\pi(P) = [43]P$. We can then use this element as our generator of $\G_2[13]$ and construct all other elements by repeatedly adding the generator to itself.

Since $BLS6(\F_{43^6})$ contains $6321251664$ elements, it's not a good strategy to simply loop through all elements. Fortunately, Sage has a way to loop through elements from the torsion group directly:

\begin{sagecommandline}
sage: BLS6 = EllipticCurve (F43_6,[0 ,6]) # curve extension
sage: INF = BLS6(0) # point at infinity
sage: for P in INF.division_points(13): # full 13-torsion
....: # PI(P) == [q]P
....:     if P.order() == 13: # exclude point at infinity
....:         PiP = BLS6([a.frobenius() for a in P])
....:         qP = 43*P
....:         if PiP == qP:
....:             break
sage: P.xy()
\end{sagecommandline}

We found an element from the full $13$-torsion that is in the Eigenspace of the Eigenvalue $43$, which implies that it is an element of $\G_2[13]$. As $\G_2[13]$ is cyclic of prime order, this element must be a generator:
\begin{equation}
g_{\G_2[13]} = (7v^2, 16v^3)
\end{equation}

We can use this generator to compute $\G_2$ in logarithmic order with respect to $g_{\G_[13]}$. Using Sage we get the following:
\begin{sagecommandline}
sage: Q = BLS6(7*v^2,16*v^3)
sage: BLS6_13_2 = []
sage: for x in range(0,13):
....:     P = x*Q
....:     BLS6_13_2.append(P)
\end{sagecommandline}
\begin{multline*}
\mathbb{G}_2=\{
(7v^2, 16v^3) \to
(10v^2, 28v^3)\to
(42v^2, 16v^3)\to
(37v^2, 27v^3)\to\\
(16v^2, 28v^3)\to
(17v^2, 28v^3)\to
(17v^2, 15v^3)\to
(16v^2, 15v^3)\to\\
(37v^2, 16v^3)\to
(42v^2, 27v^3)\to
(10v^2, 15v^3)\to
(7v^2, 27v^3)\to
\mathcal{O}\}
\end{multline*}

Again, having a logarithmic description of $\G_2[13]$ is tremendously helpful in pen-and-paper computations, as it reduces complicated computation in the extended curves to modular $13$ arithmetics, as in the following example:
\begin{align*}
(17v^2,28v^3)\oplus (10v^2,15v^2)  & = [6](7v^2,16v^3)\oplus [11](7v^2,16v^3)\\
                      & = [6+11](7v^2,16v^3)\\
                      & = [4](7v^2,16v^3)\\
                      & = (37v^2,27v^3)\\
\end{align*}

So XXX\sme{add reference} is really all we need to do computations in $\G_2[13]$ in this book efficiently. 

To summarize the previous steps, we have found two subgroups, $\G_1[13]$ and $\G_2[13]$ suitable to do Weil pairings on $BLS6\_6$ as explained in \ref{eq:weil-pairing}\sme{check reference}. Using the logarithmic order XXX\sme{add reference} of $\G_1[13]$, the logarithmic order XXX\sme{add reference} of $\G_2[13]$ and the bilinearity in \ref{eq:bilinearityBLS6}, we can do Weil pairings on $BLS6\_6$ in a pen-and-paper style:

\begin{equation}\label{eq:bilinearityBLS6}
e([k_1]g_{BLS6\_6[13]},[k_2]g_{\G_2[13]}) = 
e(g_{BLS6\_6[13]},g_{\G_2[13]})^{k_1\cdot k_2}
\end{equation}

Observe that the Weil pairing between our two generators is given by the following identity:
\begin{equation}\label{BLS6-weil-pairing}
e(g_{BLS6\_6[13]},g_{\G_2[13]})= 5v^5 + 16v^4 + 16v^3 + 15v^2 + 3v + 41
\end{equation}

\begin{sagecommandline}
sage: g1 = BLS6([13,15])
sage: g2 = BLS6([7*v^2, 16*v^3])
sage: g1.weil_pairing(g2,13)
\end{sagecommandline}

\paragraph{Hashing to pairing groups}
We give various constructions to hash into $\mathbb{G}_1$ and $\mathbb{G}_2$. 

We start with hashing to the scalar field... \smelong{TO APPEAR}\sme{finish writing this up}

None of these techniques work for hashing into $\mathbb{G}_2$. We therefore implement Pederson's Hash for BLS6. 

We start with $\mathbb{G}_1$. Our goal is to define an $12$-bit bounded hash function:
$$
H_{1}: \{0,1\}^{12} \to \mathbb{G}_1 
$$
Since $12= 3\cdot 4$ we ``randomly'' select $4$ uniformly distributed generators $\{(38, 15), (35,28),\\ (27, 34), (38, 28)\}$ from $\mathbb{G}_1$ and use the pseudo-random function from XXX\sme{add reference}. 
Therefore, we have to choose a set of $4$ randomly generated invertible elements from $\F_{13}$ for every generator. We choose the following:
$$
\begin{array}{lcl}
(38,15) &:& \{2,7,5,9\}\\
(35,28) &:& \{11,4,7,7\}\\
(27,34) &:& \{5,3,7,12\}\\
(38,28) &:& \{6,5,1,8\}
\end{array}
$$
Our hash function is then computed as follows:

\begin{multline*}
H_1(x_{11},x_1,\ldots, x_{0})=
[2\cdot 7^{x_{11}}\cdot 5^{x_{10}}\cdot 9^{x_9}](38,15)+
[11\cdot 4^{x_8}\cdot 7^{x_7}\cdot 7^{x_6}](35,28)+\\
[5\cdot 3^{x_5}\cdot 7^{x_4}\cdot 12^{x_3}](27,34) +
[6\cdot 5^{x_2}\cdot 1^{x_{1}}\cdot 8^{x_{0}}](38,28)
\end{multline*}

Note that $a^x=1$ when $x=0$. Hence, those terms can be omitted in the computation. 
In particular, the hash of the $12$-bit zero string is given as follows:\sme{correct computations}

\begin{multline*}\smelong{WRONG-ORDERING-REDO}\\
H_1(0)= [2](38,15)+[11](35,28)+[5](27,34)+[6](38,28)= \\
(27,34)+(26,34)+(35,28)+(26,9)= (33,9) + (13,28) = (38,28)
\end{multline*}

The hash of $011010101100$ is given as follows:\sme{fill in missing parts}
\begin{multline*}
H_1(011010101100)=\smelong{WRONG-ORDERING-REDO}\\
[2\cdot 7^{0}\cdot 5^{1}\cdot 9^{1}](38,15)+
[11\cdot 4^{0}\cdot 7^{1}\cdot 7^{0}](35,28)+
[5\cdot 3^{1}\cdot 7^{0}\cdot 12^{1}](27,34) +
[6\cdot 5^{1}\cdot 1^{0}\cdot 8^{0}](38,28)=\\
[2\cdot 5\cdot 9](38,15)+
[11\cdot 7](35,28)+
[5\cdot 3\cdot 12](27,34) +
[6\cdot 5](38,28)=\\
[12](38,15)+
[12](35,28)+
[11](27,34) +
[4](38,28)=\\ 
\smelong{TO APPEAR}
\end{multline*}
We can use the same technique to define a $12$-bit bounded hash function in $\mathbb{G}_2$:  
$$
H_{2}: \{0,1\}^{12} \to \mathbb{G}_2 
$$
Again, we ``randomly'' select $4$ uniformly distributed generators $\{(7v^2 , 16v^3 ), (42v^2 , 16v^3 ), \\(17v^2 , 15v^3 ), (10v^2 , 15v^3 )\}$ from $\mathbb{G}_2$, and use the pseudo-random function from XXX\sme{add reference}. Therefore, we have to choose a set of $4$ randomly generated invertible elements from $\F_{13}$ for every generator:
$$
\begin{array}{lcl}
(7v^2 , 16v^3 ) &:& \{8,4,5,7\}\\
(42v^2 , 16v^3 ) &:& \{12,1,3,8\}\\
(17v^2 , 15v^3 ) &:& \{2,3,9,11\}\\
(10v^2 , 15v^3 ) &:& \{3,6,9,10\}
\end{array}
$$
Our hash function is then computed like this:
\begin{multline*}
H_1(x_{11},x_{10},\ldots, x_{0})=
[8\cdot 4^{x_{11}}\cdot 5^{x_{10}}\cdot 7^{x_9}](7v^2 , 16v^3)+
[12\cdot 1^{x_8}\cdot 3^{x_7}\cdot 8^{x_6}](42v^2 , 16v^3 )+\\
[2\cdot 3^{x_5}\cdot 9^{x_4}\cdot 11^{x_3}](17v^2 , 15v^3 ) +
[3\cdot 6^{x_2}\cdot 9^{x_{1}}\cdot 10^{x_{0}}](10v^2 , 15v^3 )
\end{multline*}

We extend this to a hash function that maps unbounded bitstrings to $\mathbb{G}_2$ by precomposing with an actual hash function like $MD5$, and feed the first 12 bits of its outcome into our previously defined hash function, with $TinyMD5_{\mathbb{G}_2}(s)= H_2(MD5(s)_0,\ldots MD5(s)_{11})$:
$$
TinyMD5_{\mathbb{G}_2}: \{0,1\}^* \to \mathbb{G}_2
$$
For example, since 
$MD5("")=\\ 0xd41d8cd98f00b204e9800998ecf8427e$, and the binary representation of the hexadecimal number $0x27e$ is $001001111110$, we compute $TinyMD5_{\mathbb{G}_2}$ of the empty string as follows:
$$TinyMD5_{\mathbb{G}_2}("")= H_2(MD5(s)_{11},\ldots MD5(s)_{0}) = H_2(001001111110)=$$\sme{check equation}





% FOR THE SECOND VERSION OF THE BOOK
%\subsection{MNT4 MNT6 Cycles}
% https://eprint.iacr.org/2006/372.pdf theorem 5.2
%\begin{theorem}
%Let $q$ be a prime and $E/\F_q$ be an ordinary elliptic curve such that $r= |E(Fq)|$ is a prime greater than $3$.  
%\begin{itemize}
%\item $E$ has embedding  degree $k= 4$ if and only if there  exists $x\in \mathbb{Z}$ such  that $t=-x$ or $t=x+1$, and $q=x^2+x+1$.\item $E$ has  embedding  degree $k= 6$ if and only if there  exists $x\in \Z$ such that $t= 1\pm 2x$ and $q=4x^2+1$.
%\item There is an elliptic curve $E/\F_q$ with embedding degree $6$, discriminant $D$, and $|E(Fq)| = r$ if and only if there is an elliptic curve $E'/\F_r$ with embedding degree $4$, discriminant $D$, and $|E'(\F_r)| =q$.
%\end{itemize}
%\end{theorem}

%We can use this theorem to find an MNT6-MNT4 cycle over very small prime fields with characteristics $>3$: 
%\paragraph{MNT4}
%For our MNT4 curve, we can choose $x=2$. Then $q=7$ and if we choose $t= x+1 $ then $r = q + 1 - t = 7 + 1 -3 = 5$. Therefore our MNT4 curve is a curve $y^2=x^3+ax+b$ defined over $\F_7$ that consists of $5$ points. 

%To construct the actual curve we could use the complex multiplication method again, but since the parameters $a$ and $b$ are from $\F_7$ there are only $48$ possibilities so we simply loop through all possible $a$'s and $b$'s and count the curve points until we find a curve that has $5$ rational points. We get
%$$
%y^2 = x^3 + 4x + 1
%$$
%defined over $\F_7$, with scalar field $\F_5$. Since $7= 2^2+2+1$, we know from theorem XXX that this curve has embedding degree $4$ and hence qualifies as a pen-and-paper pairing-friendly elliptic curve. Since the curve's order is a prime and therefore has no non trivial factors, it has no non trivial subgroups. The curve has the following set of elements
%$$MNT4=\{(0,1)\to (0,6)\to (4,2)\to (4,5) \to \mathcal{O}\}$$ 
%\begin{sagecommandline}
%sage: F7 = GF(7)
%sage: MNT4 = EllipticCurve (F7,[4 ,1])
%sage: [P.xy() for P in MNT4.points() if P.order() > 1]
%\end{sagecommandline}
%The multiplication table is
%\begingroup
%    \fontsize{10pt}{10pt}\selectfont
%$$
%\begin{array}{c|ccccc}
%\cdot & \mathcal{O} & (0,1) & (4,5) & (4,2) & (0,6)\\
%\hline
%\\
%\mathcal{O} & \mathcal{O} & (0,1) & (4,5) & (4,2) & (0,6)\\
%\\
%(0,1) & (0,1) & (4,5) & (4,2) & (0,6) & \mathcal{O}\\
%\\
%(4,5) & (4,5) & (4,2) & (0,6) & \mathcal{O} & (0,1)\\
%\\
%(4,2) & (4,2) & (0,6) & \mathcal{O} & (0,1) & (4,5)\\
%\\
%(0,6) & (0,6) & \mathcal{O} & (0,1) & (4,5) & (4,2)\\
%\end{array}
%$$
%\endgroup
%In what follows we choose our generator to be $g_{MNT4}=(0,1)$.

%In what follows we want to compute type 2 pairings on our MNT4 curve. We therefore need to extract the subgroup $\mathbb{G}_1$ as well as $\mathbb{G}_2$ from the full $5$-torsion group. Since the order of MNT4 is a prime number, we already know from XXX\sme{add reference} that $\mathbb{G}_1$ is given by  $$\mathbb{G}_1=\{(0,1)\to (0,6)\to (4,2)\to (4,5) \to \mathcal{O}\}$$ 

%In type 2 pairings, the group $\mathbb{G}_2$ is defined by those elements $P$ of the full $5$-torsion group that are mapped to $7\cdot P$ under the Frobenius endomorphism XXX\sme{add reference}. Since $MNT4/\F_{7^4}$ only contains $2475$ elements, we can  loop through all elements, to find the full $5$-torsion group and extract all elements from $\mathbb{G}_2$:
%\begin{sagecommandline}
%sage: F7t.<t> = F7[]
%sage: F7_4.<u> = GF(7^4, name='u', modulus=t^4+t+1) # embedding degree is 4
%sage: MNT4 = EllipticCurve (F7_4,[4 ,1])
%sage: INF = MNT4(0) # point at infinity
%sage: for P in INF.division_points(5): # PI(P) == [q]P
%....:     if P.order() == 5: # exclude point at infinity
%....:         PiP = MNT4([a.frobenius() for a in P])
%....:         qP = 7*P
%....:         if PiP == qP:
%....:             print(P.xy())
%\end{sagecommandline}

%Choose $g_2=(2u^3 + 5u^2 + 4u + 2, 2u^3 + 3u + 5)$ as generator of $\mathbb{G}_2$, we get
%\begin{multline*}
%\mathbb{G}_2=\{ 
%(2u^3 + 5u^2 + 4u + 2, 2u^3 + 3u + 5) \to
%(5u^3 + 2u^2 + 3u + 6, 2u^2 + 3u) \to \\
%(5u^3 + 2u^2 + 3u + 6, 5u^2 + 4u) \to
%(2u^3 + 5u^2 + 4u + 2, 5u^3 + 4u + 2)\to
%\mathcal{O}\}
%\end{multline*}
%e.g. $[3]g_2= (5u^3 + 2u^2 + 3u + 6, 5u^2 + 4u)$.

%Having those groups we can do pairings. We choose the Weil pairing and invoke Sagemath. For example the Weil pairing between our two generators is
%$$
%e(g_1,g_2)= 5u^3 + 2u^2 + 6u
%$$
%\begin{sagecommandline}
%sage: g1 = MNT4([0,1])
%sage: g2 = MNT4(2*u^3 + 5*u^2 + 4*u + 2, 2*u^3 + 3*u + 5)
%sage: g1.weil_pairing(g2,5)
%\end{sagecommandline}
%The full pairing table can the be written as
%\begingroup
%    \fontsize{10pt}{10pt}\selectfont
    
% generate the table entries as:
% sage: for i in range(5):
% ....:     for j in range(5):
% ....:         p = (i*g1).weil_pairing((j*g2),5)
% ....:         print('e([',i,']g1,[',j,']g2=',p)         
    
    
%$$
%\begin{array}{c|lllll}
%e(\cdot,\cdot)    & \mathcal{O} & g_1            & [2]g_1         & [3]g_1         %& [4]g_1\\
%\hline
%\\
%      \mathcal{O} & 1           & 1              & 1              & 1              %& 1\\
%\\
%              g_2 & 1           & 5u^3+2u^2+6u   & 6u^3+5u^2+6    & 2u^3+u^2+2u+3  %& u^3+6u^2+6u+4\\
%\\
%\left[2\right]g_2 & 1           & 6u^3+5u^2+6    & u^3+6u^2+6u+4  & 5u^3+2u^2+6u   %& 2u^3+u^2+2u+3\\
%\\
%\left[3\right]g_2 & 1           & 2u^3+u^2+2u+3  & 5u^3+2u^2+6u   & u^3+6u^2+6u+4  & 6u^3+5u^2+6\\
%\\
%\left[4\right]g_2 & 1           & u^3+6u^2+6u+4  & 2u^3+u^2+2u+3  & 6u^3+5u^2+6    & 5u^3+2u^2+6u\\
%\end{array}
%$$
%\endgroup

%\paragraph{MNT6}
%For our MNT6 curve, we can choose $x=1$. Then $q=5$ and if we choose $t= 1 + 2x $ then $r= q + 1 - t = 5 + 1 + 1 = 7$. Therefore our MNT6 curve is a curve $y^2=x^3+ax+b$ defined over $\F_5$ that consists of $7$ points. 

%To construct the actual curve we could use the complex multiplication method again, but since the parameters $a$ and $b$ are from $\F_5$ there are only $24$ possibilities, we simply loop through all possible $a$'s and $b$'s and count the curve points until we find a curve that has $7$ rational points. We get
%$$
%y^2 = x^3 + 2x + 1
%$$
%defined over $\F_5$. Since $5= 4\cdot 1 + 1$, we know from theorem XXX that this curve has embedding degree $6$ and hence qualifies as a pen-and-paper pairing-friendly elliptic curve. 

%The curve has the following set of elements
%$$MNT6=\{(1,2)\to (3,3)\to (0,1)\to (0,4)\to (3,2)\to (1,3)\to \mathcal{O}\}$$
%The multiplication table is
%\begingroup
%    \fontsize{10pt}{10pt}\selectfont
%$$
%\begin{array}{c|ccccccc}
%\cdot & \mathcal{O} & (1,2) & (3,3) & (0,1) & (0,4) & (3,2) & (1,3)\\
%\hline
%\\
%\mathcal{O} & \mathcal{O} & (1,2) & (3,3) & (0,1) & (0,4) & (3,2) & (1,3)\\
%\\
%(1,2) & (1,2) & (3,3) & (0,1) & (0,4) & (3,2) & (1,3) & \mathcal{O}\\
%\\
%(3,3) & (3,3) & (0,1) & (0,4) & (3,2) & (1,3) & \mathcal{O} & (1,2)\\
%\\
%(0,1) & (0,1) & (0,4) & (3,2) & (1,3) & \mathcal{O} & (1,2) & (3,3)\\
%\\
%(0,4) & (0,4) & (3,2) & (1,3) & \mathcal{O} & (1,2) & (3,3) & (0,1)\\
%\\
%(3,2) & (3,2) & (1,3) & \mathcal{O} & (1,2) & (3,3) & (0,1) & (0,4)\\
%\\
%(1,3) & (1,3) & \mathcal{O} & (1,2) & (3,3) & (0,1) & (0,4) & (3,2)\\
%\end{array}
%$$
%\endgroup

%In what follows we choose our generator to be $g_{MNT6}=(1,2)$.

%In what follows we want to compute type 2 pairings on our MNT6 curve. We therefore need to extract the subgroup $\mathbb{G}_1$ as well as $\mathbb{G}_2$ from the full $7$-torsion group. Since the order of MNT6 is a prime number, we already know from XXX that $\mathbb{G}_1$ is given by
%$$\mathbb{G}_1=\{(1,2)\to (3,3)\to (0,1)\to (0,4)\to (3,2)\to (1,3)\to \mathcal{O}\}$$
%In type 2 pairings, the group $\mathbb{G}_2$ is defined by those elements $P$ of the full $7$-torsion group that are mapped to $5\cdot P$ under the Frobenius endomorphism XXX. Since $MNT6/\F_{5^6}$ contains $15680$ elements, we can still loop through all elements, to find the full $7$-torsion group and extract all elements from $\mathbb{G}_2$

%\begin{sagecommandline}
%sage: G.<x> = GF(5^6) # embedding degree is 6
%sage: MNT6 = EllipticCurve (G,[2 ,1])
%sage: INF = MNT6(0) # point at infinity
%sage: for P in INF.division_points(7): # PI(P) == [q]P
%....:     if P.order() == 7: # exclude point at infinity
%....:         PiP = MNT6([a.frobenius() for a in P])
%....:         qP = 5*P
%....:         if PiP == qP:
%....:             print(P.xy())
%\end{sagecommandline}

%\begin{multline*}
%\mathbb{G}_2=\{ 
%(x^3+2x^2+4x,x^5+2x^4+4x^3+3x^2+3)\to
%(x^5+4x^4+2x^3+3x^2+x+2,3x^4+2x^3+x)\to\\
%(4x^5+x^4+2x^3,3x^5+x^4+x^3+4x+4)\to
%(4x^5+x^4+2x^3,2x^5+4x^4+4x^3+x+1) \to\\
%(x^5+4x^4+2x^3+3x^2+x+2,2x^4+3x^3+4x)\to
%(x^3+2x^2+4x,4x^5+3x^4+x^3+2x^2+2)\to
%\mathcal{O}\}
%\end{multline*}
%We choose the generator $g_2 = (x^3+2x^2+4x,x^5+2x^4+4x^3+3x^2+3)$

%\begin{remark}
%Note however that our MNT6 curve discriminant $D=-16(4a^3 + 27 b^2)= -16(4\cdot 2^3 + 27\cdot 1^2)=-944$, while our MNT4 curve has discriminate XXX. Hence our example curves are not those guaranteed by theorem XXX. Those curve are both given by $y^2= x^3 + 2x +1$ over $\F_5$ and $\F_7$, respectively. However as both curves have the same defining equation, we rather choose examples that are visually distinguishable by their defining equations.




%\end{remark}


