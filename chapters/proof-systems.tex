\chapter{Proof Systems }
Proofs are the evidence of correctness of the assertions, and people can verify the cor-rectness by reading the proof. However, we obtain much more than the correctness itself:After you read one proof of an assertion, you know not only the correctness, but also why itis correct. Is it possible to solely show the correctness of an assertion without revealing theknowledge of proofs? It turns out that it is indeed possible, and this is the topic of today’slecture: Zero Knowledge Systems.
% from http://resources.mpi-inf.mpg.de/departments/d1/teaching/ss14/gitcs/notes6.pdf

\section{Pairing Based Proof Systems}

\subsection{Quadratic Arithmetic Programs} In chapter XXX we have introcuded algebraic circuit and their associated rank-1 constraints systems as two particular models able to represent space and time bounded computation. Both models define formal languages and associated membership as well as knowledge claim can be constructively proofed by executing thre circuit in order to compute solutions to its associated R1CS. 

One reason why those systems are useful in the context of succinct zero-knowledge proofing systems is because any R1CS can be transformed into another computational model called \textit{quadratic arithmetic programs}, which serves as the basic for some of the most efficient succinct non-interactiv zero-knowledge proof generators that currently exist. 

As we will ee, proofing statements for languages, which have checking relations defined by quadratic arithmetic programs, can be achieved by providing certain polynomials and those proofs can be verified by checking a particular divisibility property. 
\paragraph{QAP representation} To understand what quadratic arithmetic programs are in detail, let $\F$ be a field and $R$ a rank-1 constraints system over $\F$, such that the number of non zero elements in $\F$ is strictly larger then the number $k$ of constraints in $R$. Moreover let $a_j^i$, $b_j^i$ and $c_j^i\in\F$ for every index $0\leq j \leq n+m$ and $1\leq i \leq k$, be the defining constants of the R1CS and $m_1$, $\ldots$, $m_k$ be arbitrary, invertible and distinct elements from $\F$.
  
Then a \textbf{quadratic arithmetic program} [QAP] of the R1CS is the following set of polynomials over $\F$
\begin{equation}
QAP(R) = \left\{T\in \F[x],\left\{A_h,B_h,C_h\in \F[x]\right\}_{h=0}^{i+j}\right\}
\end{equation}
where $T(x) := \Pi_{l=1}^k (x- m_l)$ is a polynomial of degree $k$, called the \textbf{target polynomial} of the QAP and $A_j$, $B_j$ as well as $C_j$ are the unique degree $k-1$ polynomials defined by the equations
\begin{equation}
\begin{array}{lllr}
A_j(m_i)=a_j^i & B_j(m_i)=b_j^i & C_j(m_i)=C_j^i & j= 1, \ldots , n+m+1, i=1,\ldots,k 
\end{array}
\end{equation}
Given some rank-1 constraints system an associated quadratic arithmetic program is therefore nothing but a set of polynomials, computed from the constants in the R1CS. To see that the polynomials $A_j$, $B_j$ and $C_j$ are uniquely defined by the equations in XXX, recall that a a polynomial of degree $k-1$ is completely determined on $k$ evaluation points and the equation XXX precisely determines those $k$ evaluation points.

Since we only consider polynomials over fields, Langrange's interpolation method from XXX can be used to derive the polynomials $A_j$, $B_j$ and $C_j$ from their defining equations XXX. A practical method to compute a QAP from a given R1CS therefore consists of two steps. If the R1CS consists of $k$ constraints, first choose $k$ invertible and mutually different points from the underlaying field. Every choice defines a different QAP for the same R1CS. Then use Langrange's method and equation XXX to compute the polynomials $A_j$, $B_j$ and $C_j$ for every $1\leq j \leq k$. 
\begin{example}[Generalized factorization snark]  To provide a better intuition of quadratic arithmetic programs and how they are computed from their associated rank-1 constraint systems, consider the language $L_{3.fac\_zk}$ from example XXX and its associated R1CS
\begin{align*}
W_1 \cdot W_2 & = W_4 & \text{constraint } 1\\
W_4 \cdot W_3 & = I_1 & \text{constraint } 2
\end{align*}
In this example we want to transform this R1CS into an associated QAP. In a first step, we have to compute the defining constants $a_j^i$, $b_j^i$ and $c_j^i$ of the R1CS. According to XXX, we have
$$
\begin{array}{llllll}
a_0^1 = 0 & a_1^1= 0 & a_2^1= 1 & a_3^1 = 0 & a_4^1= 0  & a_5^1= 0 \\ 
a_0^2 = 0 & a_1^2= 0 & a_2^2= 0 & a_3^2 = 0 & a_4^2= 0  & a_5^2= 1 \\ 
\\
b_0^1 = 0 & b_1^1= 0 & b_2^1= 0 & b_3^1 = 1 & b_4^1= 0  & b_5^1= 0 \\ 
b_0^2 = 0 & b_1^2= 0 & b_2^2= 0 & b_3^2 = 0 & b_4^2= 1  & b_5^2= 0 \\ 
\\
c_0^1 = 0 & c_1^1= 0 & c_2^1= 0 & c_3^1 = 0 & c_4^1= 0  & c_5^1= 1 \\ 
c_0^2 = 0 & c_1^2= 1 & c_2^2= 0 & c_3^2 = 0 & c_4^2= 0  & c_5^2= 0 
\end{array} 
$$
Since the R1CS is defined over the field $\F_{13}$ and has two constraining equations, we need to choose two arbitrary but distinct elements $m_1$ and $m_2$ from $\F_{13}$. We choose $m_{1}=5$ and $m_{2}=7$ and with this choice we get the target polynomial
\begin{align*}
T(x) & = (x-m_1)(x-m_2) & \text{\# Definition of T}\\
     & = (x-5)(x-7)  & \text{\# Insert our choice}\\
     & = (x+8)(x+6)  & \text{\# Negatives in } \F_{13}\\
     & = x^2 + x +9 & \text{\# expand}
\end{align*}
Then we have to compute the polynomials $A_j$, $B_j$ and $C_j$ by their defining equation from the R1CS coefficients. Since the R1CS has two constraining equations, those polynomial will be of degree $1$ and are defined by their evaluation at the point $m_1=5$ and the point $m_2=7$. 

At point $m_1$, each polynomial $A_j$ is defined to be $a_j^1$ and at point $m_2$, each polynomial $A_j$ is defined to be $a_j^2$. The same holds true for the polynomials $B_j$ as well as $C_j$. Writing all these equations dow, we get:
$$
\begin{array}{llllll}
A_0(5)=0, & A_1(5)=0, & A_2(5)=1, & A_3(5)=0, & A_4(5)=0, & A_5(5)=0 \\
A_0(7)=0, & A_1(7)=0, & A_2(7)=0, & A_3(7)=0, & A_4(7)=0, & A_5(7)=1\\
\\
B_0(5)=0, & B_1(5)=0, & B_2(5)=0, & B_3(5)=1, & B_4(5)=0, & B_5(5)=0 \\
B_0(7)=0, & B_1(7)=0, & B_2(7)=0, & B_3(7)=0, & B_4(7)=1, & B_5(7)=0\\
\\
C_0(5)=0, & C_1(5)=0, & C_2(5)=0, & C_3(5)=0, & C_4(5)=0, & C_5(5)=1 \\
C_0(7)=0, & C_1(7)=1, & C_2(7)=0, & C_3(7)=0, & C_4(7)=0, & C_5(7)=0
\end{array}
$$
Langrange's interpolation implies, that a polynomial of degree $k$, that is zero on $k+1$ points has to be the zero polynomial. Since our polynomials are of degree $1$ and determined on $2$ points, we therefore know that in our QAP the only non zero polynomials are $A_2$, $A_5$, $B_3$, $B_4$, $C_1$ and $C_5$ and that we can use Langrange's interpolation to compute them. 

To compute $A_2$ we note that the set $S$ in our version of Langrange's methode is given by $S=\{(x_0,y_0), (x_1,y_1)\} = \{(5,1), (7,0)\}$. Using this set we get:
\begin{align*}
A_2(x) & = y_0\cdot l_0 + y_1\cdot l_1 \\
    & = y_0\cdot(\frac{x-x_1}{x_0-x_1}) + y_1\cdot(\frac{x-x_0}{x_1-x_0})
      = 1\cdot(\frac{x-7}{5-7}) + 0\cdot(\frac{x-5}{7-5}) \\
    & = \frac{x-7}{-2}
      = \frac{x-7}{11} & \text{\# } 11^{-1}=6 \\
    & = 6(x-7) 
      = 6x + 10 & \text{\# } -7 = 6 \text{ and } 6\cdot 6 = 10
\end{align*}
To compute $A_5$ we note that the set $S$ in our version of Langrange's methode is given by $S=\{(x_0,y_0), (x_1,y_1)\} = \{(5,0), (7,1)\}$. Using this set we get:
\begin{align*}
A_5(x) & = y_0\cdot l_0 + y_1\cdot l_1 \\
    & = y_0\cdot(\frac{x-x_1}{x_0-x_1}) + y_1\cdot(\frac{x-x_0}{x_1-x_0})
      = 0\cdot(\frac{x-7}{5-7}) + 1\cdot(\frac{x-5}{7-5}) \\
    & = \frac{x-5}{2} & \text{\# } 2^{-1}=7 \\
    & = 7(x-5) 
      = 7x + 4 & \text{\# } -5 = 8 \text{ and } 7\cdot 8 = 4
\end{align*}
Using Langranges interpolation we can deduce that $A_2=B_3=C_5$ as well as $A_5=B_4=C_1$, since they are polynomials of degree $1$ that evaluate to same values on $2$ points. Using this we get the follwing set of polynomials
\begin{center}
\begin{tabular}{|l|l|l|}\hline 
$A_{0}(x)=0 $ &$ B_{0}(x)=0   $ & $C_{0}(x)=0$ \tabularnewline\hline 
$A_1(x)=0 $ &$ B_1(x)=0   $ & $C_1(x)=7x+4$ \tabularnewline\hline 
$A_2(x)=6x+10$ &$ B_2(x)=0$ & $C_2(x)=0$ \tabularnewline\hline 
$A_3(x)=0    $ &$ B_3(x)=6x+10$ & $C_3(x)=0$ \tabularnewline\hline 
$A_4(x)=0$ &$ B_4(x)=7x+4  $ & $C_4(x)=0$ \tabularnewline\hline 
$A_5(x)=7x+4$ &$ B_5(x)=0      $ & $C_5(x)=6x+10$ \tabularnewline\hline 
\end{tabular}
\end{center}
Combining this computation, we the target polynomial we derive earlier gives a quadratic arithmetic program associated to the rank-1 constraint system $R_{3.fac\_zk}$ is given by
\begin{multline*}
QAP(R_{3.fac\_zk}) =\\
\scriptstyle \{x^{2}+x+9,\{0,6x+10,0,0,7x+4,0\},\{0,0,6x+10,7x+4,0,0\},\{0,0,0,0,6x+10,7x+4\}\}$$
\end{multline*}
\end{example}
\paragraph{QAP Satisfyability} One of the major points of quadratic arithmetic programs in proofing systems is, that solutions of their associated rank-1 constraints systems are in 1:1 correspondence with certain polynomials $P$, such that $P$ is divisible by the target polynomial $T$ of the QAP, if and only if the solution id a solution. Verifying solutions to the R1CS and hence checking proper circuit execution, is then achieveable by polynomial division of $P$ by $T$.

To be more specific, let $R$ be some rank-1 constraints system with associated assignment variables $(I_1,\ldots,I_n; W_1,\ldots, W_m)$ and let $QAP(R)$ be a quadratic arithmetic program of $R$. Then the tuple $(I_1,\ldots,I_n; W_1,\ldots, W_m)$ is a solution to the R1CS, if and only if the following polynomial is divisible by the target polynomial $T$:
\begin{equation}
P_{(I;W)} = \scriptstyle \left(A_0 + \sum_{j}^n I_j\cdot A_j + \sum_{j}^m W_j\cdot A_{n+j} \right) \cdot \left(B_0 + \sum_{j}^n I_j\cdot B_j + \sum_{j}^m W_j\cdot B_{n+j} \right) 
-\left(C_0 + \sum_{j}^n I_j\cdot C_j + \sum_{j}^m W_j\cdot C_{n+j} \right)
\end{equation}
Every typel $(I;W)$ defines a polynomial $P_{(I;W)}$ and since each polynomial $A_j$, $B_j$ and $C_j$ is of degree $k-1$, $P_{(I;W)}$ is of degree $(k-1)\cdot (k-1)= k^2 -2k +1$. 

To understand how quadratic arithmetic programs define formal languages, oberserve that every QAP over a fields $\F$ defines a decision function over the alphabet $\Sigma_I \times \Sigma_W = \F \times \F$ in the following way:
\begin{equation}
R_{QAP} : \F^* \times \F^* \to \{true, false\}\;;\;
(I;W) \mapsto
\begin{cases}
true & P_{(I;W)} \text{ is divisible by } T\\
false & else
\end{cases}
\end{equation}
Every QAP therefore defines a formal language and if the QAP is associated to an R1CS it can be shown that both languages are equivalent. A \textbf{statement} is a membership claim "There is a word $(I;W)$ in $L_{QAP}$". A proof to this claim is therefore a polynomial $P_{(I;W)}$, which is verfied by dividing $P_{(I;W)}$ by $T$.

Note the structural similarity to the definition of an R1CS in XXX and the different ways to compute proofs in both systems. For circuits and their associated rank-1 constraints systems a constructive proof consists of a valid assignment of field elements to the edges of the circuit, or the variables in the R1CS. However in the QAP picture a valid proof consists of a polynomial $P_{(I;W)}$.

Given some instance $I$, to compute a proof for a statement in $L_{QAP}$ a proofer first needs to compute a constructive proof $W$ e.g. by executing the circuit. With $(I;W)$ at hand the proofer can then compute the polynomial $P_{(I;W)}$ and publish it as proof.

Verifying a constructive proof in the circuit picture is achieved by executing the circuit and compare the result to the given proof and verifying the same proof in the R1CS picture means checking if the elements of the proof satisfy all equation. 

In contrast verifying a proof in the QAP picture is done by polynomial divide the proof $P$ by the target polynomial $T$ of the QAP. The proof checks, if and only if $P$ is divisible by $T$.
\begin{example} Consider the quadratic arithmetic program $QAP(R_{3.fac\_zk})$ from example XXX and its associated R1CS from example XXX. To give an intuition of how proofs in the language $L_{QAP(R_{3.fac\_zk})}$ lets consider the instance $I_1=11$. As we know from example XXX, $(W_1,W_2,W_3,W_5)=(2,3,4,6)$ is a proper witness, since 
$(I_1;W_1,W_2,W_3,W_5)=(11;2,3,4,6)$ is a valid circuit assignment and hence a solution to $R_{3.fac\_zk}$ and a constructive proof for language $L_{R_{3.fac\_zk}}$. 

In order to transform this constructive proof into a membership proof in language $L_{QAP(R_{3.fac\_zk})}$ a proofer has to use the elements of the constructive proof, to compute the polynomial $P_{(I;W)}$. 

In the case of $(I_1;W_1,W_2,W_3,W_5)=(11;2,3,4,6)$  the associated proof is computed as follows: 
\begin{align*}
P_{(I;W)}  = & \scriptstyle \left(A_0 + \sum_{j}^n I_j\cdot A_j + \sum_{j}^m W_j\cdot A_{n+j} \right) \cdot \left(B_0 + \sum_{j}^n I_j\cdot B_j + \sum_{j}^m W_j\cdot B_{n+j} \right) 
-\left(C_0 + \sum_{j}^n I_j\cdot C_j + \sum_{j}^m W_j\cdot C_{n+j} \right)\\
= & (2(6x+10)+6(7x+4))\cdot(3(6x+10)+4(7x+4))-(6(6x+10)+11(7x+4)) \\
= & ((12x+7)+(3x+11))\cdot((5x+4)+(2x+3))-((10x+8)+(12x+5)) \\
= & (2x+5)\cdot(7x+7)-(9x) \\
= & (x^{2}+2\cdot7x+5\cdot7x+5\cdot7)-(9x) \\
= & (x^{2}+x+9x+9)-(9x) \\
= & x^{2}+x+9
\end{align*}
Given instance $I_1=11$ a proofer therefore provides the puolynomial $x^2+x+9$ as proof. To verify this proof any verifier can then look up the target polynomial $T$ from the QAP and divide $P_{(I;W)}$ by $T$. In this particular example $P_{(I;W)}$ is equal to the target polynomial $T$ and hence it is divisible by $T$ with $P/T=1$. The verification therefore checks the proof.

To give an example of a false proof, consider the tuple $(I_1;W_1,W_2,W_3,W_4)=(11, 2, 3, 4, 8)$. Executing the circuit we can see that this is not a valid assignment and not a solution to the R1CS and hence not a constructive knowledge proof in $L_{3.fac\_zk}$. However a proofer might use these values to construct a false proof $P_{(I;W)}$:
\begin{align*}
P'_{(I;W)}  = & \scriptstyle \left(A_0 + \sum_{j}^n I_j\cdot A_j + \sum_{j}^m W_j\cdot A_{n+j} \right) \cdot \left(B_0 + \sum_{j}^n I_j\cdot B_j + \sum_{j}^m W_j\cdot B_{n+j} \right) 
-\left(C_0 + \sum_{j}^n I_j\cdot C_j + \sum_{j}^m W_j\cdot C_{n+j} \right)\\
= & (2(6x+10)+8(7x+4))\cdot(3(6x+10)+4(7x+4))-(8(6x+10)+11(7x+4)) \\
= & 8x^{2}+6
\end{align*}
Given instance $I_1=11$ a proofer therefore provides the puolynomial $8x^2+6$ as proof. To verify this proof any verifier can then look up the target polynomial $T$ from the QAP and divide $P_{(I;W)}$ by $T$. However polynomial division has a remainder
$$
(8x^{2}+6)/(x^{2}+x+9) =8+\frac{5x+12}{x^{2}+x+9} 
$$
This implies that $P_{(I;W)}$ is not divisible by $T$ and hence the verification does not check the proof. Any verfifier therefore showed that the proof is false.
\end{example}
\section{proof system}
% Intro from https://core.ac.uk/download/pdf/82198769.pdf


\subsection{Pairing Based SNARKS}
Technique. All pairing-based SNARKs in the literature follow a common paradigm
where the prover computes a number of group elements using generic group operations
and the verifier checks the proof using a number of pairing product equations. Bitansky
et al. [BCI+13] formalize this paradigm through the definition of linear interactive proofs
(LIPs). A linear interactive proof works over a finite field and the prover’s and verifier’s
messages consist of vectors of field elements. It furthermore requires that the prover
computes her messages using only linear operations. Once we have an approriate 2-move
LIP, it can be compiled into a SNARK by executing the equations “in the exponent”
using pairing-based cryptography. One source of our efficiency gain is that we design
a LIP system for arithmetic circuits where the prover only sends 3 field elements. In
comparison, the quadratic arithmetic programs by [GGPR13,PHGR13] correspond to
LIPs where the prover sends 4 field elements.
A second source of efficiency gain compared


Now a \textit{proof system} is nothing but a game between two parties, where one parties task is to convince the other party, that a given string over some alphabet is a statement is some agreed on language. To be more precise. Such a system is more over \textit{zero knowledge} if this possible without revealing any information about the (parts of) that string.
\begin{definition}[(Interactive) Proofing System]
% https://link.springer.com/content/pdf/10.1007/BF00195207.pdf
Let $L$ be some formal language over an alphabet $\Sigma$. Then an \textbf{interactive proof system} for $L$ is a pair $(P,V)$ of two probabilistic interactive algorithms, where $P$ is called the \textbf{prover} and $V$ is called the \textbf{verifier}. 

Both algorithms are able to send messages to one another. Each algorithm only sees its own state, some shared initial state and the communication messages. 

The verifier is bounded to a number of steps which is polynomial in the size of the shared initial state, after which it stops in an accept state or in a reject state. We impose no restrictions on the local computation conducted by the prover. 

We require that, whenever the verifier is executed the following two conditions hold:
\begin{itemize}
\item (Completeness) If a string $x\in \Sigma^*$ is a member of language $L$, that is $x\in L$ and both prover and verifier follow the protocol; the verifier will accept.
\item (Soundness) If a string $x\in \Sigma^*$ is not a member of language $L$, that is $x\notin L$ and the verifier follows the protocol; the verifier will not be convinced.
\item (Zero-knowledge) If a string $x\in \Sigma^*$ is a member of language $L$, that is $x\in L$ and the prover follows the protocol; the verifier will not learn anything about $x$ but $x\in L$.
\end{itemize}
\end{definition}

In the context of zero knowledge proving systems definition XXX gets a slight adaptation:
\begin{itemize}
\item Instance: Input commonly known to both prover (P) and verifier (V), and used to support the statement of what needs to be proven. This common input may either be local to the prover-verifier interaction, or public in the sense of being known by external parties (Some scientific articles use "instance" and "statement" interchangeably, but we distinguish between the two.).
\item Witness: Private input to the prover. Others may or may not know something about the witness.
\item Relation: Specification of relationship between instances and witness. A relation can be viewed as a set of permissible pairs (instance, witness).
\item Language: Set of statements that appear as a permissible pair in the given relation.
\item Statement:Defined by instance and relation. Claims the instance has a witness in the relation(which is either true or false).
\end{itemize}

The following subsections define ways to describe checking relations that are particularly useful in the context of zero knowledge proofing systems

\subsection{Succinct NIZK}
Preprocessing style: trusted setup, multi party ceremony

Blum, Feldman and Micali
% Manuel  Blum,  Paul  Feldman,  and  Silvio  Micali.   Non-interactive  zero-knowledge  and  itsapplications.  InSTOC, pages 103–112, 1988.
 extended the notion tonon-interactivezero-knowledge(NIZK)  proofs in the  common  reference  string  model.  NIZK  proofs  are  useful  in  theconstruction of non-interactive cryptographic schemes, e.g., digital signatures and CCA-secure public key encryption.
 
\begin{definition} 
Let $\mathcal{R}$ be a relation generator that given a security parameter $\lambda$ in unary returns a polynomial time decidable binary relation $R$. For pairs $(i,w)\in R$ we call $i$ the instance\footnote{Note that in Groth16 this is called the statement. We think the term instance is more consistent with SOMETHING. } and $w$ the witness. We define $R_\lambda$ to be the set of possible relations $R$ the relation generator may output given $1^\lambda$. We will in the following for notational simplicity assume $\lambda$ can be deduced from the description of $R$. The relation generator may also output some side information, an auxiliary input $z$, which will be given to the adversary. An efficient prover publicly verifiable non-interactive argument for $R$ is a quadruple of probabilistic polynomial algorithms $(\textsc{Setup},\textsc{Prove},\textsc{Vfy},\textsc{Sim})$ such 
\begin{itemize}
\item Setup: $(CRS,\tau)\rightarrow Setup(R)$: The setup produces a common reference string $CRS$ and a simulation trapdoor $\tau$ for the relation $R$.
\item Proof: $\pi\rightarrow Prove(R,CRS,i,w)$: The prover algorithm takes as input a common reference string $CRS$ and a statement $(i,w)\in R$ and returns an argument $\pi$.
\item Verify: $0/1\rightarrow Vfy(R,CRS,i,\pi)$: The  verification algorithm  takes as input a common reference string $CRS$, an instance $i$ and an argument $\pi$ and returns 0 (reject) or 1 (accept).
\item $\pi\rightarrow Sim(R,\tau,i)$: The simulator takes as input a simulation trapdoor $\tau$ and instance $i$ and returns an argument $\pi$. 
\end{itemize}
\end{definition}

\paragraph{Common Reference String Generation}
Also called trusted setup phase. The field elements needed in this step are called toxic waste ...

\subparagraph{Trusted third party} The most simple approach to generate a common reference string is a so called \textit{trusted third party}. By assumption the entire systems trusts this party to generate the common reference string exactly accoring to the rules and the party will delete all traces of the toxic waste after CRS generation.

\subparagraph{Player exchangeable Multi Party Ceremonies}

Achive soundness if only a single party is honest and correctly deletes toxix waste. Is always zero knowledge.

State of the art
%https://eprint.iacr.org/2017/1050.pdf
works in the random beacon model. 

A random beacon produces publicly available and verifyable random values at fixed intervals. The difference between random beacons and random oracles, is that random beacons are not available until certain time slots. Random beacons can be instanciated for example by evaluation of say $2^{40}$ iterations of SHA256 on some high entropy, publically available data like the closing value of the stock market on a certain date, the output of a selected set of national lotteries and so on. 

The assumption is that any given random beacon value contains large amounts of entropy that is independent from the influence of an adversary in previous time slots. 




\subsubsection{Groth16}
Groth’s  constant  size  NIZK  argument  is  based  on  constructing  a  set  of  polynomial equations and using pairings to efficiently verify these equations. Gennaro, Gentry,Parno and Raykova [Pinocchio] found an insightful construction of polynomial equations based on Lagrange interpolation polynomials yielding a pairing-based NIZK argumentwith a common reference string size proportional to the size of the statement and wit-ness.

It constructs a snark  for arithmetic circuit satisfiability, where a proof consists of only 3 group elements. In addition to being small, the proof is also easy to verify. The verifier just needs to compute a number of exponentiations proportional to the instance size and check a single pairing product equation, which only  has  3  pairings.  

The  construction  can  be  instantiated  with  any  type  of  pairings including Type III pairings, which are the most efficient pairings. The argument has perfect completeness and perfect zero-knowledge. For soundness ?? 

In the common reference string model.

Setup: 
\begin{itemize}
\item random elements $\alpha,\beta,\gamma, \delta, s \in \mathbb{F}_{scalar}$ 
\item Common reference string $CRS_{QAP}$, specific to the $QAP$ and the choice of statement and witness $CRS_{QAP}= (CRS_{\mathbb{G}_1},CRS_{\mathbb{G}_2})$, with $n=deg(t)$: 
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
[\alpha]g,[\beta]g,[\delta]g,\left\{ [s^{k}]g\right\} _{k=0}^{n-1},\left\{ [\frac{\beta a_{k}(s)+\alpha b_{k}(s)+c_{k}(s)}{\gamma}]g\right\} _{k\in I}\\
\left\{ [\frac{\beta a_{k}(s)+\alpha b_{k}(s)+c_{k}(s)}{\delta}]g\right\} _{k\in W},\left\{ [\frac{s^{k}t(s)}{\delta}]g\right\} _{k=0}^{n-2}
\end{array}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{ [\beta]h ,[\gamma]h,[\delta]h,\left\{[s^k]h\right\} _{k=0}^{n-1}\right\} 
$$
\item Toxic waste: Must delete random elements after $CRS_{QAP}$ generation.
\end{itemize} 

\begin{example}[Generalized factorization snark]
\label{main_example_2_5}
In this example we want to compile our main example in Groth16. Input is the R1CS from example \ref{main_example_2_4}. We choose the following global parameters

\begin{tabular}{ccccc}
\\
curve = BLS6-6 & $\mathbb{G}_1=$ BLS6-6(13) & $g = (13,15) $
& $\mathbb{G}_2=$ & $h=(7v^2,16v^3)$ and $\mathbb{G}_T = \F_{43^6}^*$.
\end{tabular} 
\end{example}
\begin{example}[Trusted third party for the factorization snark]
We consider ourself as a trusted third part to generate the common reference string for our generalized factorization snark. We therefore choose the following secret field elements $\alpha=6$, $\beta=5$, $\gamma=4$, $\delta=3$, $s=2$ from $\mathbb{F}_{13}$ and are very careful to hide them from anyone how hasn't read this book. From those values we can then instantiate the common reference string XXX:
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
[6](13,15),[5](13,15),[3](13,15),\left\{ [s^{k}](13,15)\right\} _{k=0}^{1},\left\{ [\frac{5 a_{k}(2)+6 b_{k}(2)+c_{k}(2)}{4}](13,15)\right\} _{k\in S}\\
\left\{ [\frac{5 a_{k}(2)+6 b_{k}(2)+c_{k}(2)}{3}](13,15)\right\} _{k\in W},\left\{ [\frac{s^{k}t(2)}{3}](13,15)\right\} _{k=0}^{0}
\end{array}\right\}
$$
Since we have instance indices $I=\{1, in_1,in_2\}$ and witness indices $W=\{in_3,mid_1,out_1\}$ we have 
The instance parts.
\begin{multline*}
\left[\frac{5 a_{c}(2)+6 b_{c}(2)+c_{c}(2)}{4}\right](13,15) = 
\left[\frac{5\cdot 0 +6\cdot 0 + 0 }{4}\right](13,15) =
\left[0\right](13,15) = \mathcal{O}
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{in_3}(2)+6 b_{in_3}(2)+c_{in_3}(2)}{4}\right](13,15) =
\left[(5\cdot 0+6\cdot(7\cdot 2 +4)+0)\cdot 10\right](13,15) =\\
\left[(6\cdot 5 )\cdot 10\right](13,15) =
\left[1\right](13,15) =
(13,15)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{out}(2)+6 b_{out}(2)+c_{out}(2)}{4}\right](13,15) = 
\left[(5\cdot 0 +6\cdot 0 + (7\cdot 2 + 4))\cdot 10 \right](13,15) =\\
\left[5\cdot 10 \right](13,15) =
\left[11\right](13,15) = 
(33,9)
\end{multline*}

Witness part:
\begin{multline*}
\left[\frac{5 a_{in_1}(2)+6 b_{in_1}(2)+c_{in_1}(2)}{3}\right](13,15) = 
\left[(5\cdot (6\cdot 2 +10) +6\cdot 0 +0 )\cdot 9\right](13,15) = \\
\left[(5\cdot 9)\cdot 9\right](13,15) =
\left[2\right](13,15) = (33,34)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{in_2}(2)+6 b_{in_2}(2)+c_{in_2}(2)}{3}\right](13,15) = 
\left[(5\cdot 0 +6\cdot (6\cdot 2 + 10) + 0 )\cdot 9\right](13,15) = \\
\left[(6\cdot 9)\cdot 9\right](13,15) =
\left[5\right](13,15) =
(26,34)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{mid_1}(2)+6 b_{mid_1}(2)+c_{mid_1}(2)}{3}\right](13,15) = 
\left[(5\cdot (7\cdot 2 + 4) +6\cdot 0 + 0 )\cdot 9\right](13,15) = \\
\left[(5\cdot 5)\cdot 9\right](13,15) =
\left[4\right](13,15) =
(35,28)
\end{multline*}
For $\left\{\left[\frac{s^{k}t(2)}{3}\right](13,15)\right\} _{k=0}^{0}$ we get
\begin{multline*}
\left[\frac{2^{0}t(2)}{3}\right](13,15)=
[t(2)\cdot 9](13,15)= 
[(2^2+2+9)\cdot 9](13,15)= 
[5](13,15) =
(26,34)
\end{multline*}
All together, the $\mathbb{G}_1$ part of the CRS is:
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\left\{(13,15),(33,34)\right\},
\left\{\mathcal{O}, (13,15), (33,9)\right\}\\
\left\{(33,34),(26,34),(35,28)\right\},
\left\{(26,34)\right\}
\end{array}\right\}
$$
To compute the $\mathbb{G}_2$ part 
$$
CRS_{\mathbb{G}_{2}}=\left\{ [5](7v^2,16v^3) ,[4](7v^2,16v^3),[3](7v^2,16v^3),\left\{[2^k](7v^2,16v^3)\right\} _{k=0}^{1}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{ [5](7v^2,16v^3) ,[4](7v^2,16v^3),[3](7v^2,16v^3),\left\{[1](7v^2,16v^3), [2](7v^2,16v^3)\right\}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\left\{(7v^2,16v^3), (10v^2,28v^3)\right\}\right\} 
$$

So alltogether our common reference string is 
$$
\begin{pmatrix}
\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\left\{(13,15),(33,34)\right\},
\left\{\mathcal{O}, (13,15), (33,9)\right\}\\
\left\{(33,34),(26,34),(35,28)\right\},
\left\{(26,34)\right\}
\end{array}\right\}\\
\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\left\{(7v^2,16v^3), (10v^2,28v^3)\right\}\right\}
\end{pmatrix}
$$
\end{example}
\begin{example}[Player exchangeable multi party ceremony for the factorization snark] In this example we want to simulate a real world player exchangeable multi party ceremony for our factorization snark XXX as explained in XXX.

We use our TinyMD5 hash function XXX to hash to $\mathbb{G}_2$.


We assume that we have a coordinator $Alice$ together with three parties $Bob$, $Carol$ and $Dave$ that want to contribute their randomness to the protocol. Since the degree $n$ of the target polynomial is $2$, we need to compute the common reference string
$$
CRS= \left\{\right\}
$$
For contributer $j>0$ in phase $l$ to compute the proof of knowledge XXX, we need to define the $transcript_{l,j-1}$ of the previous round. We define it as sha256 of $MPC_{l,j-1}$. To be more precise we define
$$
transcript_{1,j-1}= 
MD5(
'[s]g_1 [s]g_2 [s^2] g_1 [\alpha]g_1 [\alpha\cdot s]g_1
[\beta]g_1 [\beta]g_2[\beta \cdot s]g_1'
)
$$
The only thing actually important about the transcript, is that it is publically available data that is not accesable for anyone before the MPC-data of round $j-1$ in phase $l$ exists.

We start with the first round usually called the 'powers of tau' EXPLAIN THAT TERM...
The computation is initialized With $s=1$, $\alpha=1$, $\beta=1$. Hence the computation starts with the following data
$$
MPC_{1,0}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (13,15)\\ 
{}[\alpha\cdot s]g_1 &=& (13,15)\\ 
([\beta]g_1,[\beta]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[\beta \cdot s]g_1 &=& (13,15)
\end{array}
\right\}
$$
Then 
\begin{multline*}
transcript_{1,0}=\\ 
MD5('(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)') =\\ f2baea4d3dba5eef5c63bb210920e7d9
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)(13,15)(13,15)(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)" | md5sum$
% note the actual code is printf '%s' "(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)" | md5sum

Everyone agreed, that the MPC starts on the 21.03.2020 and everyone can contribute for exactly a year until the 20.03.2021. 


  
It then proceeds in a round robin style, starting with Bob, who optains that data in $MPC_{1,0}$ and then computes his contribution. Lets assume that $Bob$ is honest and that bought 
a 13-sided dice (PICTURE OF 13-SIDED DICE) to randomly find three secret field values from our prime field $\F_{13}$. He though the dice and got $\alpha = 4$, $\beta=8$ and $s= 2$. He then updates $MPC_{1,0}$:  
$$
MPC_{1,1}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([2](13,15),[2](7v^2,16v^3)) &=& ((33,34),(10v^2,28v^3))\\ 
{}[s^2] g_1 &=& [4](13,15)&=& (35,28)\\
{}[\alpha]g_1 &=& [4](13,15)&=& (35,28)\\ 
{}[\alpha\cdot s]g_1 &=& [8](13,15) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([8](13,15),[8](7v^2,16v^3))&=& ((26,9),(16v^2,15v^3))\\ 
{}[\beta \cdot s]g_1 &=& [3](13,15)&=& (38,15)
\end{array}
\right\}
$$
In addition he compute 
$$
POK_{1,1} \left\{
\begin{array}{lcl}
y_{s} &=& POK(2, f2baea4d3dba5eef5c63bb210920e7d9) = ((33,34),(16v^2 , 28v^3))\\
y_{\alpha} &=& POK(4, f2baea4d3dba5eef5c63bb210920e7d9) = ((35,28),(10v^2 , 15v^3))\\ 
y_{\beta} &=& POK(8, f2baea4d3dba5eef5c63bb210920e7d9) = ((26,9),(16v^2 , 28v^3))\\
\end{array}
\right\}
$$
since $[s]g_1 = (33,34)$, $[\alpha] g_1 = (35,28)$ and $[\beta] g_1 = (26,9)$. as well as 
\begin{align*}
TinyMD5_{2}('(33,34)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(33,34)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(2066b3b6b6d97c46c3ac6ee2ccd23ad9.trunc(3))= H_2(ad9) = \\
H_2(101 011 011 001)=\\
[8\cdot 4^{1}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{1}](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[3](7v^2 , 16v^3)+
[2](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[4](10v^2 , 15v^3 )=\\
[3](7v^2 , 16v^3)+
[2*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[4*11](7v^2 , 16v^3 )=\\
(42v^2 , 16v^3)+
(17v^2 , 28v^3 )+
(16v^2 , 15v^3 ) +
(16v^2 , 28v^3 )=\\
[3](7v^2 , 16v^3)+
[6](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[5](7v^2 , 16v^3 )=\\
[3+6+8+5](7v^2 , 16v^3)=
(37v^2 , 16v^3 )
\end{align*}
So we get $[2](37v^2 , 16v^3 )= (16v^2 , 28v^3 )$

===================

\begin{align*}
TinyMD5_{2}('(35,28)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(35,28)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(ad54fa3674f6a84fab9208d7a94c9163.trunc(3))= H_2(163) = \\
H_2(000 101 100 011)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{0}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 3](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[6](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[6*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(16v^2 , 15v^3)+
(10v^2 , 28v^3 )+
(42v^2 , 16v^3 ) +
(17v^2 , 28v^3 )=\\
[8](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[3](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[8+2+3+6](7v^2 , 16v^3)=
(17v^2 , 28v^3 )
\end{align*}
So we get $[4](17v^2 , 28v^3 )= (10v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(26,9)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(26,9)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(b87b632f7027ad78cadc2452beb30e9a.trunc(3))= H_2(e9a) = \\
H_2(111 010 011 010)=\\
[8\cdot 4^{1}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 4\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[1](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[1*11](7v^2 , 16v^3 )=\\
(10v^2 , 28v^3)+
(37v^2 , 27v^3 )+
(16v^2 , 15v^3 ) +
(10v^2 , 15v^3 )=\\
[2](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[11](7v^2 , 16v^3 )=\\
[2+4+8+11](7v^2 , 16v^3)=
(7v^2 , 27v^3 )
\end{align*}
So we get $[8](17v^2 , 28v^3 )= (16v^2 , 28v^3 )$

So Bob publishes $MPC_{1,1}$ as well as $POK_{1,1}$ and after that its Carols turn. Lets also assume that Carrol is honest. So Carol looks at Bobs data and compute the transcript according to our rules
\begin{multline*}
transcript_{1,1}=\\ 
MD5('
(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)') =\\ fe72e18b90014062682a77136944e362
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)" | md5sum$

Carol then computes here contribution. Since she is honest she chooses randomly three secret field values from our prime field $\F_{13}$, by invoking her compter. She found $\alpha = 3$, $\beta=4$ and $s= 9$ and updates $MPC_{1,1}$:  
$$
MPC_{1,2}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([9](33,34),[9](10v^2,28v^3)) &=&  ((26,34),(16v^2,28v^3))\\ 
{}[s^2] g_1 &=& [9\cdot 9](35,28) &=& (13,28)\\
{}[\alpha]g_1 &=& [3](35,28) &=& (13,28) \\ 
{}[\alpha\cdot s]g_1 &=& [3\cdot 9](26,9) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([4](26,9),[4](16v^2,15v^3)) &=& ((27,34),(17v^2,28v^3))\\ 
{}[\beta \cdot s]g_1 &=& [4\cdot 9](38,15) &=& (35,28)
\end{array}
\right\}
$$
In addition he compute 
$$
POK_{1,2} \left\{
\begin{array}{lcl}
y_{s} &=& POK(9, fe72e18b90014062682a77136944e362) = ((35,15),(17v^2 , 28v^3))\\
y_{\alpha} &=& POK(3, fe72e18b90014062682a77136944e362) = ((38,15),(17v^2 , 15v^3 ))\\ 
y_{\beta} &=& POK(4, fe72e18b90014062682a77136944e362) = ((35,28),(42v^2 , 27v^3 ))\\
\end{array}
\right\}
$$

\begin{align*}
TinyMD5_{2}('(35,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(115f145ceffdda73e916dc5ba8ae7354.trunc(3))= H_2(354) = \\
H_2(001 101 010 100)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{1}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 7](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9](17v^2 , 15v^3 ) +
[3\cdot 6](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[5](17v^2 , 15v^3 ) +
[5](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[5*7](7v^2 , 16v^3 ) +
[5*11](7v^2 , 16v^3 )=\\
(37v^2 , 27v^3)+
(10v^2 , 28v^3 )+
(37v^2 , 16v^3 ) +
(42v^2 , 16v^3 )=\\
[4](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[9](7v^2 , 16v^3 ) +
[3](7v^2 , 16v^3 )=\\
[4+2+9+3](7v^2 , 16v^3)=
(16v^2 , 28v^3 )
\end{align*}
So we get $[9](16v^2 , 28v^3 )= (17v^2 , 28v^3 )$

\begin{align*}
TinyMD5_{2}('(38,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(38,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(cc4da0c02c4c1b15e72d6cc6430206ab.trunc(3))= H_2(6ab) = \\
H_2(011 010 101 011)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 3\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[1](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[1*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(17v^2 , 28v^3 )+
(17v^2 , 15v^3 ) +
(17v^2 , 28v^3 )=\\
[7](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[7](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[7+4+7+6](7v^2 , 16v^3)=
(10v^2 , 15v^3)
\end{align*}
So we get $[3](10v^2 , 15v^3 )= (17v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(35,28)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,28)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(502323bc55c75f7189fad7999c9f1708.trunc(3))= H_2(708) = \\
H_2(011 100 001 000)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[2\cdot 11](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[9](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12*3](7v^2 , 16v^3 )+
[9*7](7v^2 , 16v^3 ) +
[3*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(42v^2 , 27v^3 )+
(10v^2 , 15v^3 ) +
(17v^2 , 15v^3 )=\\
[7](7v^2 , 16v^3)+
[10](7v^2 , 16v^3 )+
[11](7v^2 , 16v^3 ) +
[7](7v^2 , 16v^3 )=\\
[7+10+11+7](7v^2 , 16v^3)=
(37v^2 , 16v^3)
\end{align*}
So we get $[4](37v^2 , 16v^3 )= (42v^2 , 27v^3 )$

Dave thinks he can outsmart the syste, Since he is the last to contribute, he just makes up an entirely new $MPC$, that does not contain any randomness from the previous contributers. He thinks he can do that because, no one can distinguish his $MPC_{1,3}$ from a correct one. If this is done in a smart way, he will even be able to compute the correct $POK$s. 

So Dave choses $s=12$, $\alpha=11$ and $\beta=10$ and he will keep those values, hoping to be able to use them later to forge false proofs in the factorization snark. He then compute  
$$
MPC_{1,3}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,28),(7v^2,27v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (33,9)\\ 
{}[\alpha\cdot s]g_1 &=& (33,34)\\ 
([\beta]g_1,[\beta]g_2) &=& ((38,28),(42v^2,27v^3))\\ 
{}[\beta \cdot s]g_1 &=& (38,15)
\end{array}
\right\}
$$
Dave does not delete $s$, $\alpha$ and $\beta$, because if this is accepted as phase one of the common reference string computation, Dave controls already $3/4$-th of the cheating key to forge proofs. So Dave is careful to get the proofs of knowledge right. He computes the transcript of Carols contribution as 

\begin{multline*}
transcript_{1,2}=\\ 
MD5('
(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)') =\\ c8e6308fffd47009f5f65e773ae4b499
\end{multline*}

We obtain that hash by computing

$printf '\%s' "(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)" | md5sum$

\end{example}
